<!DOCTYPE html>
<!-- @noSnoop -->
<html lang="en" xmlns:b="http://www.tridium.com/baja/baja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Murphy Control Panel - AHU Monitoring</title>

<!-- Add RequireJS and BajaScript Support -->
<script type='text/javascript' src='/requirejs/config.js'></script>
<script type='text/javascript' src='/module/js/com/tridium/js/ext/require/require.min.js?'></script>

<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --success-color: #27ae60;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --info-color: #17a2b8;
            --light-color: #ecf0f1;
            --dark-color: #34495e;
            --text-color: #2c3e50;
            --bg-color: #ffffff;
            --card-bg: #ffffff;
            --border-color: #bdc3c7;
        }

        [data-theme="dark"] {
            --text-color: #ecf0f1;
            --bg-color: #1a1a1a;
            --card-bg: #2c2c2c;
            --border-color: #444444;
            --primary-color: #3498db;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg-color) 0%, var(--light-color) 100%);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
            transition: all 0.3s ease;
        }

        [data-theme="dark"] body {
            background: linear-gradient(135deg, #1a1a1a 0%, #2c2c2c 100%);
        }

        .toggle-container {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            background: var(--card-bg);
            padding: 10px 15px;
            border-radius: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .toggle-label {
            font-size: 14px;
            font-weight: 500;
        }

        .toggle-switch {
            width: 50px;
            height: 25px;
            background: var(--border-color);
            border-radius: 25px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .toggle-switch.active {
            background: var(--primary-color);
        }

        .toggle-slider {
            width: 21px;
            height: 21px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(25px);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: var(--card-bg);
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .header h1 {
            color: var(--primary-color);
            margin-bottom: 10px;
            font-size: 2.5rem;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            min-width: 120px;
        }

        .btn-success { background: var(--success-color); color: white; }
        .btn-danger { background: var(--danger-color); color: white; }
        .btn-info { background: var(--info-color); color: white; }
        .btn-primary { background: var(--primary-color); color: white; }
        .btn-secondary { background: var(--dark-color); color: white; }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .monitoring-status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 18px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .monitoring-active {
            background: var(--success-color);
            color: white;
            animation: pulse 2s infinite;
        }

        .monitoring-inactive {
            background: var(--danger-color);
            color: white;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .bubbleSP {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border-left: 5px solid var(--primary-color);
            transition: all 0.3s ease;
        }

        .bubbleSP:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .point-status {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
        }

        .status-ok {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
        }

        .status-error {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .status-display {
            background: var(--card-bg);
            color: var(--text-color);
            border: 2px solid var(--border-color);
        }

        .status-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .status-details p {
            margin-bottom: 5px;
            font-size: 14px;
        }

        .overall-summary {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border-left: 5px solid var(--success-color);
        }

        /* Graph Viewer Styles */
        .graph-viewer {
            display: none;
            background: var(--card-bg);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .graph-viewer.active {
            display: block;
        }

        .graph-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .unit-selector, .point-selector {
            padding: 10px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: var(--card-bg);
            color: var(--text-color);
            font-size: 14px;
            min-width: 150px;
        }

        .time-range-selector {
            padding: 10px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: var(--card-bg);
            color: var(--text-color);
            font-size: 14px;
        }

        .graph-container {
            width: 100%;
            height: 400px;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            background: var(--card-bg);
            position: relative;
            overflow: hidden;
        }

        .graph-canvas {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .graph-title {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: var(--primary-color);
        }

        .graph-legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        .no-data-message {
            text-align: center;
            color: var(--text-color);
            font-size: 16px;
            margin-top: 50px;
        }

        .graph-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .stat-label {
            font-size: 14px;
            color: var(--text-color);
            margin-top: 5px;
        }

        .main-view {
            display: block;
        }

        .main-view.hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .controls {
                justify-content: center;
            }
            
            .btn {
                min-width: 100px;
                font-size: 14px;
                padding: 10px 20px;
            }
            
            .graph-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .unit-selector, .point-selector, .time-range-selector {
                width: 100%;
            }
        }
        
        
        
        
        
        
        
        
     /* Export Controls Styling */
        .export-controls {
            position: relative;
            display: inline-block;
            margin: 0 5px;
        }

        .dropdown {
            position: relative;
        }

        .dropdown-toggle {
            background: #17a2b8 !important;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dropdown-toggle:hover {
            background: #138496 !important;
        }

        .dropdown-arrow {
            font-size: 12px;
            transition: transform 0.2s;
        }

        .dropdown.open .dropdown-arrow {
            transform: rotate(180deg);
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 200px;
            display: none;
            z-index: 1000;
            margin-top: 2px;
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-item {
            display: block;
            width: 100%;
            padding: 10px 15px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
            color: #333;
            border-bottom: 1px solid #eee;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background: #f8f9fa;
            color: #007bff;
        }

        /* Data Controls */
        .data-controls {
            display: inline-block;
            margin: 0 10px;
        }

        .data-controls .btn {
            margin: 0 2px;
        }

        /* Status Information */
        .status-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .status-item {
            display: flex;
            flex-direction: column;
            min-width: 150px;
        }

        .status-label {
            font-weight: bold;
            color: #495057;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .status-item span:last-child {
            color: #28a745;
            font-weight: 500;
            font-size: 14px;
        }

        /* Dark mode status info */
        .dark-mode .status-info {
            background: #2c3e50;
            border-color: #34495e;
        }

        .dark-mode .status-label {
            color: #bdc3c7;
        }

        .dark-mode .status-item span:last-child {
            color: #2ecc71;
        }

        /* Dark mode dropdown */
        .dark-mode .dropdown-menu {
            background: #34495e;
            border-color: #2c3e50;
        }

        .dark-mode .dropdown-item {
            color: #ecf0f1;
            border-bottom-color: #2c3e50;
        }

        .dark-mode .dropdown-item:hover {
            background: #2c3e50;
            color: #3498db;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                gap: 10px;
            }

            .export-controls, .data-controls {
                width: 100%;
            }

            .dropdown-toggle {
                width: 100%;
                justify-content: center;
            }

            .status-info {
                flex-direction: column;
                gap: 10px;
            }

            .status-item {
                min-width: auto;
            }
        }   
        
        .main-content {
flex: 1;
background: linear-gradient(to right,#010f35, #175f80,#266c79, #12707d);
position: relative;
display: flex;
justify-content: center;
align-items: center;
padding: 20px;
}
    </style>
</head>
<body>
<div class="main-content">
        <!-- Toggle Switch -->
        <div class="toggle-container">
            <span class="toggle-label">Light Mode</span>
            <div class="toggle-switch" id="toggleSwitch">
                <div class="toggle-slider"></div>
            </div>
        </div>

        <div class="container">
            <div class="header">
                <h1>üè¢ Niagara System Monitor</h1>
                <p id="currentDateTime"></p>
            </div>
            
            <div class="controls">
                <button class="btn btn-success" onclick="startMonitoring()">‚ñ∂Ô∏è Start Monitoring</button>
                <button class="btn btn-danger" onclick="stopMonitoring()">‚èπÔ∏è Stop Monitoring</button>
                
                <!-- Export Controls Group -->
                <div class="export-controls">
                    <div class="dropdown">
                        <button class="btn btn-info dropdown-toggle" id="exportDropdown">
                            üì§ Export Data
                            <span class="dropdown-arrow">‚ñº</span>
                        </button>
                        <div class="dropdown-menu" id="exportMenu">
                            <button class="dropdown-item" onclick="exportLogs()">üìä Export CSV Logs</button>
                            <button class="dropdown-item" onclick="exportEventLogsJSON()">üìã Export Logs JSON</button>
                            <button class="dropdown-item" onclick="exportFullDataJSON()">üíæ Export Full Data JSON</button>
                            <button class="dropdown-item" onclick="exportAllFormats()">üîÑ Export All Formats</button>
                        </div>
                    </div>
                </div>
                
                <!-- Data Management Controls -->
                <div class="data-controls">
                    <button class="btn btn-primary" onclick="saveDataWithJSON()">üíæ Save + JSON Backup</button>
                    <button class="btn btn-secondary" onclick="toggleAutoBackup()" id="autoBackupBtn">üîÑ Toggle Auto-Backup</button>
                </div>
                
                <button class="btn btn-danger" onclick="clearLogs()">üóëÔ∏è Clear Logs</button>
                <button class="btn btn-primary" onclick="toggleGraphViewer()">üìä View Graphs</button>
            </div>
            
            <div id="monitoringStatus" class="monitoring-status monitoring-active">MONITORING ACTIVE</div>
            
            <!-- Status Information -->
            <div class="status-info">
                <div class="status-item">
                    <span class="status-label">Data Status:</span>
                    <span id="dataStatus">Loading...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Last Saved:</span>
                    <span id="lastSaveTime">Never</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Auto-Backup:</span>
                    <span id="autoBackupStatus">Disabled</span>
                </div>
            </div>
           <!-- Graph Viewer Section -->
<div id="graphViewer" class="graph-viewer">
    <div class="graph-title">üìä System Data Visualization</div>
    
    <div class="graph-controls">
      
      <!--POINTS-->
        <select id="unitSelector" class="unit-selector" onchange="updatePointSelector()">
            <option value="">Select Unit...</option>
        </select>
        
        <select id="pointSelector" class="point-selector" onchange="updateGraph()">
            <option value="">Select Point...</option>
        </select>
        
        <div class="control-group">
            <label for="timeRangeSelector" class="control-label">Time Range:</label>
            <select id="timeRangeSelector" class="unit-selector" onchange="updateGraph()">
                <option value="all">All Data (Selected Date)</option>
                <option value="60">Last Hour (of Selected Date)</option>
                <option value="180">Last 3 Hours (of Selected Date)</option>
                <option value="360">Last 6 Hours (of Selected Date)</option>
                <option value="720">Last 12 Hours (of Selected Date)</option>
            </select>
        </div>
                
        <div class="control-group">
            <label for="numeric-input" class="control-label">Select Date:</label>
            <input type="date" id="numeric-input" class="unit-selector" title="Select date to filter data">
        </div>
        
        <!-- JSON Import Button -->
        <div class="control-group">
            <input type="file" id="jsonFileInput" accept=".json" style="display: none;" onchange="importJSONData(event)">
            <button class="btn btn-primary" onclick="document.getElementById('jsonFileInput').click()">
                üìÅ Import JSON Data
            </button>
        </div>
        
        <button class="btn btn-secondary" onclick="toggleGraphViewer()">‚Üê Back to Logs</button>
    </div>
                
                <div class="graph-container">
                    <canvas id="graphCanvas" class="graph-canvas"></canvas>
                    <div id="noDataMessage" class="no-data-message" style="display: none;">
                        No data available for the selected point and time range.
                    </div>
                </div>
                
                <div class="graph-legend" id="graphLegend"></div>
                
                <div class="graph-stats" id="graphStats"></div>
            </div>
            
            <!-- Main View Section -->
            <div id="mainView" class="main-view">
                <div id="system-status"></div>
                
                <h3>üìã Event Logs (State Changes Only)</h3>
                <div id="eventLogs"></div>
            </div>
        </div>
        
          </div>

  
  
  
  
  
    <script>
        // Dropdown functionality
        document.addEventListener('DOMContentLoaded', function() {
            const dropdown = document.getElementById('exportDropdown');
            const dropdownMenu = document.getElementById('exportMenu');
            
            if (dropdown && dropdownMenu) {
                dropdown.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const isOpen = dropdownMenu.classList.contains('show');
                    
                    // Close all dropdowns
                    document.querySelectorAll('.dropdown-menu').forEach(menu => {
                        menu.classList.remove('show');
                    });
                    document.querySelectorAll('.dropdown').forEach(dd => {
                        dd.classList.remove('open');
                    });
                    
                    if (!isOpen) {
                        dropdownMenu.classList.add('show');
                        dropdown.closest('.dropdown').classList.add('open');
                    }
                });
            }
            
            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.dropdown')) {
                    document.querySelectorAll('.dropdown-menu').forEach(menu => {
                        menu.classList.remove('show');
                    });
                    document.querySelectorAll('.dropdown').forEach(dd => {
                        dd.classList.remove('open');
                    });
                }
            });

            // Update status information
            updateStatusInfo();
            setInterval(updateStatusInfo, 5000); // Update every 5 seconds
        });

        // Status update function
        function updateStatusInfo() {
            const dataStatusEl = document.getElementById('dataStatus');
            const autoBackupStatusEl = document.getElementById('autoBackupStatus');
            const autoBackupBtn = document.getElementById('autoBackupBtn');
            
            if (dataStatusEl && typeof eventLogs !== 'undefined' && typeof lastKnownStates !== 'undefined') {
                const logCount = eventLogs ? eventLogs.length : 0;
                const stateCount = lastKnownStates ? Object.keys(lastKnownStates).length : 0;
                dataStatusEl.textContent = `${logCount} logs, ${stateCount} states`;
            }
            
            if (autoBackupStatusEl && autoBackupBtn) {
                const isAutoBackupActive = typeof autoBackupInterval !== 'undefined' && autoBackupInterval !== null;
                autoBackupStatusEl.textContent = isAutoBackupActive ? 'Active (15 min)' : 'Disabled';
                autoBackupStatusEl.style.color = isAutoBackupActive ? '#28a745' : '#6c757d';
                
                // Update button text
                autoBackupBtn.innerHTML = isAutoBackupActive ? '‚èπÔ∏è Stop Auto-Backup' : 'üîÑ Start Auto-Backup';
            }
        }

        // Enhanced toggle function
        window.toggleAutoBackup = function() {
            if (typeof window.toggleAutoBackup === 'function') {
                // Call the original function from the logging script
                const originalToggle = window.toggleAutoBackup;
                originalToggle();
            }
            
            // Update UI immediately
            setTimeout(updateStatusInfo, 100);
        };
        </script>
  
  
  
  
  
  
  
        
<!--LOGGING SCRIPT-->
    <script>
 // FIXED PERSISTENT DATA STORAGE USING INDEXEDDB
class PersistentStorage {
    constructor() {
        this.dbName = 'NiagaraLoggingDB';
        this.dbVersion = 1;
        this.db = null;
        this.initialized = false;
    }

    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);
            
            request.onerror = () => {
                console.error('Failed to open IndexedDB:', request.error);
                reject(request.error);
            };
            
            request.onsuccess = () => {
                this.db = request.result;
                this.initialized = true;
                console.log('‚úÖ IndexedDB initialized successfully');
                resolve();
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // Create stores if they don't exist
                if (!db.objectStoreNames.contains('eventLogs')) {
                    const eventStore = db.createObjectStore('eventLogs', { keyPath: 'id' });
                    eventStore.createIndex('timestamp', 'timestamp', { unique: false });
                    eventStore.createIndex('unit', 'unit', { unique: false });
                }
                
                if (!db.objectStoreNames.contains('unitStates')) {
                    db.createObjectStore('unitStates', { keyPath: 'id' });
                }
                
                if (!db.objectStoreNames.contains('unitHistory')) {
                    db.createObjectStore('unitHistory', { keyPath: 'id' });
                }
                
                if (!db.objectStoreNames.contains('systemConfig')) {
                    db.createObjectStore('systemConfig', { keyPath: 'key' });
                }
                
                console.log('üì¶ IndexedDB structure created');
            };
        });
    }

    async saveEventLogs(logs) {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['eventLogs'], 'readwrite');
            const store = transaction.objectStore('eventLogs');
            
            transaction.oncomplete = () => {
                console.log(`üíæ Saved ${logs.length} event logs to IndexedDB`);
                resolve();
            };
            
            transaction.onerror = (event) => {
                const error = transaction.error || event.target.error || new Error('Transaction failed');
                console.error('Failed to save event logs:', error);
                reject(error);
            };
            
            // Clear existing logs first and wait for completion
            const clearRequest = store.clear();
            clearRequest.onsuccess = () => {
                // Use put instead of add to handle potential duplicates
                try {
                    logs.forEach((log, index) => {
                        // Ensure each log has a unique ID
                        const logWithId = { ...log, id: log.id || (Date.now() + index) };
                        const putRequest = store.put(logWithId);
                        
                        putRequest.onerror = (event) => {
                            console.error(`Failed to save log ${index}:`, event.target.error);
                        };
                    });
                } catch (error) {
                    console.error('Error in saveEventLogs forEach:', error);
                    reject(error);
                }
            };
            
            clearRequest.onerror = (event) => {
                const error = clearRequest.error || event.target.error || new Error('Clear operation failed');
                console.error('Failed to clear event logs:', error);
                reject(error);
            };
        });
    }

    async loadEventLogs() {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['eventLogs'], 'readonly');
            const store = transaction.objectStore('eventLogs');
            const request = store.getAll();
            
            request.onsuccess = () => {
                const logs = request.result.sort((a, b) => b.id - a.id); // Sort by ID descending
                console.log(`üìñ Loaded ${logs.length} event logs from IndexedDB`);
                resolve(logs);
            };
            
            request.onerror = (event) => {
                const error = request.error || event.target.error || new Error('Load operation failed');
                console.error('Failed to load event logs:', error);
                reject(error);
            };
        });
    }

    async saveUnitStates(states) {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['unitStates'], 'readwrite');
            const store = transaction.objectStore('unitStates');
            
            transaction.oncomplete = () => {
                console.log(`üíæ Saved ${Object.keys(states).length} unit states to IndexedDB`);
                resolve();
            };
            
            transaction.onerror = (event) => {
                const error = transaction.error || event.target.error || new Error('Transaction failed');
                console.error('Failed to save unit states:', error);
                reject(error);
            };
            
            const clearRequest = store.clear();
            clearRequest.onsuccess = () => {
                try {
                    Object.entries(states).forEach(([unit, state]) => {
                        const putRequest = store.put({ id: unit, state: state });
                        putRequest.onerror = (event) => {
                            console.error(`Failed to save state for ${unit}:`, event.target.error);
                        };
                    });
                } catch (error) {
                    console.error('Error in saveUnitStates forEach:', error);
                    reject(error);
                }
            };
            
            clearRequest.onerror = (event) => {
                const error = clearRequest.error || event.target.error || new Error('Clear operation failed');
                console.error('Failed to clear unit states:', error);
                reject(error);
            };
        });
    }

    async loadUnitStates() {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['unitStates'], 'readonly');
            const store = transaction.objectStore('unitStates');
            const request = store.getAll();
            
            request.onsuccess = () => {
                const states = {};
                request.result.forEach(item => {
                    states[item.id] = item.state;
                });
                console.log(`üìñ Loaded ${Object.keys(states).length} unit states from IndexedDB`);
                resolve(states);
            };
            
            request.onerror = (event) => {
                const error = request.error || event.target.error || new Error('Load operation failed');
                console.error('Failed to load unit states:', error);
                reject(error);
            };
        });
    }

    async saveLastKnownStates(states) {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['systemConfig'], 'readwrite');
            const store = transaction.objectStore('systemConfig');
            
            transaction.oncomplete = () => {
                console.log(`üíæ Saved ${Object.keys(states).length} last known states to IndexedDB`);
                resolve();
            };
            
            transaction.onerror = (event) => {
                const error = transaction.error || event.target.error || new Error('Transaction failed');
                console.error('Failed to save last known states:', error);
                reject(error);
            };
            
            const putRequest = store.put({
                key: 'lastKnownStates',
                value: states,
                timestamp: new Date().toISOString()
            });
            
            putRequest.onerror = (event) => {
                const error = putRequest.error || event.target.error || new Error('Put operation failed');
                console.error('Failed to put last known states:', error);
                reject(error);
            };
        });
    }

    async loadLastKnownStates() {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['systemConfig'], 'readonly');
            const store = transaction.objectStore('systemConfig');
            const request = store.get('lastKnownStates');
            
            request.onsuccess = () => {
                const result = request.result;
                if (result && result.value) {
                    console.log(`üìñ Loaded ${Object.keys(result.value).length} last known states from IndexedDB`);
                    resolve(result.value);
                } else {
                    console.log('üìñ No saved last known states found');
                    resolve({});
                }
            };
            
            request.onerror = (event) => {
                const error = request.error || event.target.error || new Error('Load operation failed');
                console.error('Failed to load last known states:', error);
                reject(error);
            };
        });
    }

    async saveSystemConfig(config) {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['systemConfig'], 'readwrite');
            const store = transaction.objectStore('systemConfig');
            
            transaction.oncomplete = () => {
                console.log('üíæ Saved system configuration to IndexedDB');
                resolve();
            };
            
            transaction.onerror = (event) => {
                const error = transaction.error || event.target.error || new Error('Transaction failed');
                console.error('Failed to save system config:', error);
                reject(error);
            };
            
            try {
                Object.entries(config).forEach(([key, value]) => {
                    const putRequest = store.put({
                        key: key,
                        value: value,
                        timestamp: new Date().toISOString()
                    });
                    
                    putRequest.onerror = (event) => {
                        console.error(`Failed to save config ${key}:`, event.target.error);
                    };
                });
            } catch (error) {
                console.error('Error in saveSystemConfig forEach:', error);
                reject(error);
            }
        });
    }

    async loadSystemConfig() {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['systemConfig'], 'readonly');
            const store = transaction.objectStore('systemConfig');
            const request = store.getAll();
            
            request.onsuccess = () => {
                const config = {};
                request.result.forEach(item => {
                    if (item.key !== 'lastKnownStates') { // Skip this as it's handled separately
                        config[item.key] = item.value;
                    }
                });
                console.log('üìñ Loaded system configuration from IndexedDB');
                resolve(config);
            };
            
            request.onerror = (event) => {
                const error = request.error || event.target.error || new Error('Load operation failed');
                console.error('Failed to load system config:', error);
                reject(error);
            };
        });
    }

    async clearAllData() {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const stores = ['eventLogs', 'unitStates', 'unitHistory', 'systemConfig'];
            const transaction = this.db.transaction(stores, 'readwrite');
            
            transaction.oncomplete = () => {
                console.log('üóëÔ∏è Cleared all persistent data from IndexedDB');
                resolve();
            };
            
            transaction.onerror = (event) => {
                const error = transaction.error || event.target.error || new Error('Transaction failed');
                console.error('Failed to clear data:', error);
                reject(error);
            };
            
            try {
                stores.forEach(storeName => {
                    const clearRequest = transaction.objectStore(storeName).clear();
                    clearRequest.onerror = (event) => {
                        console.error(`Failed to clear store ${storeName}:`, event.target.error);
                    };
                });
            } catch (error) {
                console.error('Error in clearAllData forEach:', error);
                reject(error);
            }
        });
    }

    // NEW: Get all data for JSON export
    async getAllDataForExport() {
        if (!this.initialized) await this.init();
        
        try {
            const [eventLogs, unitStates, lastKnownStates, systemConfig] = await Promise.all([
                this.loadEventLogs(),
                this.loadUnitStates(),
                this.loadLastKnownStates(),
                this.loadSystemConfig()
            ]);

            return {
                metadata: {
                    exportTimestamp: new Date().toISOString(),
                    version: '1.0',
                    totalEventLogs: eventLogs.length,
                    totalUnitStates: Object.keys(unitStates).length,
                    totalLastKnownStates: Object.keys(lastKnownStates).length
                },
                eventLogs: eventLogs,
                unitStates: unitStates,
                lastKnownStates: lastKnownStates,
                systemConfig: systemConfig,
                unitHistory: GlobalData.unitHistory || {}
            };
        } catch (error) {
            console.error('Failed to get all data for export:', error);
            throw error;
        }
    }
}

// JSON EXPORT FUNCTIONALITY
class JSONExporter {
    static async createFullDataExport() {
        try {
            console.log('üì¶ Creating full data export...');
            
            // Get all data from IndexedDB
            const allData = await persistentStorage.getAllDataForExport();
            
            // Add current in-memory data that might not be saved yet
            allData.currentMemoryState = {
                eventLogsLength: eventLogs.length,
                logCounter: logCounter,
                monitoringActive: monitoringActive,
                startTime: startTime.toISOString(),
                globalDataKeys: Object.keys(GlobalData.unitStates),
                lastUpdate: new Date().toISOString()
            };
            
            return allData;
        } catch (error) {
            console.error('‚ùå Failed to create full data export:', error);
            throw error;
        }
    }
    
    static downloadJSON(data, filename) {
        try {
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log(`üìÑ Downloaded JSON file: ${filename}`);
            return true;
        } catch (error) {
            console.error('‚ùå Failed to download JSON:', error);
            return false;
        }
    }
    
    static async exportFullDataAsJSON() {
        try {
            const allData = await this.createFullDataExport();
            const timestamp = new Date().toISOString().split('T')[0];
            const filename = `niagara-full-data-${timestamp}.json`;
            
            const success = this.downloadJSON(allData, filename);
            
            if (success) {
                showNotification(
                    'JSON Export Complete', 
                    `Full data exported: ${allData.eventLogs.length} logs, ${Object.keys(allData.unitStates).length} states`,
                    'success'
                );
            } else {
                showNotification('Export Failed', 'Could not create JSON export', 'error');
            }
            
            return success;
        } catch (error) {
            console.error('‚ùå Full JSON export failed:', error);
            showNotification('Export Failed', 'JSON export encountered an error', 'error');
            return false;
        }
    }
    
    static async exportEventLogsAsJSON() {
        try {
            if (eventLogs.length === 0) {
                showNotification('No Data', 'No event logs available for export', 'warning');
                return false;
            }
            
            const exportData = {
                metadata: {
                    exportTimestamp: new Date().toISOString(),
                    totalLogs: eventLogs.length,
                    exportType: 'eventLogs'
                },
                eventLogs: eventLogs.slice().sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
            };
            
            const timestamp = new Date().toISOString().split('T')[0];
            const filename = `niagara-event-logs-${timestamp}.json`;
            
            const success = this.downloadJSON(exportData, filename);
            
            if (success) {
                showNotification(
                    'Event Logs JSON Export Complete', 
                    `Exported ${eventLogs.length} event logs to JSON`,
                    'success'
                );
            }
            
            return success;
        } catch (error) {
            console.error('‚ùå Event logs JSON export failed:', error);
            showNotification('Export Failed', 'Event logs JSON export failed', 'error');
            return false;
        }
    }
}

        // Initialize persistent storage
        const persistentStorage = new PersistentStorage();

        // GLOBAL DATA ACCESS - Expose data to other documents
        if (!window.NiagaraGlobalData) {
            window.NiagaraGlobalData = {
                // Current states of all units
                unitStates: {},
                
                // Historical data for graphing (timestamped values)
                unitHistory: {},
                
                // Metadata about units
                unitMetadata: {},
                
                // Get current state of a specific unit
                getUnitState: function(unitName) {
                    return this.unitStates[unitName] || null;
                },
                
                // Get historical data for a unit (for graphing)
                getUnitHistory: function(unitName, maxEntries = 100) {
                    const history = this.unitHistory[unitName] || [];
                    return history.slice(-maxEntries); // Return last N entries
                },
                
                // Get all unit names
                getAllUnits: function() {
                    return Object.keys(this.unitStates);
                },
                
                // Get units by type (AHU, VAV, etc.)
                getUnitsByType: function(type) {
                    return Object.keys(this.unitStates).filter(unit => unit.startsWith(type));
                },
                
                // Subscribe to unit changes (callback when unit state changes)
                subscribers: [],
                subscribe: function(callback) {
                    this.subscribers.push(callback);
                },
                
                // Internal method to notify subscribers
                _notifySubscribers: function(unitName, oldState, newState, timestamp) {
                    this.subscribers.forEach(callback => {
                        try {
                            callback(unitName, oldState, newState, timestamp);
                        } catch (e) {
                            console.error('Error in subscriber callback:', e);
                        }
                    });
                }
            };
        }

        // Reference to global data for easier access
        const GlobalData = window.NiagaraGlobalData;

        // Global variables for logging functionality
        let eventLogs = [];
        let logCounter = 0;
        let monitoringActive = true;
        let startTime = new Date();
        let selectedDate = null;

        
        // Store last known states to detect changes
        let lastKnownStates = {};
        
        // Graph viewer state
        let graphViewerActive = false;
        
        // Monitor points array (will be populated when require callback runs)
        let monitorPoints = [];

        // AUTO-SAVE FUNCTIONALITY
        let autoSaveInterval;
        const AUTO_SAVE_INTERVAL = 30000; // Save every 30 seconds

        function startAutoSave() {
            autoSaveInterval = setInterval(async () => {
                try {
                    await saveAllDataToPersistentStorage();
                    console.log('üîÑ Auto-save completed');
                } catch (error) {
                    console.error('‚ùå Auto-save failed:', error);
                }
            }, AUTO_SAVE_INTERVAL);
            
            console.log(`‚è∞ Auto-save started (every ${AUTO_SAVE_INTERVAL/1000} seconds)`);
        }

        function stopAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
                console.log('‚è∞ Auto-save stopped');
            }
        }

        // ENHANCED SAVE DATA TO PERSISTENT STORAGE (Now includes JSON export)
        async function saveAllDataToPersistentStorage(autoExportJSON = false) {
            try {
                console.log('üíæ Starting save operation...');
                
                // Save event logs
                if (eventLogs && eventLogs.length > 0) {
                    await persistentStorage.saveEventLogs(eventLogs);
                }
                
                // Save unit states
                if (GlobalData.unitStates && Object.keys(GlobalData.unitStates).length > 0) {
                    await persistentStorage.saveUnitStates(GlobalData.unitStates);
                }
                
                // Save last known states
                if (lastKnownStates && Object.keys(lastKnownStates).length > 0) {
                    await persistentStorage.saveLastKnownStates(lastKnownStates);
                }
                
                // Save system configuration
                await persistentStorage.saveSystemConfig({
                    logCounter: logCounter,
                    monitoringActive: monitoringActive,
                    startTime: startTime.toISOString(),
                    totalPoints: monitorPoints ? monitorPoints.length : 0
                });
                
                // Update UI to show last save time
                updateLastSaveTime();
                
                console.log('‚úÖ All data saved successfully');
                
                // AUTO-EXPORT JSON if requested and there's significant data
                if (autoExportJSON && eventLogs.length > 0) {
                    console.log('üì¶ Auto-exporting JSON backup...');
                    try {
                        await JSONExporter.exportFullDataAsJSON();
                        console.log('‚úÖ Auto JSON export completed');
                    } catch (jsonError) {
                        console.error('‚ùå Auto JSON export failed:', jsonError);
                        // Don't throw - IndexedDB save was successful
                    }
                }
                
            } catch (error) {
                console.error('‚ùå Failed to save data to persistent storage:', error);
                throw error;
            }
        }

        // LOAD DATA FROM PERSISTENT STORAGE
        async function loadAllDataFromPersistentStorage() {
            try {
                console.log('üìñ Loading data from persistent storage...');
                
                // Load event logs
                const savedLogs = await persistentStorage.loadEventLogs();
                if (savedLogs && savedLogs.length > 0) {
                    eventLogs = savedLogs;
                    console.log(`‚úÖ Restored ${eventLogs.length} event logs`);
                }
                
                // Load unit states
                const savedUnitStates = await persistentStorage.loadUnitStates();
                if (savedUnitStates && Object.keys(savedUnitStates).length > 0) {
                    GlobalData.unitStates = savedUnitStates;
                    console.log(`‚úÖ Restored ${Object.keys(savedUnitStates).length} unit states`);
                }
                
                // Load last known states
                const savedLastKnown = await persistentStorage.loadLastKnownStates();
                if (savedLastKnown && Object.keys(savedLastKnown).length > 0) {
                    lastKnownStates = savedLastKnown;
                    console.log(`‚úÖ Restored ${Object.keys(savedLastKnown).length} last known states`);
                }
                
                // Load system configuration
                const savedConfig = await persistentStorage.loadSystemConfig();
                if (savedConfig) {
                    if (savedConfig.logCounter) logCounter = savedConfig.logCounter;
                    if (savedConfig.monitoringActive !== undefined) monitoringActive = savedConfig.monitoringActive;
                    if (savedConfig.startTime) startTime = new Date(savedConfig.startTime);
                    console.log('‚úÖ Restored system configuration');
                }
                
                // Update UI
                updateEventLogs();
                updateMonitoringStatus();
                updateLastSaveTime();
                
                console.log('üéâ All data successfully restored from persistent storage');
                
                // Show restoration notification
                showNotification('Data Restored', `Restored ${eventLogs.length} logs and ${Object.keys(lastKnownStates).length} states from previous session`, 'success');
                
            } catch (error) {
                console.error('‚ùå Failed to load data from persistent storage:', error);
                showNotification('Load Failed', 'Could not restore previous session data', 'error');
            }
        }

        
        
        
        function convertToCSV(data) {
    if (!data || data.length === 0) return '';

    // Define CSV headers
    const headers = [
        // 'Log ID',
        'Unit',
        'Timestamp',
        // 'Unit',
        'Point Name',
        // 'Display Name',
        'Value',
        // 'State Change',
        // 'Details'
    ];

    // Sort data by Unit, then Point Name, then Timestamp (optional)
    // data.sort((a, b) => {
    //     if (a.unit !== b.unit) return a.unit.localeCompare(b.unit);
    //     if (a.pointName !== b.pointName) return a.pointName.localeCompare(b.pointName);
    //     return new Date(a.timestamp) - new Date(b.timestamp); // optional
    // });
    
    data.sort((a, b) => {
    const unitA = String(a.unit);
    const unitB = String(b.unit);
    const pointA = String(a.pointName);
    const pointB = String(b.pointName);

    if (unitA !== unitB) return unitA.localeCompare(unitB);
    if (pointA !== pointB) return pointA.localeCompare(pointB);
    return new Date(a.timestamp) - new Date(b.timestamp); // optional
});


    const csvRows = [headers.join(',')];
    let previousUnit = null;

    data.forEach(log => {
        // Insert a blank row when unit changes
        if (previousUnit !== null && log.unit !== previousUnit) {
            csvRows.push('');
        }

        const row = [
            log.unit || '',
            // log.id || '',
            `"${log.timestamp || ''}"`,
            // log.unit || '',
            log.pointName || '',
            // `"${log.displayName || log.systemName || ''}"`,
            log.value ? 'TRUE' : 'FALSE',
            // log.isStateChange ? 'YES' : 'NO',
            // `"${log.details || ''}"`
        ].join(',');

        csvRows.push(row);
        previousUnit = log.unit;
    });

    return csvRows.join('\n');
}


        // UPDATE LAST SAVE TIME DISPLAY
        function updateLastSaveTime() {
            const saveTimeElement = document.getElementById('lastSaveTime');
            if (saveTimeElement) {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                saveTimeElement.textContent = `Last saved: ${timeString}`;
                saveTimeElement.style.color = '#4CAF50';
                
                // Fade the color back to normal after 2 seconds
                setTimeout(() => {
                    saveTimeElement.style.color = '#666';
                }, 2000);
            }
        }

        // SHOW NOTIFICATION
        function showNotification(title, message, type = 'info') {
            // Create notification element if it doesn't exist
            let notificationContainer = document.getElementById('notificationContainer');
            if (!notificationContainer) {
                notificationContainer = document.createElement('div');
                notificationContainer.id = 'notificationContainer';
                notificationContainer.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 10000;
                    max-width: 300px;
                `;
                document.body.appendChild(notificationContainer);
            }
            
            const notification = document.createElement('div');
            const typeColors = {
                success: '#4CAF50',
                error: '#f44336',
                info: '#2196F3',
                warning: '#ff9800'
            };
            
            notification.style.cssText = `
                background: ${typeColors[type] || typeColors.info};
                color: white;
                padding: 12px 16px;
                margin-bottom: 10px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                font-family: Arial, sans-serif;
                font-size: 14px;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
            `;
            
            notification.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 4px;">${title}</div>
                <div style="font-size: 12px; opacity: 0.9;">${message}</div>
            `;
            
            notificationContainer.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 5000);
        }

        // HANDLE PAGE VISIBILITY CHANGES (save when page becomes hidden)
        document.addEventListener('visibilitychange', async () => {
            if (document.hidden) {
                console.log('üìÑ Page became hidden - saving data...');
                try {
                    await saveAllDataToPersistentStorage();
                    console.log('‚úÖ Data saved before page hidden');
                } catch (error) {
                    console.error('‚ùå Failed to save data before page hidden:', error);
                }
            }
        });

        // HANDLE PAGE UNLOAD (save before leaving)
        window.addEventListener('beforeunload', async (event) => {
            console.log('üö™ Page unloading - attempting to save data...');
            try {
                // Synchronous save attempt for beforeunload
                await saveAllDataToPersistentStorage();
                console.log('‚úÖ Data saved on page unload');
            } catch (error) {
                console.error('‚ùå Failed to save data on page unload:', error);
            }
        });

        // ENHANCED CLEAR LOGS FUNCTION
        window.clearLogs = async function() {
            const confirmMessage = `‚ö†Ô∏è WARNING: Clear All Logs and Reset States?\n\nThis will permanently delete:\n- All ${eventLogs.length} log entries\n- All ${Object.keys(lastKnownStates).length} stored states\n- All persistent storage data\n\nNext monitoring cycle will treat all points as "initial state"\n\nThis action cannot be undone!\n\nAre you sure you want to continue?`;
            
            if (confirm(confirmMessage)) {
                const backupLogCount = eventLogs.length;
                const backupStateCount = Object.keys(lastKnownStates).length;
                
                // Clear in-memory data
                eventLogs = [];
                logCounter = 0;
                lastKnownStates = {};
                
                // Clear global data history but keep current states
                Object.keys(GlobalData.unitHistory).forEach(unitName => {
                    GlobalData.unitHistory[unitName] = [];
                });
                
                try {
                    // Clear persistent storage
                    await persistentStorage.clearAllData();
                    
                    updateEventLogs();
                    updateLastSaveTime();
                    
                    console.log(`üóëÔ∏è Cleared ${backupLogCount} log entries and ${backupStateCount} stored states`);
                    showNotification('Data Cleared', `Successfully cleared ${backupLogCount} log entries and ${backupStateCount} stored states`, 'success');
                    
                } catch (error) {
                    console.error('‚ùå Failed to clear persistent storage:', error);
                    showNotification('Clear Failed', 'Failed to clear some persistent data', 'error');
                }
            } else {
                console.log('‚ùå Clear logs cancelled by user');
            }
        };

        // ENHANCED MANUAL SAVE FUNCTION (with optional JSON export)
        window.saveData = async function(exportJSON = false) {
            try {
                await saveAllDataToPersistentStorage(exportJSON);
                showNotification('Data Saved', `Saved ${eventLogs.length} logs and ${Object.keys(lastKnownStates).length} states`, 'success');
            } catch (error) {
                console.error('‚ùå Manual save failed:', error);
                showNotification('Save Failed', 'Failed to save data to persistent storage', 'error');
            }
        };

        // ENHANCED EXPORT LOGS FUNCTION (NOW EXPORTS CSV)
        window.exportLogs = function() {
            if (eventLogs.length === 0) {
                alert('No logs to export - please wait for some state changes to be detected');
                return;
            }

            // Sort by timestamp (newest first)
            const sortedLogs = eventLogs.slice().sort((a, b) => {
                return new Date(b.timestamp) - new Date(a.timestamp);
            });

            // Convert to CSV
            const csvContent = convertToCSV(sortedLogs);
            
            if (!csvContent) {
                alert('Failed to generate CSV content');
                return;
            }

            // Create and download CSV file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `niagara-logs-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log(`üìä Exported ${sortedLogs.length} logs to CSV`);
            showNotification('CSV Export Complete', `Exported ${sortedLogs.length} log entries to CSV file`, 'success');
        };

        // NEW JSON EXPORT FUNCTIONS (Global access)
        window.exportFullDataJSON = async function() {
            return await JSONExporter.exportFullDataAsJSON();
        };

        window.exportEventLogsJSON = async function() {
            return await JSONExporter.exportEventLogsAsJSON();
        };

        // NEW: Enhanced save with JSON backup option
        window.saveDataWithJSON = async function() {
            return await window.saveData(true);
        };

        // NEW: Batch export function (CSV + JSON)
        window.exportAllFormats = async function() {
            if (eventLogs.length === 0) {
                showNotification('No Data', 'No data available for export', 'warning');
                return false;
            }

            try {
                console.log('üì¶ Starting batch export (CSV + JSON)...');
                
                // Export CSV
                window.exportLogs();
                
                // Wait a moment, then export JSON
                await new Promise(resolve => setTimeout(resolve, 500));
                await JSONExporter.exportFullDataAsJSON();
                
                showNotification(
                    'Batch Export Complete', 
                    `Exported ${eventLogs.length} logs in both CSV and JSON formats`,
                    'success'
                );
                
                return true;
            } catch (error) {
                console.error('‚ùå Batch export failed:', error);
                showNotification('Batch Export Failed', 'Could not complete batch export', 'error');
                return false;
            }
        };

        // AUTO-BACKUP FUNCTIONALITY
        let autoBackupInterval;
        // const AUTO_BACKUP_INTERVAL = 300000; // Backup every 5 minutes
const AUTO_BACKUP_INTERVAL = 900000


        function startAutoBackup() {
            autoBackupInterval = setInterval(async () => {
                if (eventLogs.length > 0) {
                    try {
                        console.log('üîÑ Creating automatic JSON backup...');
                        await JSONExporter.exportFullDataAsJSON();
                        console.log('‚úÖ Auto-backup completed');
                    } catch (error) {
                        console.error('‚ùå Auto-backup failed:', error);
                    }
                }
            }, AUTO_BACKUP_INTERVAL);
            
            console.log(`üì¶ Auto-backup started (every ${AUTO_BACKUP_INTERVAL/60000} minutes)`);
        }

        function stopAutoBackup() {
            if (autoBackupInterval) {
                clearInterval(autoBackupInterval);
                autoBackupInterval = null;
                console.log('üì¶ Auto-backup stopped');
            }
        }

        // NEW: Toggle auto-backup
        window.toggleAutoBackup = function() {
            if (autoBackupInterval) {
                stopAutoBackup();
                showNotification('Auto-Backup Disabled', 'Automatic JSON backups have been stopped', 'info');
            } else {
                startAutoBackup();
                showNotification('Auto-Backup Enabled', `JSON backups will be created every ${AUTO_BACKUP_INTERVAL/60000} minutes`, 'success');
            }
        };
        
        // Simulate Niagara baja library for demo purposes
        if (typeof require === 'undefined') {
            window.require = function(deps, callback) {
                // Mock baja object
                const mockBaja = {
                    Ord: {
                        make: function(path) {
                            return {
                                get: function() {
                                    return Promise.resolve({
                                        getDisplayName: function() {
                                            const parts = path.split('/');
                                            return parts[parts.length - 1] || 'Unknown Point';
                                        },
                                        getName: function() {
                                            const parts = path.split('/');
                                            return parts[parts.length - 1] || 'Unknown Point';
                                        },
                                        get: function(slot) {
                                            if (slot === 'out') {
                                                const pointId = path.split('/').pop();
                                                const lastState = lastKnownStates[pointId];
                                                
                                                let newValue;
                                                if (lastState === undefined) {
                                                    newValue = Math.random() > 0.7;
                                                } else {
                                                    if (Math.random() > 0.1) {
                                                        newValue = lastState;
                                                    } else {
                                                        newValue = !lastState;
                                                    }
                                                }
                                                
                                                return {
                                                    getValue: function() {
                                                        return newValue;
                                                    }
                                                };
                                            }
                                            return null;
                                        }
                                    });
                                }
                            };
                        }
                    }
                };
                
                setTimeout(() => callback(mockBaja, {}), 100);
            };
        }

        // INITIALIZE ON LOAD
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('üöÄ Initializing Niagara Logging System with JSON Export...');
            
            try {
                // Load existing data
                await loadAllDataFromPersistentStorage();
                
                // Start auto-save
                startAutoSave();
                
                // Optionally start auto-backup (uncomment to enable by default)
                // startAutoBackup();
                
                console.log('‚úÖ System initialized successfully');
                
                // Show available functions in console
                console.log(`
üìã Available Functions:
- saveData() - Save to IndexedDB only
- saveDataWithJSON() - Save to IndexedDB and export JSON
- exportLogs() - Export CSV file
- exportFullDataJSON() - Export complete JSON backup
- exportEventLogsJSON() - Export event logs as JSON
- exportAllFormats() - Export both CSV and JSON
- toggleAutoBackup() - Enable/disable automatic JSON backups
- clearLogs() - Clear all data

üìä Data Status:
- Event Logs: ${eventLogs.length}
- Unit States: ${Object.keys(GlobalData.unitStates).length}
- Last Known States: ${Object.keys(lastKnownStates).length}
                `);
                
            } catch (error) {
                console.error('‚ùå System initialization failed:', error);
                showNotification('Init Failed', 'System could not initialize properly', 'error');
            }
        });

        // Export classes for external use
        window.PersistentStorage = PersistentStorage;
        window.JSONExporter = JSONExporter;
// ========================================================================================================================================












// FIXED INITIALIZATION ORDER - Define UI functions first, then load data

require(['baja!', 'baja!control:Override', 'baja!control:NumericOverride', 'baja!baja:Status', 'baja!alarm:AlarmSourceExt', 'baja!baja:StatusBoolean'], function (baja, types) {
    'use strict';
    
    // DEFINE ALL UI FUNCTIONS FIRST (before any data loading)
    
    // Time tracking function
    function updateDateTime() {
        const now = new Date();
        const options = {
            day: '2-digit',
            month: 'short',
            year: 'numeric',
            hour: 'numeric',
            minute: '2-digit',
            hour12: true,
            timeZoneName: 'short'
        };
        const formatted = now.toLocaleString('en-US', options).replace(',', '');
        document.getElementById('currentDateTime').textContent = formatted;
    }
    
    // Function to get formatted timestamp for data points
    function getFormattedTimestamp() {
        const now = new Date();
        const options = {
            day: '2-digit',
            month: 'short',
            year: 'numeric',
            hour: 'numeric',
            minute: '2-digit',
            hour12: true,
            timeZoneName: 'short'
        };
        return now.toLocaleString('en-US', options).replace(',', '');
    }
    
    
    
    
    function updateMonitoringStatus() {
        const statusElement = document.getElementById('monitoringStatus');
        if (statusElement) {
            if (monitoringActive) {
                statusElement.textContent = 'MONITORING ACTIVE';
                statusElement.className = 'monitoring-status monitoring-active';
            } else {
                statusElement.textContent = 'MONITORING STOPPED';
                statusElement.className = 'monitoring-status monitoring-inactive';
            }
        }
    }
    
    // Function to update event logs display
    function updateEventLogs() {
        const logsContainer = document.getElementById('eventLogs');
        
        // Check if element exists
        if (!logsContainer) {
            console.warn('Event logs container not found - UI may not be ready yet');
            return;
        }
        
        // Clear existing logs
        logsContainer.innerHTML = '';
        
        // Show recent logs (limit to 4 for performance)
        const recentLogs = eventLogs.slice(0, 4);
        
        // Add event logs
        recentLogs.forEach((log, index) => {
            const logElement = document.createElement('div');
            logElement.className = 'bubbleSP';
            
            const statusClass = log.value ? 'status-ok' : 'status-error';
            const statusText = log.value ? 'ON' : 'OFF';
            const statusIcon = log.value ? 'üîµ': '‚ö™';
            
            const changeIcon = log.isStateChange ? 'üîÑ ' : '';
            
            logElement.innerHTML = `
                <div id="status-point${log.id}" class="point-status status-display ${statusClass}">
                    <div class="status-title">${changeIcon}${statusIcon} ${log.displayName || log.systemName} - ${statusText}</div>
                    <div class="status-details">
                        <p><strong>Timestamp:</strong> ${log.timestamp}</p>
                        <p><strong>Status:</strong> ${log.details}</p>
                        <p><strong>Value:</strong> ${log.value ? 'TRUE' : 'FALSE'}</p>
                    </div>
                </div>
            `;
            
            logsContainer.appendChild(logElement);
        });
        
        // Show message if there are more logs
        if (eventLogs.length > 4) {
            const moreElement = document.createElement('div');
            moreElement.className = 'bubbleSP';
            moreElement.innerHTML = `
                <div class="point-status status-display">
                    <div class="status-title">... and ${eventLogs.length - 4} older entries</div>
                    <div class="status-details">
                        <p>Use Export Logs to view all ${eventLogs.length} entries</p>
                    </div>
                </div>
            `;
            logsContainer.appendChild(moreElement);
        }
        
        // Add message if no logs
        if (eventLogs.length === 0) {
            logsContainer.innerHTML = `
                <div class="bubbleSP">
                    <div class="point-status status-display">
                        <div class="status-title">No state changes recorded</div>
                        <div class="status-details">
                            <p>System is monitoring points for state changes...</p>
                            <p>Logs will only appear when values change from TRUE ‚Üî FALSE</p>
                        </div>
                    </div>
                </div>
            `;
        }
        
        updateOverallStatus();
    }
    
    // Function to update the overall system status summary
    function updateOverallStatus() {
        var statusElement = document.getElementById('system-status');
        if (!statusElement) {
            console.warn('System status element not found - UI may not be ready yet');
            return;
        }
        
        // Remove loading message
        statusElement.innerHTML = '';
        
        // Check if we need to add the overall summary
        var summaryElement = document.getElementById('overall-summary');
        if (!summaryElement) {
            summaryElement = document.createElement('div');
            summaryElement.id = 'overall-summary';
            summaryElement.className = 'overall-summary';
            statusElement.appendChild(summaryElement);
        }
        
        // Add save status indicator
        var saveStatusElement = document.getElementById('save-status');
        if (!saveStatusElement) {
            saveStatusElement = document.createElement('div');
            saveStatusElement.id = 'save-status';
            saveStatusElement.style.cssText = `
                margin-top: 10px;
                padding: 8px 12px;
                background: #f0f0f0;
                border-radius: 4px;
                font-size: 12px;
                color: #666;
            `;
            statusElement.appendChild(saveStatusElement);
        }
        
        // Count active points from last known states
        window.activeCount1 = 0;
        window.totalPoints1 = monitorPoints.length;
        
        // Count how many are active based on last known states
        Object.values(lastKnownStates).forEach(function(state) {
            if (state === true) {
                activeCount1++;
            }
        });
        
        var overallClass = activeCount1 > 0 ? 'status-ok' : 'status-error';
        var overallTitle = activeCount1 > 0 ? 
            `<span class="status-indicator"></span>üîµ ${activeCount1} SYSTEM${activeCount1 > 1 ? 'S' : ''} ACTIVE` : 
            '<span class="status-indicator"></span>‚ö™ ALL SYSTEMS INACTIVE';
        
        const monitoringStatusText = monitoringActive ? 'üü¢ ACTIVE' : 'üî¥ STOPPED';
        const monitoredCount = Object.keys(lastKnownStates).length;
        
        summaryElement.className = `overall-summary status-display ${overallClass}`;
        summaryElement.innerHTML = `
            <div class="status-title">${overallTitle}</div>
            <div class="status-details">
                <p><strong>Monitoring Status:</strong> ${monitoringStatusText}</p>
                <p><strong>True Points Count:</strong> ${activeCount1} of ${monitoredCount} monitored points</p>
                <p><strong>Total Logged Points:</strong> ${eventLogs.length}</p>
                <p><strong>Last Updated:</strong> ${new Date().toLocaleString()}</p>
                <p><strong>Global Units:</strong> ${GlobalData.getAllUnits().length} units accessible</p>
            </div>
        `;
        
        // Update save status
        saveStatusElement.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span id="lastSaveTime">Auto-save active</span>
                <button onclick="saveData()" style="padding: 4px 8px; font-size: 11px; border: 1px solid #ccc; background: white; border-radius: 3px; cursor: pointer;">Manual Save</button>
            </div>
        `;
    }

    // MODIFIED LOAD DATA FUNCTION with better error handling
    async function loadAllDataFromPersistentStorage() {
        try {
            console.log('üìñ Loading data from persistent storage...');
            
            // Load event logs
            try {
                const savedLogs = await persistentStorage.loadEventLogs();
                if (savedLogs && savedLogs.length > 0) {
                    eventLogs = savedLogs;
                    console.log(`‚úÖ Restored ${eventLogs.length} event logs`);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load event logs, starting fresh:', error.message);
            }
            
            // Load unit states
            try {
                const savedUnitStates = await persistentStorage.loadUnitStates();
                if (savedUnitStates && Object.keys(savedUnitStates).length > 0) {
                    GlobalData.unitStates = savedUnitStates;
                    console.log(`‚úÖ Restored ${Object.keys(savedUnitStates).length} unit states`);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load unit states, starting fresh:', error.message);
            }
            
            // Load last known states
            try {
                const savedLastKnown = await persistentStorage.loadLastKnownStates();
                if (savedLastKnown && Object.keys(savedLastKnown).length > 0) {
                    lastKnownStates = savedLastKnown;
                    console.log(`‚úÖ Restored ${Object.keys(savedLastKnown).length} last known states`);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load last known states, starting fresh:', error.message);
            }
            
            // Load system configuration
            try {
                const savedConfig = await persistentStorage.loadSystemConfig();
                if (savedConfig) {
                    if (savedConfig.logCounter) logCounter = savedConfig.logCounter;
                    if (savedConfig.monitoringActive !== undefined) monitoringActive = savedConfig.monitoringActive;
                    if (savedConfig.startTime) startTime = new Date(savedConfig.startTime);
                    console.log('‚úÖ Restored system configuration');
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load system config, using defaults:', error.message);
            }
            
            // Update UI - these functions are now defined above
            updateEventLogs();
            updateMonitoringStatus();
            updateLastSaveTime();
            
            console.log('üéâ Data loading completed (with any recoverable errors handled)');
            
            // Show restoration notification only if we actually restored data
            const totalRestored = eventLogs.length + Object.keys(lastKnownStates).length;
            if (totalRestored > 0) {
                showNotification('Data Restored', `Restored ${eventLogs.length} logs and ${Object.keys(lastKnownStates).length} states from previous session`, 'success');
            }
            
        } catch (error) {
            console.error('‚ùå Critical error during data loading:', error);
            showNotification('Load Failed', 'Could not restore previous session data', 'error');
            
            // Initialize with empty state to prevent further errors
            eventLogs = [];
            lastKnownStates = {};
            updateEventLogs();
            updateMonitoringStatus();
        }
    }

    // NEW: Function to load Global.json configuration
    async function loadGlobalConfiguration() {
        try {
            console.log('üìã Loading Global.json configuration...');
            
            // Try to fetch Global.json file
            const response = await fetch('./Global.json');
            if (!response.ok) {
                throw new Error(`Failed to fetch Global.json: ${response.status} ${response.statusText}`);
            }
            
            const globalConfig = await response.json();
            console.log('‚úÖ Global.json loaded successfully:', globalConfig);
            
            return globalConfig;
            
        } catch (error) {
            console.error('‚ùå Failed to load Global.json:', error);
            console.warn('‚ö†Ô∏è Falling back to hardcoded configuration');
            
            // Fallback to original hardcoded configuration if JSON fails
            return {
                globalVariables: {
                    // AIR HANDLING UNITS
                    'AHU_1': {
                        basePath: 'station:|slot:/Drivers/BcpBacnetNetwork/AHU_1/points/{pointName}',
                        points: [
                            { name: 'AHUAlarm', log: 'yes' },
                            { name: 'OccupiedCmd', log: 'yes' },
                            { name: 'AutoStop', log: 'yes' },
                            { name: 'MorningWarmupOutput', log: 'yes' },
                            { name: 'SF_S', log: 'yes' },
                            { name: 'OCC_S', log: 'yes' }
                        ]
                    },
                    'AHU_2': {
                        basePath: 'station:|slot:/Drivers/BcpBacnetNetwork/AHU_2/points/{pointName}',
                        points: [
                            { name: 'AHUAlarm', log: 'yes' },
                            { name: 'OccupiedCmd', log: 'yes' },
                            { name: 'AutoStop', log: 'yes' },
                            { name: 'MorningWarmupOutput', log: 'yes' },
                            { name: 'SF_S', log: 'yes' },
                            { name: 'OCC_S', log: 'yes' }
                        ]
                    },
                    // VAV UNITS (sample - add more as needed)
                    'VAV_0_1': {
                        basePath: 'station:|slot:/Drivers/BcpBacnetNetwork/VAV_0_1/points/{pointName}',
                        points: [
                            { name: 'UnitStatus', log: 'yes' },
                            { name: 'RoomOccupancy', log: 'yes' },
                            { name: 'Reheat1', log: 'yes' }
                        ]
                    }
                    // Add more units as needed...
                }
            };
        }
    }

    // NEW: Function to build monitor points from JSON configuration
    // function buildMonitorPointsFromJson(globalConfig) {
    //     console.log('üîß Building monitor points from Global.json...');
        
    //     monitorPoints = []; // Reset the global array
    //     let idCounter = 1;
    //     let totalPointsFound = 0;
    //     let loggablePointsFound = 0;

    //     // Process each unit in the global configuration
    //     Object.keys(globalConfig.globalVariables).forEach(unitName => {
    //         const unitConfig = globalConfig.globalVariables[unitName];
    //         console.log(`Processing unit: ${unitName}`);
            
    //         // Initialize unit state object
    //         if (!GlobalData.unitStates[unitName]) {
    //             GlobalData.unitStates[unitName] = {};
    //         }
            
    //         // Initialize unit history array
    //         if (!GlobalData.unitHistory[unitName]) {
    //             GlobalData.unitHistory[unitName] = [];
    //         }
            
    //         // Track points for this unit
    //         const unitPointNames = [];
            
    //         // Process each point in the unit
    //         if (unitConfig.points && Array.isArray(unitConfig.points)) {
    //             unitConfig.points.forEach(pointConfig => {
    //                 totalPointsFound++;
                    
    //                 // Only add points that are marked for logging
    //                 if (pointConfig.log && pointConfig.log.toLowerCase() === 'yes') {
    //                     loggablePointsFound++;
                        
    //                     // Create the point configuration
    //                     const monitorPoint = {
    //                         id: `point${idCounter++}`,
    //                         path: pointConfig.fullPath || unitConfig.basePath.replace('{pointName}', pointConfig.name),
    //                         systemName: `${unitName}_${pointConfig.name}`,
    //                         unit: unitName,
    //                         pointName: pointConfig.name,
    //                         pointId: pointConfig.id || pointConfig.name,
    //                         status: pointConfig.status || 'unknown',
    //                         dateAdded: pointConfig.dateAdded || new Date().toISOString()
    //                     };
                        
    //                     monitorPoints.push(monitorPoint);
    //                     unitPointNames.push(pointConfig.name);
                        
    //                     // Initialize individual point state
    //                     if (!GlobalData.unitStates[unitName][pointConfig.name]) {
    //                         GlobalData.unitStates[unitName][pointConfig.name] = {
    //                             value: null,
    //                             timestamp: null,
    //                             displayName: null
    //                         };
    //                     }
                        
    //                     console.log(`‚úÖ Added loggable point: ${unitName}.${pointConfig.name}`);
    //                 } else {
    //                     console.log(`‚è≠Ô∏è Skipping point: ${unitName}.${pointConfig.name} (log: ${pointConfig.log})`);
    //                 }
    //             });
    //         }
            
    //         // Initialize unit metadata
    //         if (!GlobalData.unitMetadata[unitName]) {
    //             GlobalData.unitMetadata[unitName] = {
    //                 type: unitName.startsWith('AHU') ? 'Air Handling Unit' : 
    //                       unitName.startsWith('VAV') ? 'Variable Air Volume' : 'Unknown',
    //                 points: unitPointNames,
    //                 lastUpdated: null,
    //                 basePath: unitConfig.basePath
    //             };
    //         }
    //     });

    //     console.log(`üìä Monitor points built from JSON:`);
    //     console.log(`   - Total points found: ${totalPointsFound}`);
    //     console.log(`   - Loggable points (log: "yes"): ${loggablePointsFound}`);
    //     console.log(`   - Units processed: ${Object.keys(globalConfig.globalVariables).length}`);
    //     console.log(`   - Monitor points created: ${monitorPoints.length}`);
    //     console.log('üåê Global data structures initialized:', GlobalData);
        
    //     return {
    //         totalPoints: totalPointsFound,
    //         loggablePoints: loggablePointsFound,
    //         unitsProcessed: Object.keys(globalConfig.globalVariables).length
    //     };
    // }
    
    // NEW: Function to build monitor points from JSON configuration
function buildMonitorPointsFromJson(globalConfig) {
    console.log('üîß Building monitor points from Global.json...');
    
    monitorPoints = []; // Reset the global array
    let idCounter = 1;
    let totalPointsFound = 0;
    let loggablePointsFound = 0;

    // Process each unit in the global configuration
    Object.keys(globalConfig.globalVariables).forEach(unitName => {
        const unitConfig = globalConfig.globalVariables[unitName];
        console.log(`Processing unit: ${unitName}`);
        
        // Initialize unit state object
        if (!GlobalData.unitStates[unitName]) {
            GlobalData.unitStates[unitName] = {};
        }
        
        // Initialize unit history array
        if (!GlobalData.unitHistory[unitName]) {
            GlobalData.unitHistory[unitName] = [];
        }
        
        // Track points for this unit
        const unitPointNames = [];
        
        // Process each point in the unit
        if (unitConfig.points && Array.isArray(unitConfig.points)) {
            unitConfig.points.forEach(pointConfig => {
                totalPointsFound++;
                
                // ‚úÖ Only check logBoolean
                const logBoolean = pointConfig.logBoolean && pointConfig.logBoolean.toLowerCase() === 'yes_boolean';

                if (logBoolean) {
                    loggablePointsFound++;
                    
                    // Create the point configuration
                    const monitorPoint = {
                        id: `point${idCounter++}`,
                        path: pointConfig.fullPath || unitConfig.basePath.replace('{pointName}', pointConfig.name),
                        systemName: `${unitName}_${pointConfig.name}`,
                        unit: unitName,
                        pointName: pointConfig.name,
                        pointId: pointConfig.id || pointConfig.name,
                        status: pointConfig.status || 'unknown',
                        dateAdded: pointConfig.dateAdded || new Date().toISOString(),
                        logBoolean: pointConfig.logBoolean
                    };
                    
                    monitorPoints.push(monitorPoint);
                    unitPointNames.push(pointConfig.name);
                    
                    // Initialize individual point state
                    if (!GlobalData.unitStates[unitName][pointConfig.name]) {
                        GlobalData.unitStates[unitName][pointConfig.name] = {
                            value: null,
                            timestamp: null,
                            displayName: null
                        };
                    }
                    
                    console.log(`‚úÖ Added loggable point: ${unitName}.${pointConfig.name}`);
                } else {
                    console.log(`‚è≠Ô∏è Skipping point: ${unitName}.${pointConfig.name} (logBoolean: ${pointConfig.logBoolean})`);
                }
            });
        }
        
        // Initialize unit metadata
        if (!GlobalData.unitMetadata[unitName]) {
            GlobalData.unitMetadata[unitName] = {
                type: unitName.startsWith('AHU') ? 'Air Handling Unit' : 
                      unitName.startsWith('VAV') ? 'Variable Air Volume' : 'Unknown',
                points: unitPointNames,
                lastUpdated: null,
                basePath: unitConfig.basePath
            };
        }
    });

    console.log(`üìä Monitor points built from JSON:`);
    console.log(`   - Total points found: ${totalPointsFound}`);
    console.log(`   - Loggable points (logBoolean = "yes_Boolean"): ${loggablePointsFound}`);
    console.log(`   - Units processed: ${Object.keys(globalConfig.globalVariables).length}`);
    console.log(`   - Monitor points created: ${monitorPoints.length}`);
    console.log('üåê Global data structures initialized:', GlobalData);
    
    return {
        totalPoints: totalPointsFound,
        loggablePoints: loggablePointsFound,
        unitsProcessed: Object.keys(globalConfig.globalVariables).length
    };
}


    // INITIALIZATION SEQUENCE - Now properly ordered with JSON loading
    async function initializeSystem() {
        console.log('üöÄ Initializing Niagara logging system with JSON configuration...');
        
        try {
            // Wait for DOM to be ready
            if (document.readyState === 'loading') {
                await new Promise(resolve => {
                    document.addEventListener('DOMContentLoaded', resolve);
                });
            }
            
            // Initialize the display first
            updateDateTime();
            updateMonitoringStatus();
            
            // Load Global.json configuration
            const globalConfig = await loadGlobalConfiguration();
            
            // Build monitor points from the JSON configuration
            const pointStats = buildMonitorPointsFromJson(globalConfig);
            
            // Now load saved data (UI functions are available)
            await loadAllDataFromPersistentStorage();
            
            // Start auto-save
            startAutoSave();
            
            // Set up periodic monitoring (every 10 seconds)
            setInterval(() => {
                if (monitoringActive) {
                    monitorAllPoints();
                }
            }, 10000);

            // Update date/time every second
            setInterval(updateDateTime, 1000);
            
            console.log('üéØ Niagara logging system with JSON-driven configuration initialized');
            console.log(`üìã Loaded ${pointStats.loggablePoints} loggable points from ${pointStats.unitsProcessed} units`);
            console.log('üíæ Auto-save runs every 30 seconds');
            console.log('üîÑ Monitoring cycle runs every 10 seconds');
            console.log('üì± Data persists across page refresh/browser restart');
            console.log('üìä CSV export available via exportLogs() function');
            
            // Show initialization notification
            showNotification('System Initialized', 
                `Loaded ${pointStats.loggablePoints} loggable points from Global.json`, 'success');
            
        } catch (error) {
            console.error('‚ùå Failed to initialize system:', error);
            showNotification('Initialization Error', 'System started with limited functionality', 'error');
            
            // Basic fallback initialization
            updateDateTime();
            updateMonitoringStatus();
            updateEventLogs();
            startAutoSave();
        }
    }

    // Time tracking function
    function updateDateTime() {
        const now = new Date();
        const options = {
            day: '2-digit',
            month: 'short',
            year: 'numeric',
            hour: 'numeric',
            minute: '2-digit',
            hour12: true,
            timeZoneName: 'short'
        };
        const formatted = now.toLocaleString('en-US', options).replace(',', '');
        document.getElementById('currentDateTime').textContent = formatted;
    }
    
    // Function to get formatted timestamp for data points
    function getFormattedTimestamp() {
        const now = new Date();
        const options = {
            day: '2-digit',
            month: 'short',
            year: 'numeric',
            hour: 'numeric',
            minute: '2-digit',
            hour12: true,
            timeZoneName: 'short'
        };
        return now.toLocaleString('en-US', options).replace(',', '');
    }
    
    // Function to update global data when state changes
    function updateGlobalData(pointConfig, value, displayName, timestamp) {
        const unitName = pointConfig.unit;
        const pointName = pointConfig.pointName;
        
        // Store previous value for change detection
        const previousValue = GlobalData.unitStates[unitName][pointName].value;
        
        // Update current state
        GlobalData.unitStates[unitName][pointName] = {
            value: value,
            timestamp: timestamp,
            displayName: displayName
        };
        
        // Update unit metadata
        GlobalData.unitMetadata[unitName].lastUpdated = timestamp;
        
        // Add to history for graphing (with timestamp as Date object for easier plotting)
        const historyEntry = {
            timestamp: new Date(),
            timestampString: timestamp,
            value: value,
            pointName: pointName,
            changed: previousValue !== value
        };
        
        GlobalData.unitHistory[unitName].push(historyEntry);
        
        // Limit history to prevent memory issues (keep last 1000 entries per unit)
        if (GlobalData.unitHistory[unitName].length > 1000) {
            GlobalData.unitHistory[unitName] = GlobalData.unitHistory[unitName].slice(-500);
        }
        
        // Notify subscribers of the change
        if (previousValue !== value) {
            GlobalData._notifySubscribers(unitName, previousValue, value, timestamp);
        }
    }
    
    // Function to add data point to event logs (only on state change)
    function addDataPoint(value, pointConfig, displayName, errorMsg, isStateChange = false) {
        const timestamp = getFormattedTimestamp();
        logCounter++;
        
        // Update global data regardless of whether it's logged
        updateGlobalData(pointConfig, value, displayName, timestamp);
        
        // Determine the log message based on whether it's a state change
        let details;
        if (errorMsg) {
            details = errorMsg;
        } else if (isStateChange) {
            const previousState = lastKnownStates[pointConfig.id];
            if (previousState === undefined) {
                details = `${displayName} = ${value ? 'TRUE' : 'FALSE'} (Initial State)`;
            } else {
                details = `${displayName} changed from ${previousState ? 'TRUE' : 'FALSE'} to ${value ? 'TRUE' : 'FALSE'}`;
            }
        } else {
            details = `${displayName} = ${value ? 'TRUE' : 'FALSE'}`;
        }
        
        // Add to event log
        const logEntry = {
            id: logCounter,
            value: value,
            timestamp: timestamp,
            systemName: pointConfig.systemName || displayName,
            details: details,
            pointId: pointConfig.id,
            displayName: displayName,
            isStateChange: isStateChange,
            unit: pointConfig.unit,
            pointName: pointConfig.pointName
        };
        
        eventLogs.unshift(logEntry);
        
        updateEventLogs();
        
        // Trigger auto-save after new log entry (debounced)
        if (!addDataPoint.saveTimeout) {
            addDataPoint.saveTimeout = setTimeout(async () => {
                try {
                    await saveAllDataToPersistentStorage();
                    console.log('üìä Auto-saved after log entry');
                } catch (error) {
                    console.error('‚ùå Failed to auto-save after log entry:', error);
                }
                addDataPoint.saveTimeout = null;
            }, 5000); // Save 5 seconds after last change
        }
    }
    
    // Function to monitor a single point (only log on state change)
    function monitorSinglePoint(pointConfig) {
        if (!monitoringActive) return;
        
        try {
            baja.Ord.make(pointConfig.path).get()
                .then(function(pointObject) {
                    
                    // Extract the display name from the Niagara point
                    var pathParts = pointConfig.path.split('/');
                    var parentFolder = pathParts[pathParts.indexOf('BcpBacnetNetwork') + 1] || 
                                      pathParts[pathParts.indexOf('Magic_House') + 1] || 
                                      'Unknown';
                    pointConfig.parentFolder = parentFolder;

                    // Use in display name
                    var displayName = `${parentFolder} - ` +
                    (pointObject.getDisplayName ? pointObject.getDisplayName() : 
                     pointObject.getName ? pointObject.getName() : 
                     pointConfig.path.split('/').pop());

                    pointConfig.displayName = displayName;
                    
                    console.log(`[${displayName}] Point resolved:`, pointObject);
                    
                    // Get the current value of the 'out' slot
                    var currentStatus = pointObject.get('out');
                    var boolValue = currentStatus.getValue();
                    
                    console.log(`[${displayName}] Current out value:`, currentStatus);
                    console.log(`[${displayName}] Actual boolean value:`, boolValue);
                    
                    // Check if this is a state change
                    const lastKnownValue = lastKnownStates[pointConfig.id];
                    const isFirstTime = lastKnownValue === undefined;
                    const isStateChange = isFirstTime || (lastKnownValue !== boolValue);
                    
                    // Only log if state changed or it's the first time
                    if (isStateChange) {
                        console.log(`üîÑ [${displayName}] STATE CHANGE DETECTED! ${lastKnownValue === undefined ? '(Initial)' : `${lastKnownValue} ‚Üí ${boolValue}`}`);
                        
                        // Update the last known state
                        lastKnownStates[pointConfig.id] = boolValue;
                        
                        // Add data point to logs
                        addDataPoint(boolValue, pointConfig, displayName, null, true);
                        
                        if (boolValue === true) {
                            console.log(`üö® [${displayName}] ACTIVATED!`);
                        } else {
                            console.log(`üîµ [${displayName}] DEACTIVATED!`);
                        }
                    } else {
                        // No state change - just update global data but don't log
                        updateGlobalData(pointConfig, boolValue, displayName, getFormattedTimestamp());
                        console.log(`‚ö™ [${displayName}] No change - staying ${boolValue ? 'TRUE' : 'FALSE'}`);
                    }

                })
                .catch(function(error) {
                    console.error(`[${pointConfig.id}] Error resolving point:`, error);
                    // Always log errors
                    addDataPoint(false, pointConfig, pointConfig.id, 'Error connecting to system', false);
                });
                
        } catch (error) {
            console.error(`[${pointConfig.id}] Error in monitorSinglePoint:`, error);
            // Always log errors
            addDataPoint(false, pointConfig, pointConfig.id, 'Error initializing monitor', false);
        }
    }
    
    // Function to monitor all points
    function monitorAllPoints() {
        if (!monitoringActive) {
            console.log('‚è∏Ô∏è Monitoring is stopped');
            return;
        }
        
        console.log('üîÑ Checking all points for state changes...');
        monitorPoints.forEach(function(pointConfig) {
            monitorSinglePoint(pointConfig);
        });
    }
    
    // Enhanced Start/Stop monitoring functions
    window.startMonitoring = function() {
        monitoringActive = true;
        updateMonitoringStatus();
        console.log('‚ñ∂Ô∏è Monitoring started');
        
        // Save the monitoring state
        saveAllDataToPersistentStorage().catch(error => 
            console.error('Failed to save monitoring state:', error)
        );
        
        monitorAllPoints();
        
        showNotification('Monitoring Started', 'Point monitoring is now active', 'success');
    };
    
    window.stopMonitoring = function() {
        monitoringActive = false;
        updateMonitoringStatus();
        console.log('‚èπÔ∏è Monitoring stopped');
        
        // Save the monitoring state
        saveAllDataToPersistentStorage().catch(error => 
            console.error('Failed to save monitoring state:', error)
        );
        
        showNotification('Monitoring Stopped', 'Point monitoring has been paused', 'warning');
    };
    
    function updateMonitoringStatus() {
        const statusElement = document.getElementById('monitoringStatus');
        if (statusElement) {
            if (monitoringActive) {
                statusElement.textContent = 'MONITORING ACTIVE';
                statusElement.className = 'monitoring-status monitoring-active';
            } else {
                statusElement.textContent = 'MONITORING STOPPED';
                statusElement.className = 'monitoring-status monitoring-inactive';
            }
        }
    }
    
    // Function to update event logs display
    function updateEventLogs() {
        const logsContainer = document.getElementById('eventLogs');
        
        // Clear existing logs
        logsContainer.innerHTML = '';
        
        // Show recent logs (limit to 4 for performance)
        const recentLogs = eventLogs.slice(0, 4);
        
        // Add event logs
        recentLogs.forEach((log, index) => {
            const logElement = document.createElement('div');
            logElement.className = 'bubbleSP';
            
            const statusClass = log.value ? 'status-ok' : 'status-error';
            const statusText = log.value ? 'ON' : 'OFF';
            const statusIcon = log.value ? 'üîµ': '‚ö™';
            
            const changeIcon = log.isStateChange ? 'üîÑ ' : '';
            
            logElement.innerHTML = `
                <div id="status-point${log.id}" class="point-status status-display ${statusClass}">
                    <div class="status-title">${changeIcon}${statusIcon} ${log.displayName || log.systemName} - ${statusText}</div>
                    <div class="status-details">
                        <p><strong>Timestamp:</strong> ${log.timestamp}</p>
                        <p><strong>Status:</strong> ${log.details}</p>
                        <p><strong>Value:</strong> ${log.value ? 'TRUE' : 'FALSE'}</p>
                    </div>
                </div>
            `;
            
            logsContainer.appendChild(logElement);
        });
        
        // Show message if there are more logs
        if (eventLogs.length > 4) {
            const moreElement = document.createElement('div');
            moreElement.className = 'bubbleSP';
            moreElement.innerHTML = `
                <div class="point-status status-display">
                    <div class="status-title">... and ${eventLogs.length - 4} older entries</div>
                    <div class="status-details">
                        <p>Use Export Logs to view all ${eventLogs.length} entries</p>
                    </div>
                </div>
            `;
            logsContainer.appendChild(moreElement);
        }
        
        // Add message if no logs
        if (eventLogs.length === 0) {
            logsContainer.innerHTML = `
                <div class="bubbleSP">
                    <div class="point-status status-display">
                        <div class="status-title">No state changes recorded</div>
                        <div class="status-details">
                            <p>System is monitoring points for state changes...</p>
                            <p>Logs will only appear when values change from TRUE ‚Üî FALSE</p>
                        </div>
                    </div>
                </div>
            `;
        }
        
        updateOverallStatus();
    }

    // NOW START THE INITIALIZATION (all functions are defined)
    initializeSystem();
    
    // Additional utility functions for JSON management
    
    // Function to reload configuration from Global.json (useful for runtime updates)
    window.reloadGlobalConfig = async function() {
        try {
            console.log('üîÑ Reloading Global.json configuration...');
            
            const globalConfig = await loadGlobalConfiguration();
            const pointStats = buildMonitorPointsFromJson(globalConfig);
            
            // Reset monitoring state for new configuration
            lastKnownStates = {};
            
            console.log('‚úÖ Configuration reloaded successfully');
            console.log(`üìã Now monitoring ${pointStats.loggablePoints} points from ${pointStats.unitsProcessed} units`);
            
            showNotification('Config Reloaded', 
                `Updated to ${pointStats.loggablePoints} loggable points`, 'success');
            
            // Refresh UI
            updateEventLogs();
            updateMonitoringStatus();
            
            return pointStats;
            
        } catch (error) {
            console.error('‚ùå Failed to reload configuration:', error);
            showNotification('Reload Failed', 'Could not reload Global.json', 'error');
            throw error;
        }
    };
    
    // Function to get current configuration summary
    window.getConfigSummary = function() {
        const summary = {
            totalUnits: Object.keys(GlobalData.unitStates).length,
            totalMonitorPoints: monitorPoints.length,
            activePoints: Object.values(lastKnownStates).filter(state => state === true).length,
            inactivePoints: Object.values(lastKnownStates).filter(state => state === false).length,
            unknownPoints: monitorPoints.length - Object.keys(lastKnownStates).length,
            totalLogs: eventLogs.length,
            monitoringActive: monitoringActive
        };
        
        console.log('üìä Current Configuration Summary:', summary);
        return summary;
    };
    
    // Function to validate Global.json structure
    function validateGlobalConfig(config) {
        const errors = [];
        const warnings = [];
        
        if (!config || typeof config !== 'object') {
            errors.push('Global.json must be a valid JSON object');
            return { valid: false, errors, warnings };
        }
        
        if (!config.globalVariables || typeof config.globalVariables !== 'object') {
            errors.push('Global.json must contain "globalVariables" object');
            return { valid: false, errors, warnings };
        }
        
        let totalPoints = 0;
        let loggablePoints = 0;
        
        Object.keys(config.globalVariables).forEach(unitName => {
            const unit = config.globalVariables[unitName];
            
            if (!unit.basePath) {
                warnings.push(`Unit "${unitName}" missing basePath`);
            }
            
            if (!unit.points || !Array.isArray(unit.points)) {
                warnings.push(`Unit "${unitName}" missing or invalid points array`);
            } else {
                unit.points.forEach((point, index) => {
                    totalPoints++;
                    
                    if (!point.name) {
                        warnings.push(`Unit "${unitName}" point ${index} missing name`);
                    }
                    
                    if (point.log && point.log.toLowerCase() === 'yes') {
                        loggablePoints++;
                    }
                    
                    if (!point.log) {
                        warnings.push(`Unit "${unitName}" point "${point.name}" missing log property`);
                    }
                });
            }
        });
        
        const result = {
            valid: errors.length === 0,
            errors,
            warnings,
            stats: {
                units: Object.keys(config.globalVariables).length,
                totalPoints,
                loggablePoints
            }
        };
        
        console.log('üîç Global.json validation result:', result);
        return result;
    }

});













// Enhanced Graph Viewer Functions with Date Filtering - Uses Imported JSON Data
let importedJsonData = null; // Store the imported JSON data here

function initializeGraphViewer() {
    populateUnitSelector();
    initializeDateFilter();
}

// Function to set imported JSON data (call this when JSON is imported)
function setImportedJsonData(jsonData) {
    importedJsonData = jsonData;
    console.log('üìÅ JSON data imported for graphing:', jsonData);
    
    // Refresh the graph viewer if it's active
    if (graphViewerActive) {
        forceRefreshGraph();
    }
}

// Initialize date filter functionality
function initializeDateFilter() {
    const dateInput = document.getElementById('numeric-input');
    if (dateInput) {
        // Set default date to today
        const today = new Date();
        const todayString = today.getFullYear() + '-' + 
                           String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                           String(today.getDate()).padStart(2, '0');
        dateInput.value = todayString;
        dateInput.type = 'date';
        
        console.log(`üìÖ Date input initialized with: ${todayString}`);
        
        // Add event listener for date changes
        dateInput.addEventListener('change', function() {
            console.log(`üìÖ Date changed to: ${dateInput.value}`);
            forceRefreshGraph();
        });
    }
}

// Get selected date with more robust parsing
function getSelectedDate() {
    const dateInput = document.getElementById('numeric-input');
    if (!dateInput || !dateInput.value) {
        console.log('‚ùå No date input found or no value selected');
        return null;
    }
    
    const inputValue = dateInput.value;
    console.log(`üìÖ Raw date input value: "${inputValue}"`);
    
    const selectedDate = new Date(inputValue + 'T00:00:00.000');
    const startOfDay = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate(), 0, 0, 0, 0);
    const endOfDay = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate(), 23, 59, 59, 999);
    
    console.log(`üìÖ Parsed date: ${selectedDate}`);
    console.log(`üåÖ Start of day: ${startOfDay}`);
    console.log(`üåô End of day: ${endOfDay}`);
    
    return {
        dateObject: selectedDate,
        dateString: inputValue,
        startOfDay: startOfDay,
        endOfDay: endOfDay
    };
}

// MODIFIED: Get filtered event logs from imported JSON data instead of GlobalData
function getFilteredEventLogsByDate(unit = null, point = null) {
    const selectedDate = getSelectedDate();
    if (!selectedDate) {
        console.log('‚ö†Ô∏è No date selected, returning empty array');
        return [];
    }
    
    // Check if we have imported JSON data
    if (!importedJsonData) {
        console.log('‚ö†Ô∏è No imported JSON data available');
        return [];
    }
    
    console.log(`üîç Filtering imported JSON data for date: ${selectedDate.dateString}`);
    
    const allEvents = [];
    
    // MODIFIED: Process imported JSON data structure - Handle your specific format
    if (importedJsonData.eventLogs && Array.isArray(importedJsonData.eventLogs)) {
        // Handle your specific JSON format with eventLogs array
        importedJsonData.eventLogs.forEach(event => {
            allEvents.push({
                timestamp: event.timestamp,
                value: event.value,
                unit: event.unit,  // Extract unit directly
                pointName: event.pointName,  // Extract pointName directly
                isStateChange: event.isStateChange || false,
                displayName: event.displayName || `${event.unit} - ${event.pointName}`,
                systemName: event.systemName || `${event.unit}_${event.pointName}`,
                id: event.id,
                details: event.details
            });
        });
        console.log(`üìä Processed eventLogs format: ${importedJsonData.eventLogs.length} events`);
    } else if (Array.isArray(importedJsonData)) {
        // If JSON is an array of events (fallback)
        importedJsonData.forEach(event => {
            allEvents.push({
                timestamp: event.timestamp || event.timestampString,
                value: event.value,
                unit: event.unit || event.unitName,
                pointName: event.pointName || event.point,
                isStateChange: event.isStateChange || event.changed || false,
                displayName: `${event.unit || event.unitName} - ${event.pointName || event.point}`,
                systemName: `${event.unit || event.unitName}_${event.pointName || event.point}`
            });
        });
        console.log(`üìä Processed array format: ${importedJsonData.length} events`);
    } else if (importedJsonData.unitHistory) {
        // If JSON has unitHistory structure (like GlobalData format)
        Object.keys(importedJsonData.unitHistory).forEach(unitName => {
            const unitHistory = importedJsonData.unitHistory[unitName];
            if (unitHistory && Array.isArray(unitHistory)) {
                unitHistory.forEach(historyEntry => {
                    allEvents.push({
                        timestamp: historyEntry.timestampString || historyEntry.timestamp,
                        value: historyEntry.value,
                        unit: unitName,
                        pointName: historyEntry.pointName,
                        isStateChange: historyEntry.changed || false,
                        displayName: `${unitName} - ${historyEntry.pointName}`,
                        systemName: `${unitName}_${historyEntry.pointName}`
                    });
                });
            }
        });
        console.log(`üìä Processed unitHistory format`);
    } else if (typeof importedJsonData === 'object') {
        // If JSON is an object with unit names as keys
        Object.keys(importedJsonData).forEach(unitName => {
            const unitData = importedJsonData[unitName];
            if (Array.isArray(unitData)) {
                unitData.forEach(event => {
                    allEvents.push({
                        timestamp: event.timestamp || event.timestampString,
                        value: event.value,
                        unit: unitName,
                        pointName: event.pointName || event.point,
                        isStateChange: event.isStateChange || event.changed || false,
                        displayName: `${unitName} - ${event.pointName || event.point}`,
                        systemName: `${unitName}_${event.pointName || event.point}`
                    });
                });
            }
        });
        console.log(`üìä Processed object format`);
    }
    
    console.log(`üìä Total events from imported JSON to filter: ${allEvents.length}`);
    
    // Filter with detailed logging
    const filtered = allEvents.filter((log, index) => {
        // Parse the log timestamp
        let logTimestamp;
        if (typeof log.timestamp === 'string') {
            logTimestamp = new Date(log.timestamp);
        } else if (log.timestamp instanceof Date) {
            logTimestamp = log.timestamp;
        } else {
            console.log(`‚ö†Ô∏è Invalid timestamp format at index ${index}: ${log.timestamp}`);
            return false;
        }
        
        // Check if timestamp is valid
        if (isNaN(logTimestamp.getTime())) {
            console.log(`‚ö†Ô∏è Invalid timestamp at index ${index}: "${log.timestamp}"`);
            return false;
        }
        
        // Get just the date part for comparison (ignore time)
        const logDateString = logTimestamp.getFullYear() + '-' + 
                             String(logTimestamp.getMonth() + 1).padStart(2, '0') + '-' + 
                             String(logTimestamp.getDate()).padStart(2, '0');
        
        const selectedDateString = selectedDate.dateString;
        
        // Date match check
        const matchesDate = logDateString === selectedDateString;
        
        // Unit match check
        const matchesUnit = !unit || log.unit === unit;
        
        // Point match check  
        const matchesPoint = !point || log.pointName === point;
        
        const shouldInclude = matchesDate && matchesUnit && matchesPoint;
        
        // Debug logging for first few entries or matches
        if (index < 5 || shouldInclude) {
            console.log(`üìã Index ${index}: ${log.timestamp} (${logDateString}) - Date Match: ${matchesDate}, Unit: ${matchesUnit}, Point: ${matchesPoint}, Include: ${shouldInclude}`);
        }
        
        return shouldInclude;
    });
    
    console.log(`‚úÖ Found ${filtered.length} matching logs for ${selectedDate.dateString}`);
    
    // Log the actual timestamps we found
    if (filtered.length > 0) {
        console.log('üïê Matching timestamps:');
        filtered.forEach((log, i) => {
            console.log(`  ${i + 1}. ${log.timestamp} - ${log.unit} - ${log.pointName} - ${log.value}`);
        });
    } else {
        console.log('‚ùå No matching data found for the selected criteria');
    }
    
    return filtered;
}

// MODIFIED: Enhanced populateUnitSelector using imported JSON data
function populateUnitSelector() {
    const unitSelector = document.getElementById('unitSelector');
    if (!unitSelector) return;

    console.log('üè¢ Populating unit selector from imported JSON data...');

    // Clear existing options
    unitSelector.innerHTML = '<option value="">Select Unit...</option>';

    // Check if we have imported data
    if (!importedJsonData) {
        console.log('‚ö†Ô∏è No imported JSON data available for unit selector');
        // Add a message option
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'Please import JSON data first';
        option.disabled = true;
        unitSelector.appendChild(option);
        return;
    }

    // Get unique units from imported JSON data filtered by selected date
    const filteredLogs = getFilteredEventLogsByDate();
    console.log(`üìä Units available for selected date: filtering from ${filteredLogs.length} logs`);
    
    const uniqueUnits = [...new Set(filteredLogs.map(log => log.unit))].filter(unit => unit).sort();
    console.log(`üè¢ Unique units found: ${uniqueUnits.length}`, uniqueUnits);
    
    uniqueUnits.forEach(unit => {
        const option = document.createElement('option');
        option.value = unit;
        option.textContent = unit;
        unitSelector.appendChild(option);
    });

    // Update data availability indicator
    updateDataAvailabilityIndicator(filteredLogs.length);
}

// MODIFIED: Update point selector using imported JSON data
function updatePointSelector() {
    const unitSelector = document.getElementById('unitSelector');
    const pointSelector = document.getElementById('pointSelector');
    
    if (!unitSelector || !pointSelector) return;

    const selectedUnit = unitSelector.value;
    
    // Clear existing options
    pointSelector.innerHTML = '<option value="">Select Point...</option>';

    if (selectedUnit && importedJsonData) {
        // Get unique points for the selected unit from imported JSON data filtered by date
        const filteredLogs = getFilteredEventLogsByDate(selectedUnit);
        const uniquePoints = [...new Set(filteredLogs.map(log => log.pointName))].sort();
        
        uniquePoints.forEach(point => {
            if (point) {
                const option = document.createElement('option');
                option.value = point;
                option.textContent = point;
                pointSelector.appendChild(option);
            }
        });
    }

    // Clear the graph when unit changes
    clearGraph();
}

// MODIFIED: DrawGraph function using imported JSON data
function drawGraph(unitName, pointName, timeRange) {
    console.log(`üé® Starting drawGraph for ${unitName} - ${pointName} with timeRange: ${timeRange}`);
    
    const canvas = document.getElementById('graphCanvas');
    const noDataMessage = document.getElementById('noDataMessage');
    const graphLegend = document.getElementById('graphLegend');
    const graphStats = document.getElementById('graphStats');
    
    if (!canvas) {
        console.log('‚ùå Canvas not found');
        return;
    }

    // Check if we have imported JSON data
    if (!importedJsonData) {
        noDataMessage.textContent = 'Please import JSON data first to view graphs.';
        noDataMessage.style.display = 'block';
        canvas.style.display = 'none';
        graphLegend.innerHTML = '';
        graphStats.innerHTML = '';
        return;
    }

    const selectedDate = getSelectedDate();
    if (!selectedDate) {
        console.log('‚ùå No date selected');
        clearGraph();
        return;
    }

    const ctx = canvas.getContext('2d');
    
    // Set canvas size
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    // STEP 1: Get data for selected date only from imported JSON data
    let filteredData = getFilteredEventLogsByDate(unitName, pointName);
    console.log(`üìä After date filtering: ${filteredData.length} points for ${selectedDate.dateString}`);
    
    // STEP 2: Apply time range filter within the selected date (if not 'all')
    if (timeRange !== 'all' && !timeRange.includes('All Data') && timeRange !== undefined) {
        const minutesBack = parseInt(timeRange);
        if (!isNaN(minutesBack)) {
            // Calculate cutoff time from the END of the selected day
            const cutoffTime = new Date(selectedDate.endOfDay.getTime() - (minutesBack * 60 * 1000));
            console.log(`‚è∞ Applying time filter: last ${minutesBack} minutes from ${cutoffTime}`);
            
            const beforeTimeFilter = filteredData.length;
            filteredData = filteredData.filter(log => {
                const logTime = new Date(log.timestamp);
                return logTime >= cutoffTime;
            });
            console.log(`‚è∞ After time filtering: ${filteredData.length} points (was ${beforeTimeFilter})`);
        }
    }

    // Convert to graph format
    filteredData = filteredData.map(log => ({
        timestamp: new Date(log.timestamp),
        timestampString: log.timestamp,
        value: log.value,
        changed: log.isStateChange || false,
        pointName: log.pointName
    }));

    // Sort by timestamp
    filteredData.sort((a, b) => a.timestamp - b.timestamp);

    console.log(`üìà Final data points for graph: ${filteredData.length}`);

    // Show no data message if empty
    if (filteredData.length === 0) {
        const dateStr = selectedDate.dateString;
        noDataMessage.textContent = `No data found for ${unitName} - ${pointName} on ${dateStr} in imported JSON`;
        noDataMessage.style.display = 'block';
        canvas.style.display = 'none';
        graphLegend.innerHTML = '';
        graphStats.innerHTML = '';
        console.log('‚ùå No data to display');
        return;
    }

    // Show the graph
    noDataMessage.style.display = 'none';
    canvas.style.display = 'block';

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Graph dimensions
    const padding = 60;
    const graphWidth = canvas.width - (padding * 2);
    const graphHeight = canvas.height - (padding * 2);

    // Draw background
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim() || '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw grid
    drawGrid(ctx, padding, graphWidth, graphHeight);

    // Draw axes
    drawAxesWithDate(ctx, padding, graphWidth, graphHeight, filteredData);

    // Draw data line
    drawDataLine(ctx, padding, graphWidth, graphHeight, filteredData);

    // Update legend and stats
    updateGraphLegend(unitName, pointName, filteredData);
    updateGraphStats(filteredData);
    
    console.log(`‚úÖ Graph completed for ${selectedDate.dateString} using imported JSON data`);
}

function updateGraph() {
    const unitSelector = document.getElementById('unitSelector');
    const pointSelector = document.getElementById('pointSelector');
    const timeRangeSelector = document.getElementById('timeRangeSelector');
    
    if (!unitSelector || !pointSelector) return;

    const selectedUnit = unitSelector.value;
    const selectedPoint = pointSelector.value;
    const timeRange = timeRangeSelector ? timeRangeSelector.value : 'all';

    if (!selectedUnit || !selectedPoint) {
        clearGraph();
        return;
    }

    drawGraph(selectedUnit, selectedPoint, timeRange);
}

// Add data availability indicator
function updateDataAvailabilityIndicator(dataCount) {
    const selectedDate = getSelectedDate();
    if (!selectedDate) return;
    
    // Create or update indicator element
    let indicator = document.getElementById('dataAvailabilityIndicator');
    if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'dataAvailabilityIndicator';
        indicator.style.cssText = `
            margin: 10px 0;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
        `;
        
        const unitSelector = document.getElementById('unitSelector');
        if (unitSelector && unitSelector.parentNode) {
            unitSelector.parentNode.insertBefore(indicator, unitSelector.nextSibling);
        }
    }
    
    const dateStr = selectedDate.dateObject.toLocaleDateString('en-US');
    const dataSource = importedJsonData ? 'imported JSON' : 'no data source';
    
    if (dataCount === 0) {
        indicator.textContent = `No data available for ${dateStr} in ${dataSource}`;
        indicator.style.backgroundColor = '#ffebee';
        indicator.style.color = '#c62828';
        indicator.style.border = '1px solid #ef5350';
    } else {
        indicator.textContent = `${dataCount} data points found for ${dateStr} in imported JSON`;
        indicator.style.backgroundColor = '#e8f5e8';
        indicator.style.color = '#2e7d32';
        indicator.style.border = '1px solid #4caf50';
    }
}

// MODIFIED: Enhanced CSV export with imported JSON data
function exportGraphData() {
    const unitSelector = document.getElementById('unitSelector');
    const pointSelector = document.getElementById('pointSelector');
    const selectedDate = getSelectedDate();
    
    if (!unitSelector || !pointSelector) {
        alert('Please select a unit and point first');
        return;
    }

    const selectedUnit = unitSelector.value;
    const selectedPoint = pointSelector.value;

    if (!selectedUnit || !selectedPoint) {
        alert('Please select both a unit and point to export');
        return;
    }

    if (!importedJsonData) {
        alert('Please import JSON data first');
        return;
    }

    // Get filtered data from imported JSON
    const filteredData = getFilteredEventLogsByDate(selectedUnit, selectedPoint);

    if (filteredData.length === 0) {
        const dateStr = selectedDate ? selectedDate.dateString : 'selected date';
        alert(`No data available for the selected point on ${dateStr} in imported JSON`);
        return;
    }

    // Create CSV content with date info
    const dateStr = selectedDate ? selectedDate.dateString : 'All_Dates';
    let csvContent = 'Timestamp,Value,Changed,Unit,Point\n';
    filteredData.forEach(log => {
        csvContent += `"${log.timestamp}",${log.value ? 'TRUE' : 'FALSE'},${log.isStateChange ? 'YES' : 'NO'},"${selectedUnit}","${selectedPoint}"\n`;
    });

    // Download CSV with date in filename
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `Graph_Data_${selectedUnit}_${selectedPoint}_${dateStr}_ImportedJSON.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
    
    console.log(`üìä Exported ${filteredData.length} data points for ${dateStr} from imported JSON`);
}

// Add this function to manually trigger a complete refresh
function forceRefreshGraph() {
    console.log('üîÑ Force refreshing graph...');
    
    // Clear current selections to force a complete rebuild
    const unitSelector = document.getElementById('unitSelector');
    const pointSelector = document.getElementById('pointSelector');
    
    if (unitSelector && pointSelector) {
        const selectedUnit = unitSelector.value;
        const selectedPoint = pointSelector.value;
        
        // Rebuild unit selector with current date filter
        populateUnitSelector();
        
        // Restore selections if they still exist for this date
        if (selectedUnit) {
            unitSelector.value = selectedUnit;
            updatePointSelector();
            
            if (selectedPoint) {
                pointSelector.value = selectedPoint;
                updateGraph();
            }
        }
    }
}

// Update the toggle graph viewer function
function toggleGraphViewer() {
    const graphViewer = document.getElementById('graphViewer');
    const mainView = document.getElementById('mainView');
    
    if (!graphViewer || !mainView) return;

    graphViewerActive = !graphViewerActive;

    if (graphViewerActive) {
        graphViewer.classList.add('active');
        mainView.classList.add('hidden');
        
        // Initialize graph viewer data with imported JSON
        initializeGraphViewer();
        clearGraph();
        addExportButton();
        
        // Update button text
        const button = document.querySelector('.controls button[onclick="toggleGraphViewer()"]');
        if (button) button.innerHTML = '‚Üê Back to Logs';
    } else {
        graphViewer.classList.remove('active');
        mainView.classList.remove('hidden');
        
        // Update button text
        const button = document.querySelector('.controls button[onclick="toggleGraphViewer()"]');
        if (button) button.innerHTML = 'üìä View Graphs';
    }
}

// Rest of the functions remain the same...
function drawGrid(ctx, padding, width, height) {
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
    ctx.lineWidth = 0.5;
    ctx.setLineDash([2, 2]);

    // Vertical grid lines
    for (let i = 0; i <= 10; i++) {
        const x = padding + (width * i / 10);
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, padding + height);
        ctx.stroke();
    }

    // Horizontal grid lines
    for (let i = 0; i <= 4; i++) {
        const y = padding + (height * i / 4);
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(padding + width, y);
        ctx.stroke();
    }

    ctx.setLineDash([]);
}

function drawAxesWithDate(ctx, padding, width, height, data) {
    const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim() || '#000000';
    ctx.strokeStyle = textColor;
    ctx.lineWidth = 2;
    ctx.font = '12px Segoe UI, sans-serif';
    ctx.fillStyle = textColor;

    // Draw axes
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, padding + height);
    ctx.lineTo(padding + width, padding + height);
    ctx.stroke();

    // Y-axis labels (TRUE/FALSE)
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    ctx.fillText('TRUE', padding - 10, padding + height * 0.25);
    ctx.fillText('FALSE', padding - 10, padding + height * 0.75);

    // X-axis labels with logical time intervals
    const selectedDate = getSelectedDate();
    if (selectedDate) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        
        // Use the full selected day range for X-axis
        const startTime = selectedDate.startOfDay;
        const endTime = selectedDate.endOfDay;
        
        // Use logical 4-hour intervals
const timeLabels = [
    new Date(startTime.getTime()),                    // 12:00 AM (start of day)
    new Date(startTime.getTime() + 4 * 60 * 60 * 1000), // 4:00 AM
    new Date(startTime.getTime() + 8 * 60 * 60 * 1000), // 8:00 AM  
    new Date(startTime.getTime() + 12 * 60 * 60 * 1000), // 12:00 PM (noon)
    new Date(startTime.getTime() + 16 * 60 * 60 * 1000), // 4:00 PM
    new Date(startTime.getTime() + 20 * 60 * 60 * 1000), // 8:00 PM
    new Date(endTime.getTime()),                      // 11:59:59 PM ‚Üí displays as 12:00 AM
];
        timeLabels.forEach((timePoint, i) => {
            const x = padding + (width * i / 5);
            const timeStr = timePoint.toLocaleTimeString('en-US', { 
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });
            ctx.fillText(timeStr, x, padding + height + 10);
        });
        
        // Add date label at bottom center
        ctx.font = 'bold 14px Segoe UI, sans-serif';
        const dateStr = selectedDate.dateObject.toLocaleDateString('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
        ctx.fillText(dateStr, padding + width / 2, padding + height + 35);
    }

    // Axis titles
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = 'bold 14px Segoe UI, sans-serif';
    
    // Y-axis title
    ctx.save();
    ctx.translate(20, padding + height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Point Value', 0, 0);
    ctx.restore();
    
    // X-axis title
    ctx.fillText('Time', padding + width / 2, padding + height + 55);
}

function drawDataLine(ctx, padding, width, height, data) {
    if (data.length === 0) return;

    const selectedDate = getSelectedDate();
    if (!selectedDate) return;

    // Use the full selected day range for X-axis positioning
    const startTime = selectedDate.startOfDay.getTime();
    const endTime = selectedDate.endOfDay.getTime();
    const timeRange = endTime - startTime;

    console.log(`üìä Drawing data line with day range: ${new Date(startTime)} to ${new Date(endTime)}`);
    console.log(`üìä Data points to plot: ${data.length}`);

    // Draw step line
    ctx.strokeStyle = '#3498db';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    ctx.beginPath();
    
    for (let i = 0; i < data.length; i++) {
        const entry = data[i];
        
        // Position X based on the FULL DAY range
        const x = padding + (width * (entry.timestamp.getTime() - startTime) / timeRange);
        const y = padding + (entry.value ? height * 0.25 : height * 0.75);

        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            // Create step line (horizontal then vertical)
            const prevY = padding + (data[i-1].value ? height * 0.25 : height * 0.75);
            ctx.lineTo(x, prevY); // Horizontal line
            ctx.lineTo(x, y); // Vertical line
        }
        
        console.log(`üìç Point ${i}: ${entry.timestamp.toLocaleTimeString()} at x=${Math.round(x)}, y=${Math.round(y)}`);
    }
    
    ctx.stroke();

    // Draw data points
    data.forEach((entry, index) => {
        const x = padding + (width * (entry.timestamp.getTime() - startTime) / timeRange);
        const y = padding + (entry.value ? height * 0.25 : height * 0.75);
        
        ctx.beginPath();
        ctx.arc(x, y, entry.changed ? 6 : 4, 0, 2 * Math.PI);
        ctx.fillStyle = entry.changed ? '#e74c3c' : '#3498db';
        ctx.fill();
        
        // Highlight state changes
        if (entry.changed) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    });
}

function updateGraphLegend(unitName, pointName, data) {
    const graphLegend = document.getElementById('graphLegend');
    if (!graphLegend) return;

    graphLegend.innerHTML = `
        <div class="legend-item">
            <div class="legend-color" style="background: #3498db;"></div>
            <span>Data Line</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #e74c3c; height: 6px; border-radius: 50%;"></div>
            <span>State Changes</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #2c3e50; height: 4px; border-radius: 50%;"></div>
            <span>Data Points</span>
        </div>
    `;
}

function updateGraphStats(data) {
    const graphStats = document.getElementById('graphStats');
    if (!graphStats) return;

    // Calculate statistics
    const totalPoints = data.length;
    const stateChanges = data.filter(entry => entry.changed).length;
    const trueCount = data.filter(entry => entry.value === true).length;
    const falseCount = data.filter(entry => entry.value === false).length;
    const uptime = totalPoints > 0 ? ((trueCount / totalPoints) * 100).toFixed(1) : 0;

    graphStats.innerHTML = `
        <div class="stat-card">
            <div class="stat-value">${totalPoints}</div>
            <div class="stat-label">Total Data Points</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">${stateChanges}</div>
            <div class="stat-label">State Changes</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">${uptime}%</div>
            <div class="stat-label">TRUE Ratio</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">${data.length > 0 ? new Date(data[data.length - 1].timestamp).toLocaleTimeString() : 'N/A'}</div>
            <div class="stat-label">Last Update</div>
        </div>
    `;
}

function clearGraph() {
    const canvas = document.getElementById('graphCanvas');
    const noDataMessage = document.getElementById('noDataMessage');
    const graphLegend = document.getElementById('graphLegend');
    const graphStats = document.getElementById('graphStats');
    
    if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.style.display = 'none';
    }
    
    if (noDataMessage) {
        const message = importedJsonData ? 
            'Select a unit and point to view graph data from imported JSON.' :
            'Import JSON data first, then select a unit and point to view graphs.';
        noDataMessage.textContent = message;
        noDataMessage.style.display = 'block';
    }
    
    if (graphLegend) graphLegend.innerHTML = '';
    if (graphStats) graphStats.innerHTML = '';
}

// Add export button to graph controls when graph viewer is initialized
function addExportButton() {
    const graphControls = document.querySelector('.graph-controls');
    if (graphControls && !document.getElementById('exportGraphBtn')) {
        const exportBtn = document.createElement('button');
        exportBtn.id = 'exportGraphBtn';
        exportBtn.className = 'btn btn-info';
        exportBtn.onclick = exportGraphData;
        exportBtn.innerHTML = 'üìà Export Graph Data';
        graphControls.appendChild(exportBtn);
    }
}

// Dark mode toggle
document.addEventListener('DOMContentLoaded', function() {
    const toggleSwitch = document.getElementById('toggleSwitch');
    const toggleLabel = document.querySelector('.toggle-label');
    
    // Check for saved theme preference or default to light mode
    const currentTheme = localStorage.getItem('theme') || 'light';
    document.documentElement.setAttribute('data-theme', currentTheme);
    
    if (currentTheme === 'dark') {
        toggleSwitch.classList.add('active');
        toggleLabel.textContent = 'Dark Mode';
    } else {
        toggleLabel.textContent = 'Light Mode';
    }
    
    toggleSwitch.addEventListener('click', function() {
        const currentTheme = document.documentElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        
        document.documentElement.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
        
        if (newTheme === 'dark') {
            toggleSwitch.classList.add('active');
            toggleLabel.textContent = 'Dark Mode';
        } else {
            toggleSwitch.classList.remove('active');
            toggleLabel.textContent = 'Light Mode';
        }
        
        // Redraw graph if active to update colors
        if (graphViewerActive) {
            updateGraph();
        }
    });
});

// Resize canvas when window resizes
window.addEventListener('resize', function() {
    if (graphViewerActive) {
        setTimeout(updateGraph, 100);
    }
});

// Initialize everything when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    // Initialize graph viewer with imported JSON data source
    setTimeout(initializeGraphViewer, 1000);
});

// Keyboard shortcuts for graph viewer
document.addEventListener('keydown', function(e) {
    // Ctrl/Cmd + G to toggle graph viewer
    if ((e.ctrlKey || e.metaKey) && e.key === 'g') {
        e.preventDefault();
        toggleGraphViewer();
    }
    
    // Escape key to go back to logs from graph viewer
    if (e.key === 'Escape' && graphViewerActive) {
        toggleGraphViewer();
    }
});

// Performance optimization: Only update graph if it's visible
function optimizedUpdateGraph() {
    if (graphViewerActive && document.getElementById('graphViewer').classList.contains('active')) {
        updateGraph();
    }
}

// Add tooltip functionality for data points
function addGraphTooltips() {
    const canvas = document.getElementById('graphCanvas');
    if (!canvas) return;

    canvas.addEventListener('mousemove', function(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        canvas.title = `Click and drag to zoom, double-click to reset view`;
    });
}

// Initialize tooltips when graph viewer is ready
setTimeout(addGraphTooltips, 2000);

// IMPORTANT: Call this function when you import JSON data in your main application
// Example usage:
document.getElementById('jsonFileInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(event) {
            try {
                const jsonData = JSON.parse(event.target.result);
                setImportedJsonData(jsonData); // This connects your imported data to the graph viewer
            } catch (error) {
                console.error('Error parsing JSON:', error);
            }
        };
        reader.readAsText(file);
    }
});

console.log('üéØ Enhanced Niagara System Monitor with JSON Data Graphing Ready!');
console.log('üìä Use setImportedJsonData(jsonData) to connect imported JSON to the graph viewer');
console.log('üìà Graph viewer now uses imported JSON data instead of GlobalData');
console.log('üîç Select date, unit, and point to view imported data graphs');
    </script>


</body>
</html>