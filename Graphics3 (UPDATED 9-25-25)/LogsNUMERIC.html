<!DOCTYPE html>
<!-- @noSnoop -->
<html lang="en" xmlns:b="http://www.tridium.com/baja/baja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Murphy Control Panel - AHU Monitoring</title>

<!-- Add RequireJS and BajaScript Support -->
<script type='text/javascript' src='/requirejs/config.js'></script>
<script type='text/javascript' src='/module/js/com/tridium/js/ext/require/require.min.js?'></script>

    <style>
        :root {
                    --border-color: #dddddd;
            --primary-color: #007bff;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --info-color: #17a2b8;
            --secondary-color: #6c757d;
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --danger-color: #e74c3c;
            --bg-color: #ecf0f1;
            --card-bg: #ffffff;
            --text-color: #2c3e50;
            --border-color: #bdc3c7;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --card-bg: #2d2d2d;
            --text-color: #ffffff;
            --border-color: #404040;
            --primary-color: #34495e;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--info-color));
            color: white;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .title {
            font-size: 28px;
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: var(--text-color);
            opacity: 0.8;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: var(--secondary-color);
            color: white;
        }

        .btn-success {
            background: var(--success-color);
            color: white;
        }

        .btn-warning {
            background: var(--warning-color);
            color: white;
        }

        .btn-danger {
            background: var(--danger-color);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .card {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
        }

        .status-display {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .status-ok {
            background: rgba(39, 174, 96, 0.1);
            border: 1px solid var(--success-color);
            color: var(--success-color);
        }

        .status-warning {
            background: rgba(243, 156, 18, 0.1);
            border: 1px solid var(--warning-color);
            color: var(--warning-color);
        }

        .status-error {
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid var(--danger-color);
            color: var(--danger-color);
        }

        .status-title {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 8px;
        }

        .status-details {
            font-size: 14px;
            line-height: 1.5;
        }

        .monitoring-status {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .monitoring-active {
            background: rgba(39, 174, 96, 0.1);
            color: var(--success-color);
            border: 2px solid var(--success-color);
        }

        .monitoring-inactive {
            background: rgba(231, 76, 60, 0.1);
            color: var(--danger-color);
            border: 2px solid var(--danger-color);
        }

        .datetime {
            text-align: center;
            font-size: 16px;
            color: var(--text-color);
            margin-bottom: 10px;
        }

        .graph-viewer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-color);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            overflow-y: auto;
        }

        .graph-viewer.active {
            opacity: 1;
            visibility: visible;
        }

        .graph-header {
            background: var(--primary-color);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        .graph-container {
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .series-container {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .series-controls {
            flex: 1;
            min-width: 300px;
            border: 2px solid;
            border-radius: 8px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text-color);
        }

        .control-group select, .control-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--card-bg);
            color: var(--text-color);
            font-size: 14px;
        }

        .graph-canvas-container {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            min-height: 500px;
            position: relative;
        }

        #graphCanvas {
            width: 100%;
            height: 450px;
            cursor: crosshair;
        }

        #noDataMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-color);
            opacity: 0.6;
            font-size: 16px;
        }

        .graph-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .graph-stats, .graph-legend {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
        }

        .stat-card {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            margin: 5px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.8;
        }

        .toggle-container {
            position: fixed;
            top: 145px;
            right: 400px;
            z-index: 1001;
        }

        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: var(--border-color);
            border-radius: 15px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: var(--secondary-color);
        }

        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 12px;
            transition: transform 0.3s;
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(30px);
        }

        .toggle-label {
            margin-left: 10px;
            font-size: 12px;
            color: var(--text-color);
        }

        .hidden {
            display: none !important;
        }

        .bubbleSP {
            margin: 10px 0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .series-container {
                flex-direction: column;
            }
            
            .graph-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
                .header {
            background: linear-gradient(135deg, var(--primary-color), var(--info-color));
            color: white;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        
        .header h1 {
            margin: 0;
            font-size: 2rem;
            font-weight: 300;
        }

        .header-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }

        .datetime {
            font-size: 1rem;
            opacity: 0.9;
        }

        .monitoring-status {
            font-size: 0.9rem;
            padding: 5px 12px;
            border-radius: 20px;
            font-weight: 500;
        }

        .monitoring-active {
            background: rgba(40, 167, 69, 0.2);
            border: 1px solid rgba(40, 167, 69, 0.5);
        }

        .monitoring-inactive {
            background: rgba(220, 53, 69, 0.2);
            border: 1px solid rgba(220, 53, 69, 0.5);
        }

        .dark-mode-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toggle-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .toggle-switch {
            width: 50px;
            height: 24px;
            background: rgba(255,255,255,0.3);
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

    </style>
</head>
<body>
<!--<div class="header">-->



    <!--</div>-->
    <div id="mainView" class="container">
        <!-- Header styled like boolean monitor -->
        <div class="header">
            <h1>Enhanced Numerical System Monitor</h1>
            <div style="display: flex; align-items: center;">
                <div class="header-info" style="position: relative; left: -40px;">
                    <div id="currentDateTime" class="datetime"></div>
                    <div id="monitoringStatus" class="monitoring-status">NUMERICAL MONITORING STOPPED</div>
                </div>
                
                    <!-- Dark Mode Toggle -->
    <div class="toggle-container">
        <div style="display: flex; align-items: center;">
            <div id="toggleSwitch" class="toggle-switch">
                <div class="toggle-slider"></div>
            </div>
            <span class="toggle-label">Light Mode</span>
        </div>
    </div>
                <!--<div class="dark-mode-toggle">-->
                <!--    <span class="toggle-label">Light Mode</span>-->
                <!--    <div class="toggle-switch" id="toggleSwitch" onclick="toggleDarkMode()"></div>-->
                <!--</div>-->
            </div>
        </div>
        <div class="container">
            <!-- Configuration Status -->
            <div class="card">
                <h2>Configuration Status</h2>
                <div id="configStatus" class="config-status">
                    <div class="status-display status-warning">
                        <div class="status-title">Loading Global.json configuration...</div>
                        <div class="status-details">
                            <p>Attempting to read Global.json from directory</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Control Panel -->
            <div class="card">
                <h2>Control Panel</h2>
                <div class="controls">
                    <button class="btn btn-success" onclick="startMonitoring()">Start Monitoring</button>
                    <button class="btn btn-warning" onclick="stopMonitoring()">Stop Monitoring</button>
                    <button class="btn btn-primary" onclick="collectDataNow()">Collect Now</button>
                    <button class="btn btn-primary" onclick="reloadConfig()">Reload Config</button>
                    <button class="btn btn-secondary" onclick="exportLogs()">Export CSV</button>
                    <button class="btn btn-secondary" onclick="exportFullDataJSON()">Export JSON</button>
                    <button class="btn btn-primary" onclick="toggleGraphViewer()">View Graphs</button>
                    <button class="btn btn-danger" onclick="clearLogs()">Clear Logs</button>
                </div>
            </div>

            <!-- System Status -->
            <div class="card">
                <h2>System Status</h2>
                <div id="system-status">
                    <!-- Overall summary will be injected here -->
                </div>
                <div id="lastSaveTime" style="margin-top: 10px; font-size: 0.9rem; color: var(--text-muted);"></div>
            </div>

            <!-- Recent Logs -->
            <div class="card">
                <h2>Recent Numerical Data (Last 5 Entries)</h2>
                <div id="eventLogs">
                    <!-- Logs will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Viewer -->
    <div id="graphViewer" class="graph-viewer">
        <div class="graph-header">
            <h2>Numerical Data Graphs</h2>
            <button class="btn btn-danger" onclick="toggleGraphViewer()">Close Graphs</button>
        </div>
        
        <div class="graph-container">
            <!-- Graph Controls -->
            <div class="graph-controls">
                <div class="control-group">
                    <label class="control-label">Date:</label>
                    <input type="date" id="dateInput" onchange="updateGraph()">
                </div>
                <div class="control-group">
                    <label class="control-label">Time Range:</label>
                    <select id="timeRangeSelector" onchange="updateGraph()">
                        <option value="all">Full Day</option>
                        <option value="60">Last Hour</option>
                        <option value="240">Last 4 Hours</option>
                        <option value="480">Last 8 Hours</option>
                        <option value="720">Last 12 Hours</option>
                    </select>
                </div>
                <button class="btn btn-primary" onclick="forceRefreshGraph()">Refresh Graph</button>
            </div>

            <!-- Series Selection (Auto-populated from Global.json) -->
            <!--<div class="series-container" id="seriesContainer">-->
                <!-- Series will be dynamically created here -->
            <!--</div>-->

            <!-- Dynamic Series Container -->
            <div class="series-container" style="
                display: flex; 
                gap: 15px; 
                align-items: flex-start; 
                flex-wrap: wrap;
                margin: 20px 0;
                padding: 15px;
                background: rgba(0, 0, 0, 0.02);
                border-radius: 8px;
                border: 1px solid #e0e0e0;
            ">
                <!-- Series controls will be dynamically added here -->
            </div>


            <!-- Graph Canvas -->
            <div class="graph-canvas-container">
                <canvas id="graphCanvas"></canvas>
                <div id="noDataMessage">Select points to view numerical graph data.</div>
            </div>

            <!-- Graph Legend -->
            <div class="graph-legend" id="graphLegend"></div>

            <!-- Graph Statistics -->
            <div class="graph-stats" id="graphStats"></div>
        </div>
    </div>










    <script>
        // Global variables
                let importedJsonData = null;
        let eventLogs = [];
        let monitoringActive = false;
        let logCounter = 0;
        let startTime = new Date();
        let lastCollectionTime = null;
        let graphViewerActive = false;
        let globalConfig = null;
        let monitoredPoints = [];
        let activeSeries = [];
        let seriesColors = ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6'];
        let maxSeries = 5;
        let historyCache = new Map();
        let graphDataPoints = [];

// let zoomState = {
//     isZoomed: false,
//     startTime: null,
//     endTime: null,
//     isDragging: false,
//     dragStart: null,
//     dragEnd: null
// };

        // Initialize system
        function initializeSystem() {
            updateDateTime();
            updateMonitoringStatus();
            updateEventLogs();
            initializeDateInput();
            loadGlobalConfig();
            
            // Start auto-save every 30 seconds
            setInterval(saveData, 30000);
            
            // Start data collection every 15 minutes (900000ms)
            setInterval(() => {
                if (monitoringActive) {
                    collectAllData();
                }
            }, 900000);
            
            // Update time every second
            setInterval(updateDateTime, 1000);
            
            console.log('Niagara Numerical System Monitor initialized');
        }

async function loadGlobalConfig() {
    try {
        const response = await fetch('./Global.json');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        globalConfig = await response.json();
        parseMonitoredPoints();
        updateConfigStatus();
        
        console.log('Global.json loaded successfully');
        console.log('Monitored points found:', monitoredPoints.length);
        
    } catch (error) {
        console.error('Error loading Global.json:', error);
        updateConfigStatus(error.message);
    }
}



        function parseMonitoredPoints() {
            monitoredPoints = [];
            
            if (!globalConfig || !globalConfig.globalVariables) {
                console.warn('No globalVariables found in config');
                return;
            }
            
            for (const [unitName, unitData] of Object.entries(globalConfig.globalVariables)) {
                if (!unitData.points || !Array.isArray(unitData.points)) {
                    continue;
                }
                
                unitData.points.forEach(point => {
                    if (point.logNumeric === "yes_Numeric" && point.status === "connected") {
                        monitoredPoints.push({
                            unit: unitName,
                            pointName: point.name,
                            fullPath: point.fullPath,
                            basePath: unitData.basePath,
                            id: point.id,
                            dateAdded: point.dateAdded,
                            displayName: `${unitName} - ${point.name}`
                        });
                    }
                });
            }
            
            console.log('Parsed monitored points:', monitoredPoints);
        }


        function updateConfigStatus(errorMessage = null) {
            const configStatus = document.getElementById('configStatus');
            
            if (errorMessage) {
                configStatus.innerHTML = `
                    <div class="status-display status-error">
                        <div class="status-title">Configuration Error</div>
                        <div class="status-details">
                            <p><strong>Error:</strong> ${errorMessage}</p>
                            <p>Please ensure Global.json exists in the same directory</p>
                            <p>Click "Reload Config" to try again</p>
                        </div>
                    </div>
                `;
            } else if (globalConfig) {
                const totalUnits = Object.keys(globalConfig.globalVariables || {}).length;
                const totalPoints = monitoredPoints.length;
                
                configStatus.innerHTML = `
                    <div class="status-display status-ok">
                        <div class="status-title">Configuration Loaded Successfully</div>
                        <div class="status-details">
                            <p><strong>Units Found:</strong> ${totalUnits}</p>
                            <p><strong>Numerical Points to Monitor:</strong> ${totalPoints}</p>
                            <p><strong>Config File:</strong> Global.json</p>
                            <p><strong>Last Loaded:</strong> ${new Date().toLocaleString()}</p>
                        </div>
                    </div>
                `;
            }
        }

        function reloadConfig() {
            loadGlobalConfig();
        }

        function updateDateTime() {
            const now = new Date();
            const formatted = now.toLocaleString('en-US', {
                day: '2-digit',
                month: 'short',
                year: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true,
                timeZoneName: 'short'
            });
            document.getElementById('currentDateTime').textContent = formatted;
        }

        function updateMonitoringStatus() {
            const statusElement = document.getElementById('monitoringStatus');
            if (monitoringActive) {
                statusElement.textContent = 'NUMERICAL MONITORING ACTIVE';
                statusElement.className = 'monitoring-status monitoring-active';
            } else {
                statusElement.textContent = 'NUMERICAL MONITORING STOPPED';
                statusElement.className = 'monitoring-status monitoring-inactive';
            }
        }

        // BQL History Discovery
        async function discoverHistoryOrd(pointOrd) {
            return new Promise((resolve, reject) => {
                try {
                    if (typeof require === 'undefined') {
                        reject(new Error('Niagara environment required for history access'));
                        return;
                    }
                    
                    require(['baja!'], function (baja) {
                        'use strict';
                        
                        console.log('Auto-discovering history from point:', pointOrd);
                        
                        baja.Ord.make(pointOrd).get()
                            .then(function(entity) {
                                return entity.tags();
                            })
                            .then(function(tagMap) {
                                var historyTag = tagMap.get('n:history');
                                console.log('Found history tag:', historyTag);
                                
                                if (historyTag && historyTag.toString().trim() !== '') {
                                    var historyPath = historyTag.toString();
                                    
                                    if (!historyPath.startsWith('history:')) {
                                        historyPath = 'history:' + historyPath;
                                    }
                                    
                                    console.log('Discovered history ORD:', historyPath);
                                    resolve(historyPath);
                                } else {
                                    reject(new Error('No n:history tag found on point: ' + pointOrd));
                                }
                            })
                            .catch(function(err) {
                                console.error('Could not load tags:', err);
                                reject(new Error('Failed to load point tags: ' + err.message));
                            });
                    });
                } catch (error) {
                    console.error('Baja require error:', error);
                    reject(error);
                }
            });
        }

        // Load numerical history data using BQL
        async function loadNumericalHistoryData(pointPath, startTime, endTime, maxPoints = 1000) {
            return new Promise(async (resolve, reject) => {
                try {
                    const cacheKey = pointPath;
                    let historyOrd = historyCache.get(cacheKey);
                    
                    if (!historyOrd) {
                        try {
                            historyOrd = await discoverHistoryOrd(pointPath);
                            historyCache.set(cacheKey, historyOrd);
                        } catch (error) {
                            console.warn(`No history found for point ${pointPath}:`, error.message);
                            resolve([]);
                            return;
                        }
                    }
                    
                    if (typeof require === 'undefined') {
                        reject(new Error('Niagara environment required'));
                        return;
                    }
                    
                    require(['baja!'], function (baja) {
                        'use strict';
                        
                        const timeCondition = `timestamp >= '${startTime.toISOString()}' and timestamp <= '${endTime.toISOString()}'`;
                        const bqlQuery = historyOrd + '|bql:select timestamp, value where ' + timeCondition + ' order by timestamp';
                        
                        console.log('Executing Numerical History BQL Query:', bqlQuery);
                        
                        const dataPoints = [];
                        
                        baja.Ord.make(bqlQuery).get({
                            cursor: {
                                limit: maxPoints,
                                each: function () {
                                    const row = this.get();
                                    const rawTimestamp = row.get("timestamp");
                                    const value = row.get("value");
                                    
                                    const date = new Date(rawTimestamp.getMillis());
                                    const numericValue = parseFloat(value);
                                    
                                    if (!isNaN(numericValue)) {
                                        dataPoints.push({
                                            timestamp: date,
                                            timestampString: date.toLocaleString(),
                                            timestampObj: date,
                                            value: numericValue
                                        });
                                    }
                                }
                            }
                        })
                        .then(function () {
                            console.log(`Loaded ${dataPoints.length} numerical history points for ${pointPath}`);
                            resolve(dataPoints);
                        })
                        .catch(function (err) {
                            console.error('Numerical History BQL Query failed:', err);
                            reject(new Error('Failed to load numerical history data: ' + err.message));
                        });
                    });
                    
                } catch (error) {
                    console.error('Numerical history loading error:', error);
                    reject(error);
                }
            });
        }

        // Extract data unit from point name
        function extractDataUnit(pointNameOrOrd) {
            if (!pointNameOrOrd) return '';
            
            const name = pointNameOrOrd.toLowerCase();
            
            if (name.includes('Temp') || name.includes('temperature') || name.includes('DischargeAirTemp')) return '°F';
            if (name.includes('flow') || name.includes('airflow') || name.includes('air-flow')) return 'CFM';
            if (name.includes('pressure')) return 'PSI';
            if (name.includes('humidity')) return '%';
            if (name.includes('percent') || name.includes('pct')) return '%';
            if (name.includes('speed')) return '%';
            if (name.includes('power')) return 'kW';
            if (name.includes('current')) return 'A';
            if (name.includes('voltage')) return 'V';
            if (name.includes('frequency') || name.includes('freq')) return 'Hz';
            if (name.includes('Static')) return 'in/wc';
            
            return '';
        }


function initializeSeriesContainer() {
    const seriesContainer = document.querySelector('.series-container');
    if (!seriesContainer) return;
    
    // Clear existing content
    seriesContainer.innerHTML = '';
    
    // Reset active series
    activeSeries = [];
    
    // Add initial series
    addNewSeries();
    
    console.log('Series container initialized with dynamic series system');
}

function addNewSeries() {
    if (activeSeries.length >= maxSeries) {
        updateImportStatus(`Maximum of ${maxSeries} series allowed`, 'warning');
        return;
    }
    
    const seriesId = Date.now() + Math.random();
    const seriesIndex = activeSeries.length;
    const seriesColor = seriesColors[seriesIndex];
    
    const series = {
        id: seriesId,
        index: seriesIndex,
        unit: '',
        point: '',
        color: seriesColor,
        label: `Series ${seriesIndex + 1}`
    };
    
    activeSeries.push(series);
    
    const seriesContainer = document.querySelector('.series-container');
    const seriesDiv = createSeriesControls(series);
    
    // Insert before the add button (if it exists)
    const addButton = document.getElementById('addSeriesButton');
    if (addButton) {
        seriesContainer.insertBefore(seriesDiv, addButton);
    } else {
        seriesContainer.appendChild(seriesDiv);
    }
    
    updateAddSeriesButton();
    updateAllSeriesSelectors();
}

function removeSeries(seriesId) {
    // Find and remove the series
    const seriesIndex = activeSeries.findIndex(s => s.id == seriesId);
    if (seriesIndex === -1) return;
    
    // Don't allow removing the first series
    if (seriesIndex === 0) {
        updateImportStatus('Cannot remove the primary series', 'warning');
        return;
    }
    
    // Remove from active series
    activeSeries.splice(seriesIndex, 1);
    
    // Remove the DOM element
    const seriesElement = document.getElementById(`series-${seriesId}`);
    if (seriesElement) {
        seriesElement.remove();
    }
    
    // Update indices and colors for remaining series
    activeSeries.forEach((series, index) => {
        series.index = index;
        series.color = seriesColors[index];
        series.label = index === 0 ? 'Primary Series' : `Series ${index + 1}`;
        
        // Update the visual styling
        const seriesElement = document.getElementById(`series-${series.id}`);
        if (seriesElement) {
            seriesElement.style.borderColor = series.color;
            const title = seriesElement.querySelector('h4');
            if (title) {
                title.textContent = series.label;
                title.style.color = series.color;
            }
        }
    });
    
    updateAddSeriesButton();
    updateGraph();
}

function updateAddSeriesButton() {
    const seriesContainer = document.querySelector('.series-container');
    if (!seriesContainer) return;
    
    // Remove existing add button
    const existingButton = document.getElementById('addSeriesButton');
    if (existingButton) {
        existingButton.remove();
    }
    
    // Add new add button if we haven't reached the max
    if (activeSeries.length < maxSeries) {
        const addButton = document.createElement('div');
        addButton.id = 'addSeriesButton';
        addButton.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 120px;
            border: 2px dashed #7f8c8d;
            border-radius: 8px;
            margin: 5px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.02);
            transition: all 0.3s;
            flex: 0 0 200px;
        `;
        
        addButton.innerHTML = `
            <div style="text-align: center; color: #7f8c8d;">
                <div style="font-size: 24px; margin-bottom: 5px;">+</div>
                <div style="font-size: 12px;">Add Series</div>
                <div style="font-size: 11px; opacity: 0.7;">(${activeSeries.length}/${maxSeries})</div>
            </div>
        `;
        
        addButton.addEventListener('mouseenter', function() {
            this.style.borderColor = '#3498db';
            this.style.background = 'rgba(52, 152, 219, 0.1)';
        });
        
        addButton.addEventListener('mouseleave', function() {
            this.style.borderColor = '#7f8c8d';
            this.style.background = 'rgba(255, 255, 255, 0.02)';
        });
        
        addButton.addEventListener('click', addNewSeries);
        
        seriesContainer.appendChild(addButton);
    }
}

function updateAllSeriesSelectors() {
    activeSeries.forEach(series => {
        populateUnitSelectorForSeries(series.id);
        updatePointSelector(series.id);
    });
}


function updatePointSelector(seriesId) {
    const unitSelector = document.getElementById(`unitSelector-${seriesId}`);
    const pointSelector = document.getElementById(`pointSelector-${seriesId}`);

    if (!unitSelector || !pointSelector) return;

    const selectedUnit = unitSelector.value;
    const currentValue = pointSelector.value; // Preserve current selection
    const isFirstSeries = activeSeries.find(s => s.id == seriesId).index === 0;

    pointSelector.innerHTML = `<option value="">${isFirstSeries ? 'Select Point...' : 'Select Point (Optional)...'}</option>`;

    if (selectedUnit) {
        if (monitoredPoints.length > 0) {
            const unitPoints = monitoredPoints
                .filter(point => point.unit === selectedUnit)
                .map(point => point.pointName)
                .sort();

            unitPoints.forEach(pointName => {
                const option = document.createElement('option');
                option.value = pointName;
                option.textContent = pointName;

                if (pointName === currentValue) {
                    option.selected = true;
                }

                pointSelector.appendChild(option);
            });
        }
    }
}




function populateUnitSelectorForSeries(seriesId) {
    const unitSelector = document.getElementById(`unitSelector-${seriesId}`);
    if (!unitSelector) return;

    const currentValue = unitSelector.value; // Preserve current selection
    const isFirstSeries = activeSeries.find(s => s.id == seriesId).index === 0;

    unitSelector.innerHTML = `<option value="">${isFirstSeries ? 'Select Unit...' : 'Select Unit (Optional)...'}</option>`;

    if (monitoredPoints.length === 0) {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No monitored points available';
        option.disabled = true;
        unitSelector.appendChild(option);
        return;
    }

    const uniqueUnits = [...new Set(
        monitoredPoints.map(point => point.unit)
    )].filter(unit => unit).sort();

    uniqueUnits.forEach(unit => {
        const option = document.createElement('option');
        option.value = unit;
        option.textContent = unit;
        if (unit === currentValue) {
            option.selected = true;
        }
        unitSelector.appendChild(option);
    });
}


function updateSeriesData(seriesId) {
    const series = activeSeries.find(s => s.id == seriesId);
    if (!series) return;
    
    const unitSelector = document.getElementById(`unitSelector-${seriesId}`);
    const pointSelector = document.getElementById(`pointSelector-${seriesId}`);
    
    if (unitSelector && pointSelector) {
        series.unit = unitSelector.value;
        series.point = pointSelector.value;
    }
}


function createSeriesControls(series) {
    const seriesDiv = document.createElement('div');
    seriesDiv.className = 'series-controls';
    seriesDiv.id = `series-${series.id}`;
    seriesDiv.style.cssText = `
        flex: 1;
        border: 2px solid ${series.color};
        border-radius: 8px;
        padding: 15px;
        margin: 5px;
        background: rgba(255, 255, 255, 0.05);
        position: relative;
    `;
    
    const isFirstSeries = series.index === 0;
    const seriesTitle = isFirstSeries ? 'Primary Series' : `Series ${series.index + 1}`;
    const unitPlaceholder = isFirstSeries ? 'Select Unit...' : 'Select Unit (Optional)...';
    const pointPlaceholder = isFirstSeries ? 'Select Point...' : 'Select Point (Optional)...';
    
    seriesDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0; color: ${series.color};">${seriesTitle}</h4>
            ${!isFirstSeries ? `<button onclick="removeSeries('${series.id}')" style="
                background: #e74c3c;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 4px 8px;
                cursor: pointer;
                font-size: 12px;
            ">Remove</button>` : ''}
        </div>
        <div class="control-row" style="display: flex; gap: 10px;">
            <div class="control-group" style="flex: 1;">
                <label class="control-label">Unit:</label>
                <select id="unitSelector-${series.id}" onchange="updatePointSelector('${series.id}'); updateSeriesData('${series.id}'); updateGraph()">
                    <option value="">${unitPlaceholder}</option>
                </select>
            </div>
            <div class="control-group" style="flex: 1;">
                <label class="control-label">Point:</label>
                <select id="pointSelector-${series.id}" onchange="updateSeriesData('${series.id}'); updateGraph()">
                    <option value="">${pointPlaceholder}</option>
                </select>
            </div>
        </div>
    `;
    
    return seriesDiv;
}
        function toggleSeries(seriesId) {
            const series = activeSeries.find(s => s.id == seriesId);
            const checkbox = document.getElementById(`seriesEnabled-${seriesId}`);
            const statusDiv = document.getElementById(`historyStatus-${seriesId}`);
            
            if (!series || !checkbox || !statusDiv) return;
            
            series.enabled = checkbox.checked;
            
            if (series.enabled) {
                statusDiv.textContent = 'Discovering history...';
                statusDiv.style.color = '#3498db';
                discoverSeriesHistory(series.id);
            } else {
                statusDiv.textContent = 'Enable series to discover history';
                statusDiv.style.color = '#666';
                series.historyOrd = null;
            }
            
            updateGraph();
        }

        async function discoverSeriesHistory(seriesId) {
            const series = activeSeries.find(s => s.id == seriesId);
            const statusDiv = document.getElementById(`historyStatus-${seriesId}`);
            
            if (!series || !statusDiv) return;
            
            try {
                const historyOrd = await discoverHistoryOrd(series.pointData.fullPath);
                
                if (historyOrd) {
                    series.historyOrd = historyOrd;
                    statusDiv.textContent = `✓ History discovered: ${series.pointData.pointName}`;
                    statusDiv.style.color = '#27ae60';
                    
                    console.log(`History discovered for ${series.pointData.displayName}:`, historyOrd);
                } else {
                    throw new Error('No history found');
                }
                
            } catch (error) {
                console.error(`Error discovering history for ${series.pointData.displayName}:`, error);
                statusDiv.textContent = `✗ No history available`;
                statusDiv.style.color = '#e74c3c';
                series.historyOrd = null;
            }
        }


function toggleGraphViewer() {
    const graphViewer = document.getElementById('graphViewer');
    const mainView = document.getElementById('mainView');
    
    graphViewerActive = !graphViewerActive;

    if (graphViewerActive) {
        graphViewer.classList.add('active');
        mainView.classList.add('hidden');
        // Add a delay to ensure the viewer is fully visible before initializing
        setTimeout(() => {
            initializeGraphViewer();
        }, 50);
    } else {
        graphViewer.classList.remove('active');
        mainView.classList.remove('hidden');
    }
}

        function initializeGraphViewer() {
    initializeDateInput();
    initializeSeriesContainer();
    
    // Force canvas resize after a short delay to ensure proper dimensions
    setTimeout(() => {
        resizeCanvas();
        clearGraph();
    }, 100);
}

function resizeCanvas() {
    const canvas = document.getElementById('graphCanvas');
    if (!canvas) return;
    
    // Get the container dimensions
    const container = canvas.parentElement;
    const containerRect = container.getBoundingClientRect();
    
    // Set canvas size to match container
    canvas.width = containerRect.width - 40; // Account for container padding
    canvas.height = 450; // Fixed height as defined in CSS
    
    // Also set CSS dimensions to prevent scaling issues
    canvas.style.width = canvas.width + 'px';
    canvas.style.height = canvas.height + 'px';
    
    console.log(`Canvas resized to: ${canvas.width}x${canvas.height}`);
}

        function initializeDateInput() {
            const dateInput = document.getElementById('dateInput');
            if (dateInput) {
                const today = new Date().toISOString().split('T')[0];
                dateInput.value = today;
            }
        }

        function getSelectedDate() {
            const dateInput = document.getElementById('dateInput');
            if (!dateInput || !dateInput.value) return null;
            
            const selectedDate = new Date(dateInput.value + 'T00:00:00.000');
            const startOfDay = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate(), 0, 0, 0, 0);
            const endOfDay = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate(), 23, 59, 59, 999);
            
            return {
                dateObject: selectedDate,
                dateString: dateInput.value,
                startOfDay: startOfDay,
                endOfDay: endOfDay
            };
        }




async function updateGraph() {
    console.log('updateGraph called');
    
    const timeRangeSelector = document.getElementById('timeRangeSelector');
    const timeRange = timeRangeSelector ? timeRangeSelector.value : 'all';
    
    // Get series with selected unit/point combinations
    const validSeries = activeSeries.filter(series => 
        series.unit && series.point
    );
    
    console.log('Valid series for graphing:', validSeries);
    
    if (validSeries.length === 0) {
        clearGraph();
        return;
    }

    const selectedDate = getSelectedDate();
    if (!selectedDate) {
        clearGraph();
        return;
    }

    // Show loading
    showGraphLoading(true);
    
    // Load data for all valid series
    const allSeriesData = [];
    
    try {
        for (const series of validSeries) {
            // Find the monitored point that matches this series selection
            const matchedPoint = monitoredPoints.find(point => 
                point.unit === series.unit && point.pointName === series.point
            );
            
            if (!matchedPoint) {
                console.warn(`No monitored point found for ${series.unit}.${series.point}`);
                continue;
            }
            
            console.log(`Loading data for ${series.unit}.${series.point}`, matchedPoint);
            
            let startTime = selectedDate.startOfDay;
            let endTime = selectedDate.endOfDay;
            
            // Apply time range filter
            if (timeRange !== 'all' && !isNaN(parseInt(timeRange))) {
                const minutesBack = parseInt(timeRange);
                const cutoffTime = new Date(endTime.getTime() - (minutesBack * 60 * 1000));
                if (cutoffTime > startTime) {
                    startTime = cutoffTime;
                }
            }
            
            const seriesData = await loadNumericalHistoryData(matchedPoint.fullPath, startTime, endTime, 1000);
            
            if (seriesData.length > 0) {
                // Add series metadata
                const enrichedData = seriesData.map(point => ({
                    ...point,
                    pointName: series.point,
                    dataUnit: extractDataUnit(series.point),
                    seriesIndex: series.index
                }));
                
                allSeriesData.push({
                    series: series,
                    data: enrichedData
                });
                
                console.log(`Loaded ${seriesData.length} points for ${series.unit}.${series.point}`);
            } else {
                console.warn(`No history data found for ${series.unit}.${series.point}`);
            }
        }
        
        if (allSeriesData.length === 0) {
            const noDataMessage = document.getElementById('noDataMessage');
            if (noDataMessage) {
                noDataMessage.textContent = 'No data available for selected date range and points';
                noDataMessage.style.display = 'block';
            }
            return;
        }
        
        // Draw the graph
        drawMultiSeriesGraph(allSeriesData, timeRange);
        
    } catch (error) {
        console.error('Error loading graph data:', error);
        showGraphError(`Failed to load data: ${error.message}`);
    } finally {
        showGraphLoading(false);
    }
}

        function drawMultiSeriesGraph(allSeriesData, timeRange) {
    const canvas = document.getElementById('graphCanvas');
    const noDataMessage = document.getElementById('noDataMessage');
    
    if (!canvas) return;

    // Ensure canvas is properly sized
    if (canvas.width === 0 || canvas.height === 0) {
        resizeCanvas();
    }

    const selectedDate = getSelectedDate();
    if (!selectedDate) {
        clearGraph();
        return;
    }

    const ctx = canvas.getContext('2d');
    
    // Rest of your existing drawMultiSeriesGraph code stays the same...
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            // Clear previous data points array
            graphDataPoints = [];

            noDataMessage.style.display = 'none';
            canvas.style.display = 'block';

            // Calculate combined value range for Y-axis
            const allValues = [];
            allSeriesData.forEach(seriesData => {
                allValues.push(...seriesData.data.map(d => d.value));
            });
            
            const minValue = Math.min(...allValues);
            const maxValue = Math.max(...allValues);
            const valueRange = maxValue - minValue;
            const valuePadding = valueRange * 0.1;
            const adjustedMin = minValue - valuePadding;
            const adjustedMax = maxValue + valuePadding;

            // Draw graph background and axes
            drawGraphAxes(ctx, canvas.width, canvas.height, adjustedMin, adjustedMax, selectedDate);

            // Draw all series
            const startTimeMs = selectedDate.startOfDay.getTime();
            const timeRangeMs = selectedDate.endOfDay.getTime() - startTimeMs;
            const padding = 60;
            const graphWidth = canvas.width - (padding * 2);
            const graphHeight = canvas.height - (padding * 2);

            allSeriesData.forEach(({ series, data }) => {
                if (data.length === 0) return;
                
                // Draw line
                ctx.strokeStyle = series.color;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                
                for (let i = 0; i < data.length; i++) {
                    const entry = data[i];
                    const x = padding + (graphWidth * (entry.timestamp.getTime() - startTimeMs) / timeRangeMs);
                    const normalizedValue = (entry.value - adjustedMin) / (adjustedMax - adjustedMin);
                    const y = padding + graphHeight - (graphHeight * normalizedValue);

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();

                // Draw data points and store for click detection
                data.forEach((entry, dataIndex) => {
                    const x = padding + (graphWidth * (entry.timestamp.getTime() - startTimeMs) / timeRangeMs);
                    const normalizedValue = (entry.value - adjustedMin) / (adjustedMax - adjustedMin);
                    const y = padding + graphHeight - (graphHeight * normalizedValue);
                    
                    // Store point data for click detection
                    graphDataPoints.push({
                        x: x,
                        y: y,
                        radius: 6,
                        data: entry,
                        index: dataIndex,
                        series: series.index + 1,
                        seriesName: series.label,
                        seriesColor: series.color,
                        seriesId: series.id
                    });
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fillStyle = series.color;
                    ctx.fill();
                    
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            });

            // Add click event listener (only once)
            if (canvas && !canvas.hasClickListener) {
                canvas.hasClickListener = true;
                canvas.addEventListener('click', handleGraphClick);
                canvas.style.cursor = 'pointer';
            }

            // Update legend and stats
            updateGraphLegend(allSeriesData);
            updateGraphStats(allSeriesData);
        }

        function drawGraphAxes(ctx, width, height, adjustedMin, adjustedMax, selectedDate) {
            const padding = 60;
            const graphWidth = width - (padding * 2);
            const graphHeight = height - (padding * 2);

            ctx.clearRect(0, 0, width, height);

            // Background
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-bg') || '#ffffff';
            ctx.fillRect(0, 0, width, height);

            // Grid
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border-color') || '#ddd';
            ctx.lineWidth = 0.5;
            ctx.setLineDash([2, 2]);

            for (let i = 0; i <= 10; i++) {
                const x = padding + (graphWidth * i / 10);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, padding + graphHeight);
                ctx.stroke();
            }

            for (let i = 0; i <= 8; i++) {
                const y = padding + (graphHeight * i / 8);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + graphWidth, y);
                ctx.stroke();
            }

            ctx.setLineDash([]);

            // Axes
            const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color') || '#000000';
            ctx.strokeStyle = textColor;
            ctx.lineWidth = 2;
            ctx.font = '12px Segoe UI, sans-serif';
            ctx.fillStyle = textColor;

            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + graphHeight);
            ctx.lineTo(padding + graphWidth, padding + graphHeight);
            ctx.stroke();

            // Y-axis labels
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            for (let i = 0; i <= 8; i++) {
                const value = adjustedMin + (adjustedMax - adjustedMin) * (1 - i / 8);
                const y = padding + (graphHeight * i / 8);
                ctx.fillText(value.toFixed(1), padding - 10, y);
            }

            // X-axis labels
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            const startTime = selectedDate.startOfDay;
            const timeLabels = [
                new Date(startTime.getTime()),
                new Date(startTime.getTime() + 4 * 60 * 60 * 1000),
                new Date(startTime.getTime() + 8 * 60 * 60 * 1000),
                new Date(startTime.getTime() + 12 * 60 * 60 * 1000),
                new Date(startTime.getTime() + 16 * 60 * 60 * 1000),
                new Date(startTime.getTime() + 20 * 60 * 60 * 1000),
                new Date(selectedDate.endOfDay.getTime())
            ];
            
            timeLabels.forEach((timePoint, i) => {
                const x = padding + (graphWidth * i / 6);
                const timeStr = timePoint.toLocaleTimeString('en-US', { 
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                });
                ctx.fillText(timeStr, x, padding + graphHeight + 10);
            });

            // Axis titles
            ctx.font = 'bold 14px Segoe UI, sans-serif';
            ctx.save();
            ctx.translate(20, padding + graphHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Value', 0, 0);
            ctx.restore();
            
            ctx.fillText('Time', padding + graphWidth / 2, padding + graphHeight + 35);
        }

        function handleGraphClick(event) {
            if (!graphDataPoints) return;
            
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Check if click is near any data point
            for (let i = 0; i < graphDataPoints.length; i++) {
                const point = graphDataPoints[i];
                const distance = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
                
                if (distance <= point.radius) {
                    showDataPointTooltip(point, event.clientX, event.clientY);
                    return;
                }
            }
            
            hideDataPointTooltip();
        }

        function showDataPointTooltip(pointData, screenX, screenY) {
            hideDataPointTooltip();
            
            const tooltip = document.createElement('div');
            tooltip.id = 'dataPointTooltip';
            tooltip.style.cssText = `
                position: fixed;
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 12px 16px;
                border-radius: 8px;
                font-family: 'Segoe UI', sans-serif;
                font-size: 13px;
                z-index: 10001;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                border: 2px solid ${pointData.seriesColor};
                max-width: 280px;
                pointer-events: none;
            `;
            
            const timeStr = pointData.data.timestamp.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
            });
            
            tooltip.innerHTML = `
                <div style="font-weight: bold; color: ${pointData.seriesColor}; margin-bottom: 6px;">
                    ${pointData.seriesName}
                </div>
                <div style="margin-bottom: 4px;">
                    <strong>Value:</strong> ${pointData.data.value} ${pointData.data.dataUnit || ''}
                </div>
                <div style="margin-bottom: 4px;">
                    <strong>Time:</strong> ${timeStr}
                </div>
                <div style="margin-bottom: 4px;">
                    <strong>Point:</strong> ${pointData.data.pointName}
                </div>
                <div style="font-size: 11px; color: #bbb; margin-top: 8px;">
                    Click elsewhere to close
                </div>
            `;
            
            document.body.appendChild(tooltip);
            
            // Position tooltip
            const tooltipRect = tooltip.getBoundingClientRect();
            let left = screenX + 15;
            let top = screenY - 15;
            
            if (left + tooltipRect.width > window.innerWidth) {
                left = screenX - tooltipRect.width - 15;
            }
            
            if (top < 0) {
                top = screenY + 15;
            }
            
            if (top + tooltipRect.height > window.innerHeight) {
                top = window.innerHeight - tooltipRect.height - 10;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            
            setTimeout(() => {
                hideDataPointTooltip();
            }, 8000);
        }

        function hideDataPointTooltip() {
            const existingTooltip = document.getElementById('dataPointTooltip');
            if (existingTooltip) {
                existingTooltip.remove();
            }
        }


        
        function updateGraphLegend(allSeriesData) {
    const graphLegend = document.getElementById('graphLegend');
    if (!graphLegend) return;

    let legendHtml = '';
    
    allSeriesData.forEach(({ series, data }) => {
        if (data.length > 0) {
            const displayName = `${series.unit} - ${series.point}`;
            legendHtml += `
                <div class="legend-item">
                    <span class="legend-color" style="background-color: ${series.color};"></span>
                    <span class="legend-text">${displayName}</span>
                </div>
            `;
        }
    });
    
    graphLegend.innerHTML = legendHtml;
}

        function updateGraphStats(allSeriesData) {
            const graphStats = document.getElementById('graphStats');
            if (!graphStats) return;

            let statsHtml = '';
            
            allSeriesData.forEach(({ series, data }) => {
                if (data.length > 0) {
                    const values = data.map(d => d.value);
                    const avg = values.reduce((sum, val) => sum + val, 0) / values.length;
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    const current = values[values.length - 1];
                    const unit = data[0].dataUnit || '';
                    
                    statsHtml += `
                        <div class="stat-group" style="border-left: 4px solid ${series.color}; padding-left: 10px; margin-bottom: 15px;">
                            <div style="font-weight: bold; color: ${series.color}; margin-bottom: 8px;">${series.label}</div>
                            <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                                <div class="stat-card" style="min-width: 80px;">
                                    <div class="stat-value" style="color: ${series.color};">${data.length}</div>
                                    <div class="stat-label">Points</div>
                                </div>
                                <div class="stat-card" style="min-width: 80px;">
                                    <div class="stat-value" style="color: ${series.color};">${avg.toFixed(2)} ${unit}</div>
                                    <div class="stat-label">Average</div>
                                </div>
                                <div class="stat-card" style="min-width: 80px;">
                                    <div class="stat-value" style="color: ${series.color};">${current.toFixed(2)} ${unit}</div>
                                    <div class="stat-label">Current</div>
                                </div>
                                <div class="stat-card" style="min-width: 80px;">
                                    <div class="stat-value" style="color: ${series.color};">${min.toFixed(2)} - ${max.toFixed(2)} ${unit}</div>
                                    <div class="stat-label">Range</div>
                                </div>
                            </div>
                        </div>
                    `;
                }
            });
            
            graphStats.innerHTML = statsHtml;
        }

function showGraphLoading(show) {
    const canvas = document.getElementById('graphCanvas');
    const noDataMessage = document.getElementById('noDataMessage');

    if (show) {
        // Hide the canvas while loading
        if (canvas) {
            canvas.style.display = 'none';
        }

        // Show the loading message
        if (noDataMessage) {
            noDataMessage.textContent = 'Loading data from Niagara histories...';
            noDataMessage.style.display = 'block';
            noDataMessage.style.color = '#3498db';
        }
    } else {
        // Hide the loading message
        if (noDataMessage && noDataMessage.textContent.includes('Loading')) {
            noDataMessage.style.display = 'none';
        }

        // Force the canvas to redraw and show the graph
        if (canvas) {
            // Trick to force refresh: temporarily hide and show
            canvas.style.display = 'none';
            void canvas.offsetWidth; // Force reflow
            canvas.style.display = 'block';
        }
    }
}

        function showGraphError(message) {
            const canvas = document.getElementById('graphCanvas');
            const noDataMessage = document.getElementById('noDataMessage');
            
            if (canvas) canvas.style.display = 'none';
            if (noDataMessage) {
                noDataMessage.textContent = `Error: ${message}`;
                noDataMessage.style.display = 'block';
                noDataMessage.style.color = '#e74c3c';
            }
        }

        function clearGraph() {
            const canvas = document.getElementById('graphCanvas');
            const noDataMessage = document.getElementById('noDataMessage');
            const graphLegend = document.getElementById('graphLegend');
            const graphStats = document.getElementById('graphStats');
            
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                canvas.style.display = 'none';
            }
            
            if (noDataMessage) {
                noDataMessage.textContent = 'Enable series to view numerical graph data.';
                noDataMessage.style.display = 'block';
                noDataMessage.style.color = '#666';
            }
            
            if (graphLegend) graphLegend.innerHTML = '';
            if (graphStats) graphStats.innerHTML = '';
            
            graphDataPoints = [];
            hideDataPointTooltip();
        }

        function forceRefreshGraph() {
            updateGraph();
        }

        // Data collection functions (simplified)
        async function collectAllData() {
            if (!monitoringActive || monitoredPoints.length === 0) return;
            
            console.log('Collecting numerical data from configured points...');
            lastCollectionTime = new Date();
            
            let successCount = 0;
            let errorCount = 0;
            
            for (const point of monitoredPoints) {
                try {
                    const value = await readActualPointValue(point);
                    
                    if (value !== null && value !== undefined) {
                        const numericValue = typeof value === 'number' ? value : parseFloat(value);
                        
                        if (!isNaN(numericValue)) {
                            addNumericalDataPoint(point, numericValue);
                            successCount++;
                        } else {
                            console.warn(`Non-numeric value for ${point.unit}.${point.pointName}: ${value}`);
                            errorCount++;
                        }
                    } else {
                        console.warn(`Null value for ${point.unit}.${point.pointName}`);
                        errorCount++;
                    }
                } catch (error) {
                    console.error(`Error reading point ${point.unit}.${point.pointName}:`, error);
                    errorCount++;
                }
            }
            
            updateEventLogs();
            saveDataToFile();
            
            const message = `Collected ${successCount} points${errorCount > 0 ? `, ${errorCount} errors` : ''}`;
            showNotification('Data Collection Complete', message, successCount > 0 ? 'success' : 'warning');
        }

        async function readActualPointValue(point) {
            return new Promise((resolve, reject) => {
                try {
                    if (typeof require === 'undefined') {
                        console.error('Baja require system not available. This script must run within a Niagara station environment.');
                        resolve(Math.random() * 100); // Demo value for testing outside Niagara
                        return;
                    }
                    
                    require(['baja!'], function (baja) {
                        'use strict';
                        
                        const pointPath = point.fullPath;
                        console.log(`Reading point: ${pointPath}`);
                        
                        baja.Ord.make(pointPath).get()
                            .then(function(pointEntity) {
                                if (pointEntity && pointEntity.getOut) {
                                    const value = pointEntity.getOut().getValue();
                                    console.log(`Point ${pointPath} value: ${value}`);
                                    resolve(value);
                                } else {
                                    console.warn(`Point ${pointPath} has no output value`);
                                    resolve(null);
                                }
                            })
                            .catch(function(error) {
                                console.error(`Error reading point ${pointPath}:`, error);
                                reject(error);
                            });
                    });
                } catch (error) {
                    console.error(`Baja require error for point ${point.fullPath}:`, error);
                    reject(error);
                }
            });
        }

        function addNumericalDataPoint(point, value) {
            const timestamp = new Date().toLocaleString();
            logCounter++;
            
            const roundedValue = (typeof value === 'number' && !isNaN(value)) 
                ? Number(value.toFixed(2)) 
                : value;
            
            let dataUnit = extractDataUnit(point.id || point.pointName);
            
            const logEntry = {
                id: logCounter,
                timestamp: timestamp,
                timestampObj: new Date(),
                unit: point.unit,
                pointName: point.pointName,
                pointId: point.id,
                value: roundedValue,
                dataUnit: dataUnit,
                fullPath: point.fullPath,
                displayName: `${point.unit} - ${point.pointName}`,
                details: `${point.pointName} = ${roundedValue} ${dataUnit}`
            };
            
            eventLogs.unshift(logEntry);
            
            if (eventLogs.length > 5000) {
                eventLogs = eventLogs.slice(0, 5000);
            }
        }

        async function saveDataToFile() {
            try {
                const exportData = {
                    metadata: {
                        saveTimestamp: new Date().toISOString(),
                        totalLogs: eventLogs.length,
                        monitoredPointsCount: monitoredPoints.length
                    },
                    eventLogs: eventLogs,
                    systemConfig: {
                        monitoringActive: monitoringActive,
                        logCounter: logCounter,
                        startTime: startTime.toISOString(),
                        lastCollectionTime: lastCollectionTime ? lastCollectionTime.toISOString() : null
                    },
                    monitoredPoints: monitoredPoints
                };

                console.log('Data would be saved to numerical_data.json:', exportData);
                
            } catch (error) {
                console.error('Save to file failed:', error);
            }
        }

        function updateEventLogs() {
            const logsContainer = document.getElementById('eventLogs');
            const recentLogs = eventLogs.slice(0, 5);
            
            logsContainer.innerHTML = '';
            
            if (recentLogs.length === 0) {
                logsContainer.innerHTML = `
                    <div class="bubbleSP">
                        <div class="status-display">
                            <div class="status-title">No numerical data recorded yet</div>
                            <div class="status-details">
                                <p>System collects data from ${monitoredPoints.length} configured points every 15 minutes</p>
                                <p>Click "Collect Now" for immediate data collection</p>
                            </div>
                        </div>
                    </div>
                `;
                return;
            }
            
            recentLogs.forEach(log => {
                const logElement = document.createElement('div');
                logElement.className = 'bubbleSP';
                
                let statusClass = 'status-ok';
                let statusIcon = '📊';
                
                if (log.value === null || log.value === undefined) {
                    statusClass = 'status-error';
                    statusIcon = '❌';
                } else if (log.value < 0) {
                    statusClass = 'status-warning';
                    statusIcon = '⚠️';
                }
                
                logElement.innerHTML = `
                    <div class="status-display ${statusClass}">
                        <div class="status-title">${statusIcon} ${log.displayName} - ${log.value} ${log.dataUnit}</div>
                        <div class="status-details">
                            <p><strong>Timestamp:</strong> ${log.timestamp}</p>
                            <p><strong>Value:</strong> ${log.value} ${log.dataUnit}</p>
                            <p><strong>Unit:</strong> ${log.unit}</p>
                            <p><strong>Point:</strong> ${log.pointName}</p>
                            <p><strong>Full Path:</strong> ${log.fullPath}</p>
                        </div>
                    </div>
                `;
                logsContainer.appendChild(logElement);
            });
            
            updateOverallStatus();
        }

        function updateOverallStatus() {
            const statusElement = document.getElementById('system-status');
            
            let summaryElement = document.getElementById('overall-summary');
            if (!summaryElement) {
                summaryElement = document.createElement('div');
                summaryElement.id = 'overall-summary';
                summaryElement.className = 'overall-summary';
                statusElement.appendChild(summaryElement);
            }
            
            const activePoints = monitoredPoints.length;
            const totalLogs = eventLogs.length;
            
            const overallClass = activePoints > 0 ? 'status-ok' : 'status-error';
            const overallTitle = `📊 ${activePoints} POINTS MONITORED`;
            const monitoringStatusText = monitoringActive ? '🟢 ACTIVE (15min intervals)' : '🔴 STOPPED';
            
            summaryElement.className = `overall-summary status-display ${overallClass}`;
            summaryElement.innerHTML = `
                <div class="status-title">${overallTitle}</div>
                <div class="status-details">
                    <p><strong>Monitoring Status:</strong> ${monitoringStatusText}</p>
                    <p><strong>Configured Points:</strong> ${activePoints} numerical points</p>
                    <p><strong>Total Logged Entries:</strong> ${totalLogs}</p>
                    <p><strong>Last Collection:</strong> ${lastCollectionTime ? lastCollectionTime.toLocaleString() : 'Never'}</p>
                    <p><strong>Config Status:</strong> ${globalConfig ? 'Loaded' : 'Not Loaded'}</p>
                </div>
            `;
        }

        // Control functions
        function startMonitoring() {
            if (!globalConfig) {
                showNotification('Configuration Required', 'Please load Global.json first', 'error');
                return;
            }
            
            if (monitoredPoints.length === 0) {
                showNotification('No Points Configured', 'No numerical points found in configuration', 'warning');
                return;
            }
            
            monitoringActive = true;
            updateMonitoringStatus();
            collectAllData();
            showNotification('Monitoring Started', `Monitoring ${monitoredPoints.length} numerical points`, 'success');
        }

        function stopMonitoring() {
            monitoringActive = false;
            updateMonitoringStatus();
            showNotification('Monitoring Stopped', 'Numerical monitoring has been paused', 'warning');
        }

        function collectDataNow() {
            if (!monitoringActive) {
                showNotification('Monitoring Inactive', 'Please start monitoring first', 'error');
                return;
            }
            
            if (monitoredPoints.length === 0) {
                showNotification('No Points Configured', 'No numerical points to collect', 'warning');
                return;
            }
            
            collectAllData();
        }

        function exportLogs() {
            if (eventLogs.length === 0) {
                showNotification('No Data', 'No logs to export', 'warning');
                return;
            }

            const headers = ['ID', 'Timestamp', 'Unit', 'Point Name', 'Value', 'Full Path'];

            const sortedLogs = [...eventLogs].sort((a, b) => {
                if (a.unit !== b.unit) return a.unit.localeCompare(b.unit);
                if (a.pointName !== b.pointName) return a.pointName.localeCompare(b.pointName);
                return new Date(a.timestampObj) - new Date(b.timestampObj);
            });

            const csvRows = [headers.join(',')];
            let lastUnit = null;

            sortedLogs.forEach(log => {
                if (lastUnit !== null && log.unit !== lastUnit) {
                    csvRows.push('');
                }

                csvRows.push([
                    log.id,
                    `"${log.timestamp}"`,
                    `"${log.unit}"`,
                    `"${log.pointName}"`,
                    log.value,
                    `"${log.fullPath}"`,
                ].join(','));

                lastUnit = log.unit;
            });

            const csvContent = csvRows.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `niagara_numerical_logs_${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('Export Complete', `Exported ${eventLogs.length} log entries`, 'success');
        }

        function saveData() {
            try {
                const saveData = {
                    eventLogs: eventLogs,
                    logCounter: logCounter,
                    monitoringActive: monitoringActive,
                    timestamp: new Date().toISOString(),
                    monitoredPoints: monitoredPoints
                };
                
                console.log('Data saved:', saveData);
                console.log('Auto-save completed');
            } catch (error) {
                console.error('Save failed:', error);
            }
        }

        function clearLogs() {
            if (confirm('Are you sure you want to clear all numerical logs? This cannot be undone.')) {
                eventLogs = [];
                logCounter = 0;
                updateEventLogs();
                showNotification('Logs Cleared', 'All numerical data has been cleared', 'info');
            }
        }

        function showNotification(title, message, type = 'info') {
            const notification = document.createElement('div');
            const colors = {
                success: '#27ae60',
                error: '#e74c3c',
                info: '#3498db',
                warning: '#f39c12'
            };
            
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${colors[type] || colors.info};
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 10000;
                max-width: 300px;
                font-family: 'Segoe UI', sans-serif;
                font-size: 14px;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
            `;
            
            notification.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 5px;">${title}</div>
                <div>${message}</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 5000);
        }

        // Dark mode toggle
        function initializeDarkMode() {
            const toggleSwitch = document.getElementById('toggleSwitch');
            const toggleLabel = document.querySelector('.toggle-label');
            
            const currentTheme = 'light';
            document.documentElement.setAttribute('data-theme', currentTheme);
            
            toggleLabel.textContent = 'Light Mode';
            
            toggleSwitch.addEventListener('click', function() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                document.documentElement.setAttribute('data-theme', newTheme);
                
                if (newTheme === 'dark') {
                    toggleSwitch.classList.add('active');
                    toggleLabel.textContent = 'Dark Mode';
                } else {
                    toggleSwitch.classList.remove('active');
                    toggleLabel.textContent = 'Light Mode';
                }
                
                if (graphViewerActive) {
                    updateGraph();
                }
            });
        }

        // Add click handler to document to hide tooltip when clicking elsewhere
        document.addEventListener('click', function(event) {
            const canvas = document.getElementById('graphCanvas');
            if (event.target !== canvas) {
                hideDataPointTooltip();
            }
        });

        // Initialize everything when DOM loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeSystem();
            initializeDarkMode();
            
            console.log('Niagara Numerical System Monitor ready!');
            console.log('Features: Auto-discovery from Global.json, BQL history queries, real-time graphing');
        });

   
        
        // Resize handling
window.addEventListener('resize', function() {
    if (graphViewerActive) {
        resizeCanvas();
        setTimeout(updateGraph, 100);
    }
});


    </script>
</body>
</html>