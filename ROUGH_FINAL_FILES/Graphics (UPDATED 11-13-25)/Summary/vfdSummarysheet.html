<!DOCTYPE html>
<!-- @noSnoop -->
<html lang="en" xmlns:b="http://www.tridium.com/baja/baja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Murphy Control Panel - VFD Monitoring</title>

    <!-- Add RequireJS and BajaScript Support -->
    <script type='text/javascript' src='/requirejs/config.js'></script>
    <script type='text/javascript' src='/module/js/com/tridium/js/ext/require/require.min.js?'></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0d1421 0%, #1a1f3a 50%, #0f2027 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: linear-gradient(145deg, rgba(13, 20, 33, 0.95), rgba(26, 31, 58, 0.9));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(64, 224, 208, 0.2);
            border-radius: 16px;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.4),
                0 0 20px rgba(64, 224, 208, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #1e3a8a, #312e81, #1e40af);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header h1 {
            margin: 0;
            font-size: 24px;
            position: relative;
            z-index: 1;
            text-shadow: 0 0 15px rgba(64, 224, 208, 0.3);
        }

        .chart-section {
            padding: 30px;
            margin: 20px;
            background: rgba(13, 20, 33, 0.6);
            border-radius: 12px;
            border: 1px solid rgba(64, 224, 208, 0.2);
        }

        /* New layout: two separate chart containers side-by-side */
        .charts-row {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
            flex-wrap: wrap;
        }

        .single-chart {
            background: rgba(15, 24, 35, 0.6);
            border-radius: 10px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 48%;
            min-width: 300px;
            box-sizing: border-box;
            border: 1px solid rgba(64, 224, 208, 0.08);
        }

        .single-chart .chart-title {
            text-align: center;
            color: #40e0d0;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 12px;
            text-shadow: 0 0 8px rgba(64, 224, 208, 0.4);
        }

        .single-chart .chart-body {
            display: flex;
            gap: 12px;
            align-items: center;
            width: 100%;
            justify-content: center;
        }

        .single-chart canvas {
            background: transparent;
            border-radius: 6px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.4);
        }

        .chart-legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
            width: 220px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 10px;
            background: rgba(26, 31, 58, 0.5);
            border-radius: 6px;
            border: 1px solid rgba(64, 224, 208, 0.08);
            cursor: pointer;
            transition: transform .15s ease, background .15s ease;
        }

        .legend-item:hover { transform: translateX(4px); background: rgba(30,58,138,0.22); }

        .legend-color { width: 18px; height: 18px; border-radius: 4px; flex-shrink: 0; }
        .legend-text { color: #b0bec5; font-size: 13px; white-space: nowrap; }
        .legend-value { color: #40e0d0; font-weight: bold; margin-left: auto; font-size: 13px; }

        /* existing table and value styles preserved below */
        .vav-table { width: 100%; border-collapse: collapse; font-size: 14px; background: transparent; }
        .vav-table th { background: linear-gradient(135deg, #1e3a8a, #312e81, #1e40af); color: #e0f7fa; padding: 12px 8px; text-align: center; font-weight: bold; border-right: 1px solid rgba(64, 224, 208, 0.3); text-shadow: 0 0 8px rgba(64, 224, 208, 0.4); position: relative; }
        .vav-table td { padding: 10px 8px; text-align: center; border-bottom: 1px solid rgba(64, 224, 208, 0.15); border-right: 1px solid rgba(64, 224, 208, 0.15); background: rgba(13, 20, 33, 0.6); color: #b0bec5; transition: all 0.3s ease; }
        .vav-table tr:nth-child(even) td { background: rgba(26, 31, 58, 0.4); }
        .vav-name { font-weight: bold; color: #40e0d0; text-shadow: 0 0 10px rgba(64, 224, 208, 0.5); }
        .value-loading { color: #7c3aed; font-style: italic; animation: pulse 2s ease-in-out infinite; }
        @keyframes pulse { 0%,100%{opacity:.6}50%{opacity:1} }
        .value-error { color: #f87171; font-style: italic; text-shadow: 0 0 5px rgba(248, 113, 113, 0.5); }
        .value-normal { color: #67e8f9; font-weight: 500; text-shadow: 0 0 8px rgba(103, 232, 249, 0.3); }
        .value-active { color: #34d399; font-weight: bold; text-shadow: 0 0 10px rgba(52, 211, 153, 0.5); animation: glow-green 2s ease-in-out infinite alternate; }
        @keyframes glow-green { from { text-shadow: 0 0 10px rgba(52, 211, 153, 0.5); } to { text-shadow: 0 0 15px rgba(52, 211, 153, 0.7); } }
        .value-inactive { color: #64748b; text-shadow: 0 0 5px rgba(100, 116, 139, 0.3); }
        .error { background: linear-gradient(135deg, rgba(30, 58, 138, 0.3), rgba(49, 46, 129, 0.2)); color: #f87171; padding: 20px; text-align: center; border-radius: 8px; margin: 20px; border: 1px solid rgba(248, 113, 113, 0.3); backdrop-filter: blur(5px); }
        .loading { text-align: center; padding: 40px; color: #40e0d0; font-size: 16px; text-shadow: 0 0 10px rgba(64, 224, 208, 0.5); }

        /* hyperlink styles */
        .ahu-name a, .vav-name a { color: #007bff; text-decoration: none; }
        .ahu-name a:hover, .vav-name a:hover { color: #0056b3; text-decoration: underline; }
        .ahu-name a:visited, .vav-name a:visited { color: #bdbdbd; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header"><h1>VFD Summary Sheet</h1></div>

        <div id="main-content"><div class="loading">Loading VFD data...</div></div>

        <div class="chart-section">
            <div class="charts-row">
                <!-- Power chart container -->
                <div class="single-chart" id="powerContainer">
                    <div class="chart-title">Power Consumption by VFD (kW)</div>
                    <div class="chart-body">
                        <canvas id="powerChart" width="360" height="360"></canvas>
                        <div class="chart-legend" id="chartLegend"></div>
                    </div>
                </div>

                <!-- Frequency chart container -->
                <div class="single-chart" id="freqContainer">
                    <div class="chart-title">Frequency by VFD (Hz)</div>
                    <div class="chart-body">
                        <canvas id="frequencyChart" width="360" height="360"></canvas>
                        <div class="chart-legend" id="chartLegendFreq"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
    // Global variables
    let pointSubscriptions = [];
    let pointValues = {};
    let allVFDPoints = {};
    let subscriber;
    let chartData = [];
    let chartDataFreq = [];

    // Vibrant color palette
    const colorPalette = [
        '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
        '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384',
        '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40',
        '#E74C3C', '#3498DB', '#F39C12', '#1ABC9C', '#9B59B6'
    ];

    // Custom Pie Chart Drawing Function for power
    function drawPieChart() {
        const canvas = document.getElementById('powerChart');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = Math.min(centerX, centerY) - 18;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const total = chartData.reduce((s, it) => s + it.value, 0);
        if (total === 0) {
            ctx.fillStyle = '#40e0d0'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('No Power Data Available', centerX, centerY); return;
        }

        let currentAngle = -Math.PI / 2;
        chartData.forEach((item) => {
            const sliceAngle = (item.value / total) * 2 * Math.PI;
            ctx.beginPath(); ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
            ctx.closePath(); ctx.fillStyle = item.color; ctx.fill();
            ctx.strokeStyle = '#0d1421'; ctx.lineWidth = 2; ctx.stroke();

            if (sliceAngle > 0.3) {
                const middleAngle = currentAngle + sliceAngle / 2;
                const textX = centerX + (radius * 0.7) * Math.cos(middleAngle);
                const textY = centerY + (radius * 0.7) * Math.sin(middleAngle);
                const percentage = ((item.value / total) * 100).toFixed(1);
                ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0,0,0,0.8)'; ctx.shadowBlur = 4;
                ctx.fillText(percentage + '%', textX, textY); ctx.shadowBlur = 0;
            }

            currentAngle += sliceAngle;
        });
    }

    // Draw frequency pie chart
    function drawFrequencyChart() {
        const canvas = document.getElementById('frequencyChart');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = Math.min(centerX, centerY) - 18;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const total = chartDataFreq.reduce((s, it) => s + it.value, 0);
        if (total === 0) {
            ctx.fillStyle = '#40e0d0'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('No Frequency Data Available', centerX, centerY); return;
        }

        let currentAngle = -Math.PI / 2;
        chartDataFreq.forEach((item) => {
            const sliceAngle = (item.value / total) * 2 * Math.PI;
            ctx.beginPath(); ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
            ctx.closePath(); ctx.fillStyle = item.color; ctx.fill();
            ctx.strokeStyle = '#0d1421'; ctx.lineWidth = 2; ctx.stroke();

            if (sliceAngle > 0.3) {
                const middleAngle = currentAngle + sliceAngle / 2;
                const textX = centerX + (radius * 0.7) * Math.cos(middleAngle);
                const textY = centerY + (radius * 0.7) * Math.sin(middleAngle);
                const percentage = ((item.value / total) * 100).toFixed(1);
                ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0,0,0,0.8)'; ctx.shadowBlur = 4;
                ctx.fillText(percentage + '%', textX, textY); ctx.shadowBlur = 0;
            }

            currentAngle += sliceAngle;
        });
    }

    // Update legends
    function updateLegend() {
        const legendDiv = document.getElementById('chartLegend'); if (!legendDiv) return;
        legendDiv.innerHTML = '';
        const total = chartData.reduce((s, it) => s + it.value, 0);
        chartData.forEach((item) => {
            const percentage = total > 0 ? ((item.value / total) * 100).toFixed(1) : 0;
            const legendItem = document.createElement('div');
            legendItem.className = 'legend-item';
            legendItem.innerHTML = `<div class="legend-color" style="background-color:${item.color}"></div>
                                    <div class="legend-text">${item.label}</div>
                                    <div class="legend-value">${item.value.toFixed(1)} kW (${percentage}%)</div>`;
            legendDiv.appendChild(legendItem);
        });
    }

    function updateLegendFreq() {
        const legendDiv = document.getElementById('chartLegendFreq'); if (!legendDiv) return;
        legendDiv.innerHTML = '';
        const total = chartDataFreq.reduce((s, it) => s + it.value, 0);
        chartDataFreq.forEach((item) => {
            const percentage = total > 0 ? ((item.value / total) * 100).toFixed(1) : 0;
            const legendItem = document.createElement('div');
            legendItem.className = 'legend-item';
            legendItem.innerHTML = `<div class="legend-color" style="background-color:${item.color}"></div>
                                    <div class="legend-text">${item.label}</div>
                                    <div class="legend-value">${item.value.toFixed(1)} Hz (${percentage}%)</div>`;
            legendDiv.appendChild(legendItem);
        });
    }

    // Update charts based on pointValues
    function updatePowerChart() {
        chartData = [];
        const vfdNames = Object.keys(pointValues).sort();
        vfdNames.forEach((vfdName, index) => {
            const powerValue = pointValues[vfdName]?.power;
            if (typeof powerValue === 'number' && powerValue > 0) {
                chartData.push({ label: vfdName, value: powerValue, color: colorPalette[index % colorPalette.length] });
            }
        });
        drawPieChart(); updateLegend();
    }

    function updateFrequencyChart() {
        chartDataFreq = [];
        const vfdNames = Object.keys(pointValues).sort();
        vfdNames.forEach((vfdName, index) => {
            const freqValue = pointValues[vfdName]?.frequency;
            if (typeof freqValue === 'number' && freqValue > 0) {
                chartDataFreq.push({ label: vfdName, value: freqValue, color: colorPalette[index % colorPalette.length] });
            }
        });
        drawFrequencyChart(); updateLegendFreq();
    }

    // Authorization (unchanged)
    function isAuthorizedUser() {
        const username = 'murphy'; console.log('Current user:', username);
        if (!username) { console.log('No user found'); return false; }
        const authorizedUsers = ['murphy', 'admin'];
        const isAuthorized = authorizedUsers.includes(username.toLowerCase());
        console.log('User authorized for point display:', isAuthorized); return isAuthorized;
    }

    if (!isAuthorizedUser()) {
        console.log('Point display script terminated - user not authorized');
        document.getElementById('main-content').innerHTML =
            '<div class="error">Access Denied: You do not have permission to view point data.</div>';
        throw new Error('Unauthorized access');
    }

    // Formatting helpers (unchanged)
    function formatPointValue(value, pointId) {
        if (value === null || value === undefined || value === 'N/A' || value === 'Connection Error') {
            return value === 'Connection Error' ? 'Connection Error' : 'N/A';
        }
        if (typeof value === 'string' && value.startsWith('NO_')) return value;
        if (pointId === 'speed') return Math.round(value) + ' RPM';
        else if (pointId === 'frequency') return value.toFixed(1) + ' Hz';
        else if (pointId === 'torque') return Math.round(value) + '%';
        else if (pointId === 'power') return value.toFixed(1) + ' kW';
        else if (pointId === 'current') return value.toFixed(1) + ' A';
        else if (pointId === 'voltage') return Math.round(value) + ' V';
        else if (typeof value === 'number') return value.toFixed(1);
        return value.toString();
    }

    function getValueClass(value, pointId) {
        if (value === null || value === undefined || value === 'N/A' || value === 'Connection Error') return 'value-error';
        if (typeof value === 'string' && value.startsWith('NO_')) return 'value-missing';
        return 'value-normal';
    }

    function updatePointValue(vfdName, pointId, value) {
        const elementId = `point-${vfdName}-${pointId}`;
        const valueElement = document.getElementById(elementId);
        if (valueElement) {
            const formattedValue = formatPointValue(value, pointId);
            const valueClass = getValueClass(value, pointId);
            valueElement.textContent = formattedValue;
            valueElement.className = valueClass;
            if (!pointValues[vfdName]) pointValues[vfdName] = {};
            pointValues[vfdName][pointId] = value;
            if (pointId === 'power') updatePowerChart();
            if (pointId === 'frequency') updateFrequencyChart();
        } else {
            // still update internal store so charts can use values even if the table cell isn't created yet
            if (!pointValues[vfdName]) pointValues[vfdName] = {};
            pointValues[vfdName][pointId] = value;
            if (pointId === 'power') updatePowerChart();
            if (pointId === 'frequency') updateFrequencyChart();
        }
    }

    // Subscriber init (unchanged)
    try {
        require(['baja!'], function(baja) {
            subscriber = new baja.Subscriber();
            subscriber.attach('changed', function(prop) {
                if (prop.getName() === 'out') {
                    const pointInfo = this.userData;
                    if (pointInfo) {
                        const out = this.getOut();
                        const displayValue = out.getValue();
                        updatePointValue(pointInfo.vfdName, pointInfo.pointId, displayValue);
                    }
                }
            });
        });
    } catch (error) { console.error('Failed to initialize subscriber:', error); }

    function subscribeToPoint(vfdName, pointId, pointPath) {
        console.log(`Subscribing to: ${pointPath}`);
        try {
            require(['baja!'], function(baja) {
                baja.Ord.make(pointPath).get({ subscriber: subscriber })
                    .then(point => {
                        console.log(`‚úÖ Successfully connected to ${pointId}: ${pointPath}`);
                        point.userData = { vfdName: vfdName, pointId: pointId, pointPath: pointPath };
                        const out = point.getOut();
                        const displayValue = out.getValue();
                        updatePointValue(vfdName, pointId, displayValue);
                    })
                    .catch(error => {
                        console.error(`‚ùå Failed to connect to ${pointId} (${pointPath}):`, error);
                        updatePointValue(vfdName, pointId, 'Connection Error');
                    });
            });
        } catch (error) {
            console.error(`Failed to subscribe to ${pointPath}:`, error);
            updatePointValue(vfdName, pointId, 'Connection Error');
        }
    }

    function createVFDDisplay(vfdData) {
        const mainContent = document.getElementById('main-content');
        if (Object.keys(vfdData).length === 0) {
            mainContent.innerHTML = '<div class="error">No VFD configurations found in JSON file.</div>';
            return;
        }

        let html = `<table class="vav-table"><thead><tr>
                    <th>Name</th><th>Speed</th><th>Frequency</th><th>Torque</th><th>Power</th><th>Current</th><th>Voltage</th>
                    </tr></thead><tbody>`;

        const sortedVFDNames = Object.keys(vfdData).sort();
        sortedVFDNames.forEach(vfdName => {
            html += `<tr>
                        <td class="vav-name"><a href="../VFDs/${vfdName}.html">${vfdName}</a></td>
                        <td id="point-${vfdName}-speed" class="value-loading">Loading...</td>
                        <td id="point-${vfdName}-frequency" class="value-loading">Loading...</td>
                        <td id="point-${vfdName}-torque" class="value-loading">Loading...</td>
                        <td id="point-${vfdName}-power" class="value-loading">Loading...</td>
                        <td id="point-${vfdName}-current" class="value-loading">Loading...</td>
                        <td id="point-${vfdName}-voltage" class="value-loading">Loading...</td>
                    </tr>`;
        });

        html += `</tbody></table>`;
        mainContent.innerHTML = html;

        // Subscribe to all points
        sortedVFDNames.forEach(vfdName => {
            const points = vfdData[vfdName];
            const pointMapping = {
                'speed': points.find(p => p.id === 'speed'),
                'frequency': points.find(p => p.id === 'frequency'),
                'torque': points.find(p => p.id === 'torque'),
                'power': points.find(p => p.id === 'power'),
                'current': points.find(p => p.id === 'current'),
                'voltage': points.find(p => p.id === 'voltage')
            };

            Object.keys(pointMapping).forEach(pointId => {
                const point = pointMapping[pointId];
                if (point && point.status === 'connected') {
                    subscribeToPoint(vfdName, pointId, point.fullPath);
                } else {
                    let missingName = 'N/A';
                    if (pointId === 'speed') missingName = 'NO_Speed';
                    else if (pointId === 'frequency') missingName = 'NO_Frequency';
                    else if (pointId === 'torque') missingName = 'NO_Torque';
                    else if (pointId === 'power') missingName = 'NO_Power';
                    else if (pointId === 'current') missingName = 'NO_Current';
                    else if (pointId === 'voltage') missingName = 'NO_Voltage';

                    console.warn(`Point ${pointId} not found or not connected for VFD ${vfdName}`);
                    updatePointValue(vfdName, pointId, missingName);
                }
            });
        });

        // Initialize charts
        updatePowerChart();
        updateFrequencyChart();
    }

    async function loadAndDisplayVFDPoints() {
        try {
            console.log('=== LOADING VFD POINTS FROM JSON ===');
            const response = await fetch('../Global.json');
            if (!response.ok) throw new Error(`Failed to load JSON: ${response.status} ${response.statusText}`);
            const jsonData = await response.json();
            console.log('JSON data loaded:', jsonData);

            const vfdConfigs = {};
            Object.keys(jsonData.globalVariables).forEach(key => {
                const keyLower = key.toLowerCase();
                if (keyLower.includes('vfd_') || keyLower.includes('_sf') ||
                    keyLower.includes('_rf') || keyLower.includes('_ef') ||
                    keyLower.startsWith('rf_') || keyLower.startsWith('ef_')) {
                    console.log(`Found VFD configuration: ${key}`);
                    const connectedPoints = jsonData.globalVariables[key].points.filter(point => point.status === "connected");
                    if (connectedPoints.length > 0) vfdConfigs[key] = connectedPoints;
                }
            });

            allVFDPoints = vfdConfigs;
            console.log('Filtered VFD configurations:', vfdConfigs);
            console.log('=== VFD POINT LOADING COMPLETE ===');
            createVFDDisplay(vfdConfigs);
        } catch (error) {
            console.error('Error loading VFD points from JSON:', error);
            document.getElementById('main-content').innerHTML =
                `<div class="error">Error loading VFD data: ${error.message}</div>`;
        }
    }

    function cleanup() {
        if (subscriber) { subscriber.unsubscribeAll(); console.log('üßπ Cleaned up all subscriptions'); }
    }
    window.addEventListener('beforeunload', cleanup);

    // Initialize
    loadAndDisplayVFDPoints();
</script>
</body>
</html>
