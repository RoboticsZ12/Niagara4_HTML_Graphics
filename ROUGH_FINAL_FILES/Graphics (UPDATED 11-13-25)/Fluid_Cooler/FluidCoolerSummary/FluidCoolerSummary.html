<!DOCTYPE html>
<!-- @noSnoop -->
<html lang="en" xmlns:b="http://www.tridium.com/baja/baja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Murphy Control Panel - Fluid Cooler Monitoring</title>
    
    <!-- Add RequireJS and BajaScript Support -->
    <script type='text/javascript' src='/requirejs/config.js'></script>
    <script type='text/javascript' src='/module/js/com/tridium/js/ext/require/require.min.js?'></script>
    
    <style>

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            margin: 0;
            min-height: 100vh;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 25%, #2d1b4e 50%, #1e3a5f 75%, #0f2027 100%);
            background-attachment: fixed;
            position: relative;
            overflow-x: hidden;
        }
        
        /* Animated background bubbles */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 219, 226, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 60% 70%, rgba(138, 43, 226, 0.25) 0%, transparent 50%);
            animation: float 20s ease-in-out infinite;
            pointer-events: none;
            z-index: -1;
        }
        
        @keyframes float {
            0%, 100% { transform: translate(0px, 0px) rotate(0deg); }
            33% { transform: translate(30px, -30px) rotate(120deg); }
            66% { transform: translate(-20px, 20px) rotate(240deg); }
        }
        
        .header {
            text-align: center;
            color: #e0e6ed;
            margin: 30px 20px 40px;
            padding: 30px;
            background: linear-gradient(135deg, rgba(15, 32, 39, 0.9) 0%, rgba(45, 27, 78, 0.9) 100%);
            border-radius: 20px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 40px rgba(138, 43, 226, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(138, 43, 226, 0.1), transparent);
            animation: shimmer 3s linear infinite;
            pointer-events: none;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }
        
        .header h1 {
            font-size: 2.5em;
            font-weight: 900;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #64b5f6, #ab47bc, #26c6da);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(138, 43, 226, 0.5);
            position: relative;
            z-index: 1;
        }
        
        .header p {
            font-size: 1.1em;
            color: #b0c4de;
            position: relative;
            z-index: 1;
        }
        
        .cooler-container {
            margin: 0 20px 40px;
            background: linear-gradient(135deg, rgba(15, 32, 39, 0.95) 0%, rgba(30, 58, 95, 0.95) 100%);
            border-radius: 20px;
            box-shadow: 
                0 10px 40px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            overflow: hidden;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 181, 246, 0.2);
            position: relative;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .cooler-container:hover {
            transform: translateY(-5px);
            box-shadow: 
                0 15px 50px rgba(0, 0, 0, 0.5),
                0 0 50px rgba(138, 43, 226, 0.3);
        }
        
        .cooler-header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #8e2de2 100%);
            color: #ffffff;
            padding: 20px 25px;
            font-size: 1.4em;
            font-weight: 700;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }
        
        .cooler-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            animation: slide 3s infinite;
        }
        
        @keyframes slide {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .points-grid {
            padding: 25px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
        }
        
        .point-item {
            background: linear-gradient(135deg, rgba(15, 32, 39, 0.8) 0%, rgba(45, 27, 78, 0.8) 100%);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(100, 181, 246, 0.3);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            backdrop-filter: blur(10px);
            cursor: pointer;
        }
        
        .point-item:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 12px 35px rgba(0, 0, 0, 0.4),
                0 0 30px rgba(138, 43, 226, 0.4);
            border-color: rgba(171, 71, 188, 0.6);
        }
        
        .point-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.1) 0%, transparent 50%);
            border-radius: 15px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .point-item:hover::before {
            opacity: 1;
        }
        
        .point-item::after {
            content: 'ðŸ“Š Click for History';
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 0.7em;
            color: #26c6da;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 2;
        }
        
        .point-item:hover::after {
            opacity: 0.8;
        }
        
        .point-name {
            font-weight: 700;
            color: #64b5f6;
            margin-bottom: 8px;
            font-size: 1.1em;
            text-shadow: 0 0 10px rgba(100, 181, 246, 0.5);
            position: relative;
            z-index: 1;
        }
        
        .point-value {
            font-size: 1.3em;
            color: #26c6da;
            margin-bottom: 8px;
            font-weight: 700;
            text-shadow: 0 0 15px rgba(38, 198, 218, 0.6);
            position: relative;
            z-index: 1;
        }
        
        .point-path {
            font-size: 0.8em;
            color: #90a4ae;
            word-break: break-all;
            opacity: 0.8;
            position: relative;
            z-index: 1;
        }
        
        .point-type {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.7em;
            font-weight: 700;
            text-transform: uppercase;
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        
        .type-numeric {
            background: linear-gradient(45deg, #1e3c72, #2a5298);
            color: #ffffff;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .type-boolean {
            background: linear-gradient(45deg, #8e2de2, #4a00e0);
            color: #ffffff;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .type-other {
            background: linear-gradient(45deg, #2d5016, #3e7b27);
            color: #ffffff;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .loading {
            text-align: center;
            padding: 60px;
            color: #64b5f6;
            font-size: 1.2em;
            text-shadow: 0 0 20px rgba(100, 181, 246, 0.5);
        }
        
        .error {
            color: #ff6b9d;
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, rgba(255, 107, 157, 0.1) 0%, rgba(138, 43, 226, 0.1) 100%);
            border-radius: 15px;
            margin: 20px;
            border: 1px solid rgba(255, 107, 157, 0.3);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .no-data {
            text-align: center;
            padding: 60px;
            color: #90a4ae;
            font-style: italic;
            font-size: 1.1em;
        }
        
        /* History Popup Modal Styles */
        .history-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .history-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .history-content {
            background: linear-gradient(135deg, rgba(15, 32, 39, 0.98) 0%, rgba(30, 58, 95, 0.98) 100%);
            border-radius: 20px;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(100, 181, 246, 0.3);
            backdrop-filter: blur(15px);
            position: relative;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { transform: scale(0.8) translateY(50px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }
        
        .history-header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #8e2de2 100%);
            color: #ffffff;
            padding: 25px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .history-title {
            font-size: 1.5em;
            font-weight: 700;
        }
        
        .close-button {
            background: none;
            border: none;
            color: #ffffff;
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 50%;
            transition: background-color 0.3s ease;
        }
        
        .close-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .history-body {
            padding: 30px;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .history-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .date-control {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .date-control label {
            color: #64b5f6;
            font-weight: 700;
            font-size: 0.9em;
        }
        
        .date-picker {
            padding: 10px 15px;
            background: linear-gradient(135deg, rgba(15, 32, 39, 0.9) 0%, rgba(30, 58, 95, 0.9) 100%);
            border: 2px solid rgba(100, 181, 246, 0.3);
            border-radius: 8px;
            color: #e0e6ed;
            font-family: 'Orbitron', monospace;
            font-size: 0.9em;
            backdrop-filter: blur(10px);
            transition: border-color 0.3s ease;
        }
        
        .date-picker:focus {
            outline: none;
            border-color: #26c6da;
        }
        
        .load-button {
            padding: 10px 20px;
            background: linear-gradient(45deg, #1e3c72, #2a5298);
            border: none;
            border-radius: 8px;
            color: #ffffff;
            font-family: 'Orbitron', monospace;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            align-self: end;
        }
        
        .load-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(30, 60, 114, 0.4);
        }
        
        .point-info {
            background: linear-gradient(135deg, rgba(38, 198, 218, 0.1) 0%, rgba(138, 43, 226, 0.1) 100%);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 25px;
            border: 1px solid rgba(38, 198, 218, 0.3);
        }
        
        .point-info-name {
            font-size: 1.3em;
            color: #26c6da;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .point-info-path {
            font-size: 0.95em;
            color: #90a4ae;
            word-break: break-all;
        }
        
        .history-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        
        .stat-box {
            background: linear-gradient(135deg, rgba(15, 32, 39, 0.8) 0%, rgba(45, 27, 78, 0.8) 100%);
            border-radius: 10px;
            padding: 15px 20px;
            border: 1px solid rgba(100, 181, 246, 0.3);
            text-align: center;
            flex: 1;
            min-width: 120px;
        }
        
        .stat-label {
            font-size: 0.85em;
            color: #90a4ae;
            margin-bottom: 8px;
        }
        
        .stat-value {
            font-size: 1.2em;
            color: #26c6da;
            font-weight: 700;
        }
        
        .history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .history-table th {
            background: linear-gradient(135deg, rgba(30, 60, 114, 0.8) 0%, rgba(142, 45, 226, 0.8) 100%);
            color: #ffffff;
            padding: 15px;
            text-align: left;
            font-weight: 700;
            border-bottom: 2px solid rgba(38, 198, 218, 0.3);
            position: sticky;
            top: 0;
        }
        
        .history-table td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #e0e6ed;
        }
        
        .history-table tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .history-table tr:hover {
            background: rgba(38, 198, 218, 0.1);
        }
        
        .history-loading {
            text-align: center;
            padding: 40px;
            color: #64b5f6;
            font-size: 1.1em;
        }
        
        .history-error {
            color: #ff6b9d;
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, rgba(255, 107, 157, 0.1) 0%, rgba(138, 43, 226, 0.1) 100%);
            border-radius: 10px;
            border: 1px solid rgba(255, 107, 157, 0.3);
        }
        
        .history-no-data {
            text-align: center;
            padding: 40px;
            color: #90a4ae;
            font-style: italic;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(15, 32, 39, 0.5);
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #1e3c72, #8e2de2);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #2a5298, #ab47bc);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Fluid Cooler Point Display System</h1>
        <p>Real-time monitoring of all Fluid Cooler points with historical data access</p>
    </div>
    
    <div id="main-content">
        <div class="loading">Loading Fluid Cooler points...</div>
    </div>

    <!-- History Modal Popup -->
    <div id="history-modal" class="history-modal">
        <div class="history-content">
            <div class="history-header">
                <div class="history-title">Point History</div>
                <button class="close-button" onclick="closeHistoryModal()">&times;</button>
            </div>
            <div class="history-body">
                <div class="point-info">
                    <div class="point-info-name" id="modal-point-name">Loading...</div>
                    <div class="point-info-path" id="modal-point-path">Loading...</div>
                </div>
                
                <div class="history-controls">
                    <div class="date-control">
                        <label for="modal-start-date">Start Date:</label>
                        <input type="date" id="modal-start-date" class="date-picker">
                    </div>
                    <div class="date-control">
                        <label for="modal-end-date">End Date:</label>
                        <input type="date" id="modal-end-date" class="date-picker">
                    </div>
                    <button class="load-button" onclick="loadModalHistory()">Load History</button>
                </div>
                
                <div id="history-data-content">
                    <div class="history-loading">Select date range and click "Load History"</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let pointSubscriptions = [];
        let pointValues = {};
        let allFluidCoolerPoints = {};
        let subscriber;
        let currentHistoryPoint = null;
        let historyCache = new Map();
        
        // User authorization check
        function isAuthorizedUser() {
            const username = 'murphy'; // Simulated user
            console.log('Current user:', username);
            
            if (!username) {
                console.log('No user found');
                return false;
            }
            
            const authorizedUsers = ['murphy', 'admin'];
            const isAuthorized = authorizedUsers.includes(username.toLowerCase());
            
            console.log('User authorized for point display:', isAuthorized);
            return isAuthorized;
        }

        // Check authorization before proceeding
        if (!isAuthorizedUser()) {
            console.log('Point display script terminated - user not authorized');
            document.getElementById('main-content').innerHTML = 
                '<div class="error">Access Denied: You do not have permission to view point data.</div>';
            throw new Error('Unauthorized access');
        }

        // Initialize date inputs to last 24 hours
        function initializeDateInputs() {
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 1);
            
            document.getElementById('modal-start-date').value = startDate.toISOString().split('T')[0];
            document.getElementById('modal-end-date').value = endDate.toISOString().split('T')[0];
        }

        // Function to get point type styling
        function getPointTypeClass(pointId) {
            if (pointId === 'SP-Numeric') return 'type-numeric';
            if (pointId === 'SP-Boolean') return 'type-boolean';
            return 'type-other';
        }

        // Function to format point values
        function formatPointValue(value, pointId) {
            if (value === null || value === undefined) return 'No Data';
            
            if (pointId === 'SP-Boolean') {
                return value ? 'TRUE' : 'FALSE';
            } else if (pointId === 'SP-Numeric') {
                return typeof value === 'number' ? value.toFixed(2) : value.toString();
            }
            
            return value.toString();
        }

        // Function to update point value in the display
        function updatePointValue(coolerName, pointName, value) {
            const elementId = `point-${coolerName}-${pointName}`;
            const valueElement = document.getElementById(elementId);
            if (valueElement) {
                const pointInfo = getAllFluidCoolerPoints()[coolerName]?.find(p => p.name === pointName);
                const formattedValue = formatPointValue(value, pointInfo?.id);
                valueElement.textContent = formattedValue;
                
                if (!pointValues[coolerName]) pointValues[coolerName] = {};
                pointValues[coolerName][pointName] = value;
            }
        }

        function getAllFluidCoolerPoints() {
            return allFluidCoolerPoints;
        }

        // Initialize subscriber
        try {
            require(['baja!'], function(baja) {
                subscriber = new baja.Subscriber();
                
                subscriber.attach('changed', function(prop) {
                    if (prop.getName() === 'out') {
                        const pointInfo = this.userData;
                        if (pointInfo) {
                            const out = this.getOut();
                            const displayValue = out.getValueDisplay();
                            const isOverridden = this.getStatus().isOverridden();
                            
                            updatePointValueWithStatus(pointInfo.coolerName, pointInfo.pointName, displayValue, isOverridden, pointInfo.pointType);
                        }
                    }
                });
            });
        } catch (error) {
            console.error('Failed to initialize subscriber:', error);
        }

        // Function to update point value with override status and type-specific formatting
        function updatePointValueWithStatus(coolerName, pointName, displayValue, isOverridden, pointType) {
            const elementId = `point-${coolerName}-${pointName}`;
            const valueElement = document.getElementById(elementId);
            if (valueElement) {
                if (isOverridden) {
                    valueElement.textContent = `${displayValue} (Override)`;
                    valueElement.style.color = '#8B5CF6';
                    valueElement.style.fontWeight = 'bold';
                } else {
                    if (pointType === 'boolean') {
                        // Color boolean values based on true/false
                        const boolVal = displayValue === 'true' || displayValue === 'TRUE' || displayValue === true;
                        valueElement.textContent = displayValue;
                        valueElement.style.color = boolVal ? '#2ecc71' : '#e74c3c';
                    } else {
                        valueElement.textContent = displayValue;
                        valueElement.style.color = '#26c6da';
                    }
                    valueElement.style.fontWeight = 'normal';
                }
                
                if (!pointValues[coolerName]) pointValues[coolerName] = {};
                pointValues[coolerName][pointName] = displayValue;
            }
        }

        // Function to subscribe to a point using Niagara Baja
        function subscribeToPoint(coolerName, pointName, pointPath, pointType) {
            console.log(`Subscribing to: ${pointPath}`);
            
            try {
                require(['baja!'], function(baja) {
                    baja.Ord.make(pointPath).get({ subscriber: subscriber })
                        .then(point => {
                            console.log(`âœ… Successfully connected to ${pointName}: ${pointPath}`);
                            
                            point.userData = { 
                                coolerName: coolerName,
                                pointName: pointName, 
                                pointPath: pointPath,
                                pointType: pointType
                            };
                            
                            const out = point.getOut();
                            const displayValue = out.getValueDisplay();
                            const isOverridden = point.getStatus().isOverridden();
                            
                            updatePointValueWithStatus(coolerName, pointName, displayValue, isOverridden, pointType);
                        })
                        .catch(error => {
                            console.error(`âŒ Failed to connect to ${pointName} (${pointPath}):`, error);
                            updatePointValue(coolerName, pointName, 'Connection Error');
                        });
                });
            } catch (error) {
                console.error(`Failed to subscribe to ${pointPath}:`, error);
                setTimeout(() => {
                    const randomValue = (Math.random() * 100).toFixed(2);
                    updatePointValue(coolerName, pointName, randomValue);
                }, Math.random() * 2000);
            }
        }

        // Show history modal
        function showHistoryModal(pointPath, pointName, coolerName, pointType) {
            currentHistoryPoint = {
                path: pointPath,
                name: pointName,
                coolerName: coolerName,
                type: pointType,
                displayName: `${coolerName} - ${pointName}`
            };
            
            // Update modal content
            document.getElementById('modal-point-name').textContent = currentHistoryPoint.displayName;
            document.getElementById('modal-point-path').textContent = pointPath;
            
            // Clear previous history data
            document.getElementById('history-data-content').innerHTML = 
                '<div class="history-loading">Select date range and click "Load History"</div>';
            
            // Show modal
            document.getElementById('history-modal').classList.add('show');
        }

        // Close history modal
        function closeHistoryModal() {
            document.getElementById('history-modal').classList.remove('show');
            currentHistoryPoint = null;
        }

        // BQL History Discovery (from your original script)
        async function discoverHistoryOrd(pointOrd) {
            return new Promise((resolve, reject) => {
                try {
                    require(['baja!'], function (baja) {
                        console.log('Auto-discovering history from point:', pointOrd);
                        
                        baja.Ord.make(pointOrd).get()
                            .then(function(entity) {
                                return entity.tags();
                            })
                            .then(function(tagMap) {
                                var historyTag = tagMap.get('n:history');
                                console.log('Found history tag:', historyTag);
                                
                                if (historyTag && historyTag.toString().trim() !== '') {
                                    var historyPath = historyTag.toString();
                                    
                                    if (!historyPath.startsWith('history:')) {
                                        historyPath = 'history:' + historyPath;
                                    }
                                    
                                    console.log('Discovered history ORD:', historyPath);
                                    resolve(historyPath);
                                } else {
                                    reject(new Error('No n:history tag found on point: ' + pointOrd));
                                }
                            })
                            .catch(function(err) {
                                console.error('Could not load tags:', err);
                                reject(new Error('Failed to load point tags: ' + err.message));
                            });
                    });
                } catch (error) {
                    console.error('Baja require error:', error);
                    reject(error);
                }
            });
        }

        // Load historical data for both numeric and boolean points
        async function loadHistoryDataForPoint(pointPath, startTime, endTime, pointType, maxPoints = 1000) {
            return new Promise(async (resolve, reject) => {
                try {
                    const cacheKey = pointPath;
                    let historyOrd = historyCache.get(cacheKey);
                    
                    if (!historyOrd) {
                        try {
                            historyOrd = await discoverHistoryOrd(pointPath);
                            historyCache.set(cacheKey, historyOrd);
                        } catch (error) {
                            console.warn(`No history found for point ${pointPath}:`, error.message);
                            resolve([]);
                            return;
                        }
                    }
                    
                    require(['baja!'], function (baja) {
                        const timeCondition = `timestamp >= '${startTime.toISOString()}' and timestamp <= '${endTime.toISOString()}'`;
                        const bqlQuery = historyOrd + '|bql:select timestamp, value where ' + timeCondition + ' order by timestamp';
                        
                        console.log(`Executing BQL Query for ${pointType}:`, bqlQuery);
                        
                        const dataPoints = [];
                        
                        baja.Ord.make(bqlQuery).get({
                            cursor: {
                                limit: maxPoints,
                                each: function () {
                                    const row = this.get();
                                    const rawTimestamp = row.get("timestamp");
                                    const value = row.get("value");
                                    
                                    const date = new Date(rawTimestamp.getMillis());
                                    
                                    let processedValue;
                                    if (pointType === 'boolean') {
                                        processedValue = value === true || value === 'true' || value === 1 || value === '1';
                                    } else {
                                        processedValue = parseFloat(value);
                                        if (isNaN(processedValue)) {
                                            return;
                                        }
                                    }
                                    
                                    dataPoints.push({
                                        timestamp: date,
                                        timestampString: date.toLocaleString(),
                                        value: processedValue
                                    });
                                }
                            }
                        })
                        .then(function () {
                            console.log(`Loaded ${dataPoints.length} history points for ${pointPath} (${pointType})`);
                            resolve(dataPoints);
                        })
                        .catch(function (err) {
                            console.error('BQL Query failed:', err);
                            reject(new Error('Failed to load history data: ' + err.message));
                        });
                    });
                    
                } catch (error) {
                    console.error('History loading error:', error);
                    reject(error);
                }
            });
        }

        // Extract data unit from point name
        function extractDataUnit(pointNameOrOrd) {
            if (!pointNameOrOrd) return '';
            
            const name = pointNameOrOrd.toLowerCase();
            
            if (name.includes('temp') || name.includes('temperature')) return 'Â°F';
            if (name.includes('flow')) return 'GPM';
            if (name.includes('pressure')) return 'PSI';
            if (name.includes('humidity')) return '%';
            if (name.includes('percent') || name.includes('pct')) return '%';
            if (name.includes('speed')) return '%';
            if (name.includes('power')) return 'kW';
            if (name.includes('current')) return 'A';
            if (name.includes('voltage')) return 'V';
            if (name.includes('frequency') || name.includes('freq')) return 'Hz';
            
            return '';
        }

        // Load history data for modal
        async function loadModalHistory() {
            if (!currentHistoryPoint) return;
            
            const historyContent = document.getElementById('history-data-content');
            historyContent.innerHTML = '<div class="history-loading">Loading historical data...</div>';
            
            try {
                const startDateStr = document.getElementById('modal-start-date').value;
                const endDateStr = document.getElementById('modal-end-date').value;
                
                if (!startDateStr || !endDateStr) {
                    throw new Error('Please select both start and end dates');
                }
                
                const startDate = new Date(startDateStr);
                const endDate = new Date(endDateStr + 'T23:59:59');
                
                const historyData = await loadHistoryDataForPoint(
                    currentHistoryPoint.path, 
                    startDate, 
                    endDate, 
                    currentHistoryPoint.type, 
                    1000
                );
                
                if (historyData.length === 0) {
                    historyContent.innerHTML = '<div class="history-no-data">No historical data found for the selected date range.</div>';
                    return;
                }
                
                // Calculate statistics
                let stats;
                if (currentHistoryPoint.type === 'boolean') {
                    const trueCount = historyData.filter(d => d.value === true).length;
                    const falseCount = historyData.length - trueCount;
                    stats = {
                        count: historyData.length,
                        trueCount: trueCount,
                        falseCount: falseCount,
                        truePercent: ((trueCount / historyData.length) * 100).toFixed(1)
                    };
                } else {
                    const values = historyData.map(d => d.value);
                    stats = {
                        count: values.length,
                        min: Math.min(...values),
                        max: Math.max(...values),
                        avg: values.reduce((a, b) => a + b, 0) / values.length
                    };
                }
                
                const unit = currentHistoryPoint.type === 'numeric' ? extractDataUnit(currentHistoryPoint.displayName) : '';
                
                // Build HTML
                let html = '<div class="history-stats">';
                html += `<div class="stat-box"><div class="stat-label">Count</div><div class="stat-value">${stats.count}</div></div>`;
                
                if (currentHistoryPoint.type === 'boolean') {
                    html += `
                        <div class="stat-box">
                            <div class="stat-label">TRUE Count</div>
                            <div class="stat-value">${stats.trueCount}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">FALSE Count</div>
                            <div class="stat-value">${stats.falseCount}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">TRUE %</div>
                            <div class="stat-value">${stats.truePercent}%</div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="stat-box">
                            <div class="stat-label">Minimum</div>
                            <div class="stat-value">${stats.min.toFixed(2)} ${unit}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Maximum</div>
                            <div class="stat-value">${stats.max.toFixed(2)} ${unit}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Average</div>
                            <div class="stat-value">${stats.avg.toFixed(2)} ${unit}</div>
                        </div>
                    `;
                }
                
                html += '</div>';
                
                html += `
                    <table class="history-table">
                        <thead>
                            <tr>
                                <th>Timestamp</th>
                                <th>Value</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                const displayData = historyData.slice(-100).reverse();
                
                displayData.forEach(point => {
                    let displayValue;
                    if (currentHistoryPoint.type === 'boolean') {
                        displayValue = `<span style="color: ${point.value ? '#2ecc71' : '#e74c3c'}; font-weight: bold;">${point.value ? 'TRUE' : 'FALSE'}</span>`;
                    } else {
                        displayValue = `${point.value.toFixed(2)} ${unit}`;
                    }
                    
                    html += `
                        <tr>
                            <td>${point.timestampString}</td>
                            <td>${displayValue}</td>
                        </tr>
                    `;
                });
                
                html += '</tbody></table>';
                
                if (historyData.length > 100) {
                    html += `
                        <div style="text-align: center; margin-top: 20px; color: #90a4ae; font-size: 0.9em;">
                            Showing most recent 100 of ${historyData.length} records
                        </div>
                    `;
                }
                
                historyContent.innerHTML = html;
                
            } catch (error) {
                console.error('Error loading history data:', error);
                historyContent.innerHTML = `<div class="history-error">Error loading history: ${error.message}</div>`;
            }
        }

        // Function to create the display for all Fluid Cooler points
        function createFluidCoolerDisplay(coolerData) {
            const mainContent = document.getElementById('main-content');
            
            if (Object.keys(coolerData).length === 0) {
                mainContent.innerHTML = '<div class="no-data">No Fluid Cooler configurations found in JSON file.</div>';
                return;
            }
            
            let html = '';
            const sortedCoolerNames = Object.keys(coolerData).sort();
            
            sortedCoolerNames.forEach(coolerName => {
                const points = coolerData[coolerName];
                
                html += `
                    <div class="cooler-container">
                        <div class="cooler-header">${coolerName.replace(/_/g, ' ')}</div>
                        <div class="points-grid">
                `;
                
                points.forEach(point => {
                    const pointTypeClass = getPointTypeClass(point.id);
                    const pointId = `point-${coolerName}-${point.name}`;
                    const pointType = point.logNumeric === "yes_Numeric" ? "numeric" : "boolean";
                    const pointTypeText = pointType === 'numeric' ? 'NUMERIC' : 'BOOLEAN';
                    
                    html += `
                        <div class="point-item" onclick="showHistoryModal('${point.fullPath}', '${point.name}', '${coolerName}', '${pointType}')">
                            <div class="point-type ${pointTypeClass}">${pointTypeText}</div>
                            <div class="point-name">${point.name.replace(/_/g, ' ')}</div>
                            <div class="point-value" id="${pointId}">Loading...</div>
                            <div class="point-path">${point.fullPath}</div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            mainContent.innerHTML = html;
            
            // Subscribe to all points
            sortedCoolerNames.forEach(coolerName => {
                const points = coolerData[coolerName];
                points.forEach(point => {
                    const pointType = point.logNumeric === "yes_Numeric" ? "numeric" : "boolean";
                    subscribeToPoint(coolerName, point.name, point.fullPath, pointType);
                });
            });
        }

      // Function to load and parse JSON configuration
async function loadAndDisplayFluidCoolerPoints() {
    try {
        console.log('=== LOADING ALL FLUID COOLER POINTS FROM JSON ===');

        const response = await fetch('../../Global.json');
        if (!response.ok) {
            throw new Error(`Failed to load JSON: ${response.status} ${response.statusText}`);
        }

        const jsonData = await response.json();
        console.log('JSON data loaded:', jsonData);

        // Pull every Fluid_Cooler section â€” no filtering
        const coolerConfigs = {};

        Object.keys(jsonData.globalVariables).forEach(key => {
            if (key.toLowerCase().includes('fluid_cooler')) {
                console.log(`Found Fluid Cooler configuration: ${key}`);

                // âœ… Include all points under this section (no filtering)
                const allPoints = jsonData.globalVariables[key].points || [];

                if (allPoints.length > 0) {
                    coolerConfigs[key] = allPoints;
                }
            }
        });

        allFluidCoolerPoints = coolerConfigs;

        console.log('âœ… Fluid Cooler configurations loaded:', coolerConfigs);
        console.log('=== FLUID COOLER POINT LOADING COMPLETE ===');

        createFluidCoolerDisplay(coolerConfigs);

    } catch (error) {
        console.error('Error loading Fluid Cooler points from JSON:', error);
        document.getElementById('main-content').innerHTML =
            `<div class="error">Error loading Fluid Cooler data: ${error.message}</div>`;
    }
}

        // Cleanup function for subscriptions
        function cleanup() {
            if (subscriber) {
                subscriber.unsubscribeAll();
                console.log('ðŸ§¹ Cleaned up all subscriptions');
            }
        }

        // Handle page unload
        window.addEventListener('beforeunload', cleanup);

        // Initialize the system
        initializeDateInputs();
        loadAndDisplayFluidCoolerPoints();
    </script>
</body>
</html>