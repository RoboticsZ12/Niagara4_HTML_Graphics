<!DOCTYPE html>
<!-- @noSnoop -->
<html lang="en" xmlns:b="http://www.tridium.com/baja/baja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Murphy Control Panel - AHU Monitoring</title>

<!-- Add RequireJS and BajaScript Support -->
<script type='text/javascript' src='/requirejs/config.js'></script>
<script type='text/javascript' src='/module/js/com/tridium/js/ext/require/require.min.js?'></script>

    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --error-color: #e74c3c;
            --background: #f8f9fa;
            --card-bg: #ffffff;
            --text-color: #2c3e50;
            --border-color: #dee2e6;
            --shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] {
            --primary-color: #34495e;
            --secondary-color: #3498db;
            --success-color: #2ecc71;
            --warning-color: #f39c12;
            --error-color: #e74c3c;
            --background: #1a1a1a;
            --card-bg: #2d2d2d;
            --text-color: #ecf0f1;
            --border-color: #444;
            --shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--background);
            color: var(--text-color);
            line-height: 1.6;
            transition: all 0.3s ease;
        }

        .header {
            background: var(--primary-color);
            color: white;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow);
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .header-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.25rem;
        }

        .datetime {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .monitoring-status {
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-weight: bold;
        }

        .monitoring-active {
            background: var(--success-color);
            color: white;
        }

        .monitoring-inactive {
            background: var(--error-color);
            color: white;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .btn {
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
            text-align: center;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: var(--secondary-color);
            color: white;
        }

        .btn-success {
            background: var(--success-color);
            color: white;
        }

        .btn-warning {
            background: var(--warning-color);
            color: white;
        }

        .btn-danger {
            background: var(--error-color);
            color: white;
        }

        .btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        /*.card {*/
        /*    background: var(--card-bg);*/
        /*    border-radius: 8px;*/
        /*    padding: 1.5rem;*/
        /*    margin-bottom: 2rem;*/
        /*    box-shadow: var(--shadow);*/
        /*    border: 1px solid var(--border-color);*/
        /*}*/

        .card h2 {
            margin-bottom: 1rem;
            color: var(--primary-color);
            font-size: 1.3rem;
        }

        .status-display {
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            border-left: 4px solid;
        }

        .status-ok {
            background: rgba(39, 174, 96, 0.1);
            border-left-color: var(--success-color);
        }

        .status-warning {
            background: rgba(243, 156, 18, 0.1);
            border-left-color: var(--warning-color);
        }

        .status-error {
            background: rgba(231, 76, 60, 0.1);
            border-left-color: var(--error-color);
        }

        .status-title {
            font-weight: bold;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        .status-details p {
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
        }

        .bubbleSP {
            margin-bottom: 1rem;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            padding: 0.75rem 1rem;
            background: var(--secondary-color);
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-block;
        }

        .file-input-label:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .dark-mode-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: 2rem;
        }

        .toggle-switch {
            width: 50px;
            height: 24px;
            background: #ccc;
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: var(--secondary-color);
        }

        .toggle-switch::after {
            content: '';
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(26px);
        }

        .toggle-label {
            font-size: 0.9rem;
            color: white;
        }

        /*.graph-viewer {*/
        /*    position: fixed;*/
        /*    top: 0;*/
        /*    left: 0;*/
        /*    width: 100%;*/
        /*    height: 100%;*/
        /*    background: var(--background);*/
        /*    z-index: 1000;*/
        /*    display: none;*/
        /*    flex-direction: column;*/
        /*}*/
        
.graph-viewer {
    position: fixed;
    inset: 0;                        /* shorthand for top/right/bottom/left = 0 */
    width: 100%;
    height: 100%;                    /* lock to viewport height */
    background: var(--background);
    z-index: 1000;
    display: none;
    flex-direction: column;
    overflow-y: auto;                /* scroll overlay */
    -webkit-overflow-scrolling: touch; /* smooth scroll on iOS */
}

.graph-viewer.active {
    display: flex;
}

/* Important: let content grow naturally instead of stretching */
.graph-content {
    flex: 0 0 auto;                  /* was flex:1, that blocks scrolling */
    padding: 2rem;
    display: flex;
    flex-direction: column;
}


        .graph-header {
            background: var(--primary-color);
            color: white;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .graph-controls {
            background: var(--card-bg);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .graph-content {
            flex: 1;
            padding: 2rem;
            display: flex;
            flex-direction: column;
        }

        .graph-container {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: var(--shadow);
            height: 400px;
            position: relative;
            margin-bottom: 2rem;
        }

        #graphCanvas {
            width: 100%;
            height: 100%;
            border-radius: 6px;
        }

        .no-data-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-color);
            font-size: 1.1rem;
            text-align: center;
        }

        .graph-legend {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }

        .graph-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
        }

        .stat-card {
            background: var(--card-bg);
            padding: 1rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--secondary-color);
            margin-bottom: 0.25rem;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-color);
            opacity: 0.8;
        }

        select, input[type="date"] {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--card-bg);
            color: var(--text-color);
            font-size: 0.9rem;
        }

        .hidden {
            display: none;
        }

        .config-status {
            margin-bottom: 1rem;
            padding: 1rem;
            background: var(--card-bg);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .import-status {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: 500;
            margin-left: auto;
            min-width: 200px;
            text-align: center;
        }
        
        .import-success {
            background: rgba(39, 174, 96, 0.1);
            color: var(--success-color);
            border: 1px solid var(--success-color);
        }
        
        .import-error {
            background: rgba(231, 76, 60, 0.1);
            color: var(--error-color);
            border: 1px solid var(--error-color);
        }
        
        .import-warning {
            background: rgba(243, 156, 18, 0.1);
            color: var(--warning-color);
            border: 1px solid var(--warning-color);
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header {
                padding: 1rem;
                flex-direction: column;
                gap: 1rem;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .graph-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
        
        
        
        
        
        
             select, input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }
        
        .series-separator {
            width: 100%;
            height: 1px;
            background: #e0e0e0;
            margin: 20px 0;
            position: relative;
        }
        
        .series-separator::before {
            content: 'Second Series (Optional)';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 0 10px;
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }
        
        .series-1 {
            border-left: 4px solid #3498db;
            padding-left: 15px;
            background: rgba(52, 152, 219, 0.05);
            border-radius: 4px;
        }
        
        .series-2 {
            border-left: 4px solid #e74c3c;
            padding-left: 15px;
            background: rgba(231, 76, 60, 0.05);
            border-radius: 4px;
        }
        
        .import-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }
        
        .import-btn:hover {
            background: #2980b9;
        }
        
        .legend-demo {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 3, 3, 0.05);
            border-radius: 4px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        
        .legend-text {
            font-size: 18px;
            /* color: #0de1de; */
            color: white;
            font-weight: bold;
        }






        select {
    padding: 6px 12px;
    border: 1px solid #ccc;
    border-radius: 6px;
    gap: 10px;
    background: #0b6561;
    font-family: "Segoe UI", sans-serif;
    font-size: 20px;
    color: #000000;

    /* remove native dropdown arrow */
    appearance: none;  
    -webkit-appearance: none; 
    -moz-appearance: none;

    /* custom dropdown arrow */
    background-image: url("data:image/svg+xml;utf8,<svg fill='gray' height='24' viewBox='0 0 24 24' width='24' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>");
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-size: 16px;
    padding-right: 36px; /* space for arrow */
}

select:focus {
    border-color: #3498db;
    box-shadow: 0 0 4px rgba(52,152,219,0.4);
    outline: none;
}

 /* Enhanced styles for multi-series support */
        .series-container {
            min-height: 120px;
        }
        
        .series-controls {
            transition: all 0.3s ease;
        }
        
        .series-controls:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(248, 7, 7, 0.1);
        }
        
        .stat-group {
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
            padding: 6px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        
        .control-group {
            margin: 5px 0;
        }
        
        .control-label {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 3px;
            display: block;
        }
        
        .control-group select {
            width: 100%;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: rgb(16, 199, 196);
            font-size: 15px;
        }
        
        .stat-card {
            text-align: center;
            padding: 8px;
            background: rgba(154, 124, 124, 0.1);
            border-radius: 4px;
        }
        
        .stat-value {
            font-weight: bold;
            font-size: 24px;
            margin-bottom: 2px;
        }
        
        .stat-label {
            font-size: 11px;
            opacity: 0.8;
        }


    </style>
</head>
<body>
<!-- Main View -->
    <div id="mainView">
        <div class="header">
            <h1>Numerical System Logger</h1>
            <div style="display: flex; align-items: center;">
                <div class="header-info">
                    <div id="currentDateTime" class="datetime"></div>
                    <div id="monitoringStatus" class="monitoring-status"></div>
                </div>
                <div class="dark-mode-toggle">
                    <span class="toggle-label">Light Mode</span>
                    <div class="toggle-switch" id="toggleSwitch"></div>
                </div>
            </div>
        </div>

        <div class="container">
            <!-- Configuration Status -->
            <div class="card">
                <h2>Configuration Status</h2>
                <div id="configStatus" class="config-status">
                    <div class="status-display status-warning">
                        <div class="status-title">Loading Global.json configuration...</div>
                        <div class="status-details">
                            <p>Attempting to read Global.json from directory</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Control Panel -->
            <div class="card">
                <h2>Control Panel</h2>
                <div class="controls">
                    <button class="btn btn-success" onclick="startMonitoring()">Start Monitoring</button>
                    <button class="btn btn-warning" onclick="stopMonitoring()">Stop Monitoring</button>
                    <button class="btn btn-primary" onclick="collectDataNow()">Collect Now</button>
                    <button class="btn btn-primary" onclick="reloadConfig()">Reload Config</button>
                    <button class="btn btn-secondary" onclick="exportLogs()">Export CSV</button>
                    <button class="btn btn-secondary" onclick="exportFullDataJSON()">Export JSON</button>
                    <button class="btn btn-primary" onclick="toggleGraphViewer()">View Graphs</button>
                    <button class="btn btn-danger" onclick="clearLogs()">Clear Logs</button>
                </div>
            </div>

            <!-- System Status -->
            <div class="card">
                <h2>System Status</h2>
                <div id="system-status">
                    <!-- Overall summary will be injected here -->
                </div>
            </div>

            <!-- Recent Event Logs -->
            <div class="card">
                <h2>Recent Numerical Data (Last 5 Entries)</h2>
                <div id="eventLogs">
                    <!-- Logs will be populated here -->
                </div>
            </div>
        </div>
    </div>


<!-- Graph Viewer -->
    <div id="graphViewer" class="graph-viewer">
        <div class="graph-header" style="position: relative;">
            <h1>Graph Viewer</h1>
            <!-- File History Container will be dynamically inserted here -->
            <div id="fileHistoryContainer" style="
                position: absolute;
                top: 10px;
                right: 200px;
                display: flex;
                flex-direction: column;
                gap: 5px;
                z-index: 1000;
                max-width: 200px;
            "></div>
            <button class="btn btn-secondary" onclick="toggleGraphViewer()">Back to Monitor</button>
        </div>
        
        <div class="graph-controls">
            <div class="control-row">
                <div class="file-input-wrapper">
                    <input type="file" id="jsonFileInput" accept=".json" onchange="importJsonFile(this)">
                    <label for="jsonFileInput" class="file-input-label">Import JSON Data</label>
                </div>
                <div class="control-group">
                    <label class="control-label">Date:</label>
                    <input type="date" id="dateInput" onchange="forceRefreshGraph()">
                </div>
                <div class="control-group">
                    <label class="control-label">Time Range:</label>
                    <select id="timeRangeSelector" onchange="updateGraph()">
                        <option value="all">All Day</option>
                        <!--<option value="60">Last Hour</option>-->
                        <!--<option value="240">Last 4 Hours</option>-->
                        <!--<option value="480">Last 8 Hours</option>-->
                    </select>
                </div>
            </div>
            
            <!-- Dynamic Series Container -->
            <div class="series-container" style="
                display: flex; 
                gap: 15px; 
                align-items: flex-start; 
                flex-wrap: wrap;
                margin: 20px 0;
                padding: 15px;
                background: rgba(0, 0, 0, 0.02);
                border-radius: 8px;
                border: 1px solid #e0e0e0;
            ">
                <!-- Series controls will be dynamically added here -->
            </div>
            
            <div id="importStatus" class="import-status"></div>
        </div>
        
        <div class="graph-content">
            <div class="graph-container">
                <canvas id="graphCanvas"></canvas>
                <div id="noDataMessage" class="no-data-message">
                    Import a JSON file first to view graph data.
                </div>
            </div>
            
            <div id="graphLegend" class="graph-legend"></div>
            <div id="graphStats" class="graph-stats"></div>
        </div>
    </div>
    
    

    <script>
        // Global variables
        let eventLogs = [];
        let monitoringActive = false;
        let logCounter = 0;
        let startTime = new Date();
        let lastCollectionTime = null;
        let graphViewerActive = false;
        let importedJsonData = null;
        let globalConfig = null;
        let monitoredPoints = [];



        let fileHistory = [];
        let activeSeries = []; // Array to store active series configurations
let seriesColors = ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6']; // Colors for up to 5 series
let maxSeries = 5;  
        
        // Initialize system
        function initializeSystem() {
            updateDateTime();
            updateMonitoringStatus();
            updateEventLogs();
            initializeDateInput();
            loadGlobalConfig();
            
            // Start auto-save every 30 seconds
            setInterval(saveData, 30000);
            
            // Start data collection every 15 minutes (900000ms)
            setInterval(() => {
                if (monitoringActive) {
                    collectAllData();
                }
            }, 900000);
            
            // Update time every second
            setInterval(updateDateTime, 1000);
            
            console.log('Niagara Numerical System Monitor initialized');
        }

        async function loadGlobalConfig() {
            try {
                const response = await fetch('./Global.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                globalConfig = await response.json();
                parseMonitoredPoints();
                updateConfigStatus();
                
                console.log('Global.json loaded successfully');
                console.log('Monitored points found:', monitoredPoints.length);
                
            } catch (error) {
                console.error('Error loading Global.json:', error);
                updateConfigStatus(error.message);
            }
        }

        function parseMonitoredPoints() {
            monitoredPoints = [];
            
            if (!globalConfig || !globalConfig.globalVariables) {
                console.warn('No globalVariables found in config');
                return;
            }
            
            for (const [unitName, unitData] of Object.entries(globalConfig.globalVariables)) {
                if (!unitData.points || !Array.isArray(unitData.points)) {
                    continue;
                }
                
                unitData.points.forEach(point => {
                    if (point.logNumeric === "yes_Numeric" && point.status === "connected") {
                        monitoredPoints.push({
                            unit: unitName,
                            pointName: point.name,
                            fullPath: point.fullPath,
                            basePath: unitData.basePath,
                            id: point.id,
                            dateAdded: point.dateAdded
                        });
                    }
                });
            }
            
            console.log('Parsed monitored points:', monitoredPoints);
        }

        function updateConfigStatus(errorMessage = null) {
            const configStatus = document.getElementById('configStatus');
            
            if (errorMessage) {
                configStatus.innerHTML = `
                    <div class="status-display status-error">
                        <div class="status-title">Configuration Error</div>
                        <div class="status-details">
                            <p><strong>Error:</strong> ${errorMessage}</p>
                            <p>Please ensure Global.json exists in the same directory</p>
                            <p>Click "Reload Config" to try again</p>
                        </div>
                    </div>
                `;
            } else if (globalConfig) {
                const totalUnits = Object.keys(globalConfig.globalVariables || {}).length;
                const totalPoints = monitoredPoints.length;
                
                configStatus.innerHTML = `
                    <div class="status-display status-ok">
                        <div class="status-title">Configuration Loaded Successfully</div>
                        <div class="status-details">
                            <p><strong>Units Found:</strong> ${totalUnits}</p>
                            <p><strong>Numerical Points to Monitor:</strong> ${totalPoints}</p>
                            <p><strong>Config File:</strong> Global.json</p>
                            <p><strong>Last Loaded:</strong> ${new Date().toLocaleString()}</p>
                        </div>
                    </div>
                `;
            }
        }

        function reloadConfig() {
            loadGlobalConfig();
        }

        function updateDateTime() {
            const now = new Date();
            const formatted = now.toLocaleString('en-US', {
                day: '2-digit',
                month: 'short',
                year: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true,
                timeZoneName: 'short'
            });
            document.getElementById('currentDateTime').textContent = formatted;
        }

        function updateMonitoringStatus() {
            const statusElement = document.getElementById('monitoringStatus');
            if (monitoringActive) {
                statusElement.textContent = 'NUMERICAL MONITORING ACTIVE';
                statusElement.className = 'monitoring-status monitoring-active';
            } else {
                statusElement.textContent = 'NUMERICAL MONITORING STOPPED';
                statusElement.className = 'monitoring-status monitoring-inactive';
            }
        }

        async function collectAllData() {
            if (!monitoringActive || monitoredPoints.length === 0) return;
            
            // Check if we're running in a Niagara environment
            if (typeof require === 'undefined') {
                console.error('Baja require system not available. This script must run within a Niagara station environment.');
                showNotification('Baja System Error', 'This script must run within a Niagara station environment', 'error');
                return;
            }
            
            console.log('Collecting numerical data from configured points...');
            lastCollectionTime = new Date();
            
            let successCount = 0;
            let errorCount = 0;
            
            for (const point of monitoredPoints) {
                try {
                    // Read actual values from Niagara system using Baja
                    const value = await readActualPointValue(point);
                    
                    if (value !== null && value !== undefined) {
                        // Convert value to number if it's not already
                        const numericValue = typeof value === 'number' ? value : parseFloat(value);
                        
                        if (!isNaN(numericValue)) {
                            addNumericalDataPoint(point, numericValue);
                            successCount++;
                        } else {
                            console.warn(`Non-numeric value for ${point.unit}.${point.pointName}: ${value}`);
                            errorCount++;
                        }
                    } else {
                        console.warn(`Null value for ${point.unit}.${point.pointName}`);
                        errorCount++;
                    }
                } catch (error) {
                    console.error(`Error reading point ${point.unit}.${point.pointName}:`, error);
                    errorCount++;
                }
            }
            
            updateEventLogs();
            saveDataToFile();
            
            const message = `Collected ${successCount} points${errorCount > 0 ? `, ${errorCount} errors` : ''}`;
            showNotification('Data Collection Complete', message, successCount > 0 ? 'success' : 'warning');
        }

        async function readActualPointValue(point) {
            return new Promise((resolve, reject) => {
                try {
                    require(['baja!', 'baja!control:Override', 'baja!control:NumericOverride'], function (baja, Override, NumericOverride) {
                        'use strict';
                        
                        // Use the fullPath from the configuration
                        const pointPath = point.fullPath;
                        console.log(`Reading point: ${pointPath}`);
                        
                        baja.Ord.make(pointPath).get()
                            .then(function(point) {
                                if (point && point.getOut) {
                                    const value = point.getOut().getValue();
                                    console.log(`Point ${pointPath} value: ${value}`);
                                    resolve(value);
                                } else {
                                    console.warn(`Point ${pointPath} has no output value`);
                                    resolve(null);
                                }
                            })
                            .catch(function(error) {
                                console.error(`Error reading point ${pointPath}:`, error);
                                reject(error);
                            });
                    });
                } catch (error) {
                    console.error(`Baja require error for point ${point.fullPath}:`, error);
                    reject(error);
                }
            });
        }

        function addNumericalDataPoint(point, value) {
            const timestamp = new Date().toLocaleString();
            logCounter++;
            
            // Round value to the tenths place if it's a number
            const roundedValue = (typeof value === 'number' && !isNaN(value)) 
                ? Number(value.toFixed(2)) 
                : value;
            
            // Determine unit based on point ID or name from Global.json
            let dataUnit = '';
            if (point.id) {
                const id = point.id.toLowerCase();
                if (id.includes('temp') || id.includes('temperature')) dataUnit = '¬∞F';
                else if (id.includes('flow') || id.includes('air-flow')) dataUnit = 'CFM';
                else if (id.includes('pressure')) dataUnit = 'PSI';
                else if (id.includes('humidity')) dataUnit = '%';
                else if (id.includes('percent')) dataUnit = '%';
                else if (id.includes('speed')) dataUnit = '%';
                else if (id.includes('power')) dataUnit = 'kW';
                else if (id.includes('current')) dataUnit = 'A';
                else if (id.includes('voltage')) dataUnit = 'V';
            }
            
            // Fallback to point name if ID didn't provide unit info
            if (!dataUnit) {
                const pointName = point.pointName.toLowerCase();
                if (pointName.includes('temp')) dataUnit = '¬∞F';
                else if (pointName.includes('flow')) dataUnit = 'CFM';
                else if (pointName.includes('pressure')) dataUnit = 'PSI';
                else if (pointName.includes('humidity')) dataUnit = '%';
            }
            
            const logEntry = {
                id: logCounter,
                timestamp: timestamp,
                timestampObj: new Date(),
                unit: point.unit,
                pointName: point.pointName,
                pointId: point.id,
                value: roundedValue,
                dataUnit: dataUnit,
                fullPath: point.fullPath,
                displayName: `${point.unit} - ${point.pointName}`,
                details: `${point.pointName} = ${roundedValue} ${dataUnit}`
            };
            
            eventLogs.unshift(logEntry);
            
            // Keep only last 1000 entries
            if (eventLogs.length > 5000000) {
                eventLogs = eventLogs.slice(0, 5000000);
            }
        }
// 5 MB

        async function saveDataToFile() {
            try {
                const exportData = {
                    metadata: {
                        saveTimestamp: new Date().toISOString(),
                        totalLogs: eventLogs.length,
                        monitoredPointsCount: monitoredPoints.length
                    },
                    eventLogs: eventLogs,
                    systemConfig: {
                        monitoringActive: monitoringActive,
                        logCounter: logCounter,
                        startTime: startTime.toISOString(),
                        lastCollectionTime: lastCollectionTime ? lastCollectionTime.toISOString() : null
                    },
                    monitoredPoints: monitoredPoints
                };

                const jsonString = JSON.stringify(exportData, null, 2);
                
                // In a real implementation, this would save to the file system
                // For now, we'll save to browser storage as a backup
                console.log('Data would be saved to numerical_data.json:', exportData);
                
            } catch (error) {
                console.error('Save to file failed:', error);
            }
        }

        function updateEventLogs() {
            const logsContainer = document.getElementById('eventLogs');
            const recentLogs = eventLogs.slice(0, 5);
            
            logsContainer.innerHTML = '';
            
            if (recentLogs.length === 0) {
                logsContainer.innerHTML = `
                    <div class="bubbleSP">
                        <div class="point-status status-display">
                            <div class="status-title">No numerical data recorded yet</div>
                            <div class="status-details">
                                <p>System collects data from ${monitoredPoints.length} configured points every 15 minutes</p>
                                <p>Click "Collect Now" for immediate data collection</p>
                            </div>
                        </div>
                    </div>
                `;
                return;
            }
            
            recentLogs.forEach(log => {
                const logElement = document.createElement('div');
                logElement.className = 'bubbleSP';
                
                let statusClass = 'status-ok';
                let statusIcon = 'üìä';
                
                if (log.value === null || log.value === undefined) {
                    statusClass = 'status-error';
                    statusIcon = '‚ùå';
                } else if (log.value < 0) {
                    statusClass = 'status-warning';
                    statusIcon = '‚ö†Ô∏è';
                }
                
logElement.innerHTML = `
    <div class="point-status status-display ${statusClass}">
        <div class="status-title">${statusIcon} ${log.displayName} - ${log.value.toFixed(2)} ${log.dataUnit}</div>
        <div class="status-details">
            <p><strong>Timestamp:</strong> ${log.timestamp}</p>
            <p><strong>Value:</strong> ${log.value.toFixed(2)} ${log.dataUnit}</p>
            <p><strong>Unit:</strong> ${log.dataUnit}</p> <!-- fixed -->
            <p><strong>Point:</strong> ${log.pointName}</p>
            <p><strong>Full Path:</strong> ${log.fullPath}</p>
        </div>
    </div>
`;

                
                
                logsContainer.appendChild(logElement);
            });
            
            updateOverallStatus();
        }

        function updateOverallStatus() {
            const statusElement = document.getElementById('system-status');
            
            let summaryElement = document.getElementById('overall-summary');
            if (!summaryElement) {
                summaryElement = document.createElement('div');
                summaryElement.id = 'overall-summary';
                summaryElement.className = 'overall-summary';
                statusElement.appendChild(summaryElement);
            }
            
            const activePoints = monitoredPoints.length;
            const totalLogs = eventLogs.length;
            
            const overallClass = activePoints > 0 ? 'status-ok' : 'status-error';
            const overallTitle = `üìä ${activePoints} POINTS MONITORED`;
            const monitoringStatusText = monitoringActive ? 'üü¢ ACTIVE (15min intervals)' : 'üî¥ STOPPED';
            
            summaryElement.className = `overall-summary status-display ${overallClass}`;
            summaryElement.innerHTML = `
                <div class="status-title">${overallTitle}</div>
                <div class="status-details">
                    <p><strong>Monitoring Status:</strong> ${monitoringStatusText}</p>
                    <p><strong>Configured Points:</strong> ${activePoints} numerical points</p>
                    <p><strong>Total Logged Entries:</strong> ${totalLogs}</p>
                    <p><strong>Last Collection:</strong> ${lastCollectionTime ? lastCollectionTime.toLocaleString() : 'Never'}</p>
                    <p><strong>Config Status:</strong> ${globalConfig ? 'Loaded' : 'Not Loaded'}</p>
                </div>
            `;
        }

        // Control functions
        function startMonitoring() {
            if (!globalConfig) {
                showNotification('Configuration Required', 'Please load Global.json first', 'error');
                return;
            }
            
            if (monitoredPoints.length === 0) {
                showNotification('No Points Configured', 'No numerical points found in configuration', 'warning');
                return;
            }
            
            monitoringActive = true;
            updateMonitoringStatus();
            collectAllData();
            showNotification('Monitoring Started', `Monitoring ${monitoredPoints.length} numerical points`, 'success');
        }

        function stopMonitoring() {
            monitoringActive = false;
            updateMonitoringStatus();
            showNotification('Monitoring Stopped', 'Numerical monitoring has been paused', 'warning');
        }

        function collectDataNow() {
            if (!monitoringActive) {
                showNotification('Monitoring Inactive', 'Please start monitoring first', 'error');
                return;
            }
            
            if (monitoredPoints.length === 0) {
                showNotification('No Points Configured', 'No numerical points to collect', 'warning');
                return;
            }
            
            collectAllData();
        }

        function exportLogs() {
            if (eventLogs.length === 0) {
                showNotification('No Data', 'No logs to export', 'warning');
                return;
            }

            const headers = ['ID', 'Timestamp', 'Unit', 'Point Name', 'Value', 'Full Path'];

            // Sort logs by Unit, then Point Name, then Timestamp
            const sortedLogs = [...eventLogs].sort((a, b) => {
                if (a.unit !== b.unit) return a.unit.localeCompare(b.unit);
                if (a.pointName !== b.pointName) return a.pointName.localeCompare(b.pointName);
                return new Date(a.timestampObj) - new Date(b.timestampObj);
            });

            const csvRows = [headers.join(',')];

            let lastUnit = null;

            sortedLogs.forEach(log => {
                // If the unit changed, add a blank row before continuing
                if (lastUnit !== null && log.unit !== lastUnit) {
                    csvRows.push(''); // blank line
                }

                csvRows.push([
                    log.id,
                    `"${log.timestamp}"`,
                    `"${log.unit}"`,
                    `"${log.pointName}"`,
                    log.value,
                    `"${log.fullPath}"`,
                ].join(','));

                lastUnit = log.unit;
            });

            const csvContent = csvRows.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `niagara_numerical_logs_${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('Export Complete', `Exported ${eventLogs.length} log entries`, 'success');
        }

        function exportFullDataJSON() {
            const exportData = {
                metadata: {
                    exportTimestamp: new Date().toISOString(),
                    totalLogs: eventLogs.length,
                    exportType: 'fullNumericalData',
                    monitoredPointsCount: monitoredPoints.length
                },
                eventLogs: eventLogs,
                systemConfig: {
                    monitoringActive: monitoringActive,
                    logCounter: logCounter,
                    startTime: startTime.toISOString(),
                    lastCollectionTime: lastCollectionTime ? lastCollectionTime.toISOString() : null
                },
                monitoredPoints: monitoredPoints
            };

            const jsonString = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `niagara_numerical_data_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('JSON Export Complete', 'Full numerical data exported', 'success');
        }

        function saveData() {
            try {
                const saveData = {
                    eventLogs: eventLogs,
                    logCounter: logCounter,
                    monitoringActive: monitoringActive,
                    timestamp: new Date().toISOString(),
                    monitoredPoints: monitoredPoints
                };
                
                console.log('Data saved:', saveData);
                
                const saveTimeElement = document.getElementById('lastSaveTime');
                if (saveTimeElement) {
                    saveTimeElement.textContent = `Last saved: ${new Date().toLocaleTimeString()}`;
                }
                
                console.log('Auto-save completed');
            } catch (error) {
                console.error('Save failed:', error);
            }
        }

        function clearLogs() {
            if (confirm('Are you sure you want to clear all numerical logs? This cannot be undone.')) {
                eventLogs = [];
                logCounter = 0;
                updateEventLogs();
                showNotification('Logs Cleared', 'All numerical data has been cleared', 'info');
            }
        }














// JSON Import Functions
function importJsonFile(input) {
    const file = input.files[0];
    const statusElement = document.getElementById('importStatus');
    
    if (!file) {
        updateImportStatus('No file selected', 'warning');
        return;
    }
    
    if (!file.name.toLowerCase().endsWith('.json')) {
        updateImportStatus('Please select a JSON file', 'error');
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const jsonData = JSON.parse(e.target.result);
            processImportedJson(jsonData, file.name, e.target.result);
        } catch (error) {
            console.error('JSON parse error:', error);
            updateImportStatus('Invalid JSON file format', 'error');
        }
    };
    
    reader.onerror = function() {
        updateImportStatus('Error reading file', 'error');
    };
    
    reader.readAsText(file);
}

function processImportedJson(jsonData, fileName, rawJsonText) {
    try {
        // Handle different JSON structures
        let eventLogs = [];
        
        if (jsonData.eventLogs && Array.isArray(jsonData.eventLogs)) {
            eventLogs = jsonData.eventLogs;
        } else if (Array.isArray(jsonData)) {
            eventLogs = jsonData;
        } else if (jsonData.data && Array.isArray(jsonData.data)) {
            eventLogs = jsonData.data;
        } else if (jsonData.logs && Array.isArray(jsonData.logs)) {
            eventLogs = jsonData.logs;
        } else {
            throw new Error('No recognizable event logs structure found in JSON');
        }
        
        const validatedLogs = validateImportedLogs(eventLogs);
        
        if (validatedLogs.length === 0) {
            throw new Error('No valid log entries found with required fields (unit, pointName, timestamp, value)');
        }
        
        // Store the imported data globally
        importedJsonData = {
            eventLogs: validatedLogs,
            metadata: {
                fileName: fileName,
                importTime: new Date().toISOString(),
                totalEntries: validatedLogs.length
            }
        };
        
        // Add to file history
        addToFileHistory(fileName, validatedLogs, rawJsonText);
        
        // Update all series selectors
        updateAllSeriesSelectors();
        clearGraph();
        
        const uniqueUnits = [...new Set(validatedLogs.map(log => log.unit))].length;
        const uniquePoints = [...new Set(validatedLogs.map(log => log.pointName))].length;
        
        updateImportStatus(`Imported: ${validatedLogs.length} entries, ${uniqueUnits} units, ${uniquePoints} points`, 'success');
        
        console.log('JSON data imported successfully:', {
            fileName: fileName,
            totalEntries: validatedLogs.length,
            uniqueUnits: uniqueUnits,
            uniquePoints: uniquePoints
        });
        
    } catch (error) {
        console.error('Import processing error:', error);
        updateImportStatus(`Import failed: ${error.message}`, 'error');
        importedJsonData = null;
    }
}

function addToFileHistory(fileName, eventLogs, rawJsonText) {
    const fileData = {
        fileName: fileName,
        eventLogs: eventLogs,
        rawJson: rawJsonText,
        importTime: new Date().toISOString(),
        id: Date.now() + Math.random()
    };
    
    const existingIndex = fileHistory.findIndex(file => file.fileName === fileName);
    
    if (existingIndex !== -1) {
        fileHistory[existingIndex] = fileData;
    } else {
        if (fileHistory.length >= 5) {
            fileHistory.shift();
        }
        fileHistory.push(fileData);
    }
    
    updateFileHistoryDisplay();
}

function updateFileHistoryDisplay() {
    let historyContainer = document.getElementById('fileHistoryContainer');
    
    if (!historyContainer) {
        historyContainer = document.createElement('div');
        historyContainer.id = 'fileHistoryContainer';
        historyContainer.style.cssText = `
            position: absolute;
            top: 10px;
            right: 150px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
        `;
        
        const header = document.querySelector('.graph-header');
        if (header) {
            header.appendChild(historyContainer);
        }
    }
    
    historyContainer.innerHTML = '';
    
    if (fileHistory.length > 0) {
        const title = document.createElement('div');
        title.textContent = 'Recent Files:';
        title.style.cssText = `
            font-size: 15px;
            color: white;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        historyContainer.appendChild(title);
    }
    
    fileHistory.forEach((fileData, index) => {
        const button = document.createElement('button');
        
        const displayName = fileData.fileName.length > 20 ? 
            fileData.fileName.substring(0, 17) + '...' : 
            fileData.fileName;
        
        button.textContent = displayName;
        button.title = `${fileData.fileName} (${fileData.eventLogs.length} entries)`;
        button.style.cssText = `
            background: #2c3e50;
            color: white;
            border: 1px solid #34495e;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 120px;
            text-align: left;
        `;
        
        if (importedJsonData && importedJsonData.metadata.fileName === fileData.fileName) {
            button.style.background = '#3498db';
            button.style.borderColor = '#2980b9';
        }
        
        button.addEventListener('mouseenter', function() {
            if (this.style.background !== 'rgb(52, 152, 219)') {
                this.style.background = '#34495e';
            }
        });
        
        button.addEventListener('mouseleave', function() {
            if (importedJsonData && importedJsonData.metadata.fileName === fileData.fileName) {
                this.style.background = '#3498db';
            } else {
                this.style.background = '#2c3e50';
            }
        });
        
        button.addEventListener('click', function() {
            loadFileFromHistory(fileData);
        });
        
        historyContainer.appendChild(button);
    });
}

function loadFileFromHistory(fileData) {
    try {
        importedJsonData = {
            eventLogs: fileData.eventLogs,
            metadata: {
                fileName: fileData.fileName,
                importTime: fileData.importTime,
                totalEntries: fileData.eventLogs.length
            }
        };
        
        updateAllSeriesSelectors();
        clearGraph();
        updateFileHistoryDisplay();
        
        const uniqueUnits = [...new Set(fileData.eventLogs.map(log => log.unit))].length;
        const uniquePoints = [...new Set(fileData.eventLogs.map(log => log.pointName))].length;
        
        updateImportStatus(`Loaded: ${fileData.fileName} (${fileData.eventLogs.length} entries, ${uniqueUnits} units, ${uniquePoints} points)`, 'success');
        
    } catch (error) {
        console.error('Error loading file from history:', error);
        updateImportStatus(`Error loading ${fileData.fileName}: ${error.message}`, 'error');
    }
}

// Dynamic Series Management Functions
function initializeSeriesContainer() {
    const seriesContainer = document.querySelector('.series-container');
    if (!seriesContainer) return;
    
    // Clear existing content
    seriesContainer.innerHTML = '';
    
    // Add initial series
    activeSeries = [];
    addNewSeries();
    
    // Add the "Add Series" button
    updateAddSeriesButton();
}

function addNewSeries() {
    if (activeSeries.length >= maxSeries) {
        updateImportStatus(`Maximum of ${maxSeries} series allowed`, 'warning');
        return;
    }
    
    const seriesId = Date.now() + Math.random();
    const seriesIndex = activeSeries.length;
    const seriesColor = seriesColors[seriesIndex];
    
    const series = {
        id: seriesId,
        index: seriesIndex,
        unit: '',
        point: '',
        color: seriesColor,
        label: `Series ${seriesIndex + 1}`
    };
    
    activeSeries.push(series);
    
    const seriesContainer = document.querySelector('.series-container');
    const seriesDiv = createSeriesControls(series);
    
    // Insert before the add button (if it exists)
    const addButton = document.getElementById('addSeriesButton');
    if (addButton) {
        seriesContainer.insertBefore(seriesDiv, addButton);
    } else {
        seriesContainer.appendChild(seriesDiv);
    }
    
    updateAddSeriesButton();
    updateAllSeriesSelectors();
}

function createSeriesControls(series) {
    const seriesDiv = document.createElement('div');
    seriesDiv.className = 'series-controls';
    seriesDiv.id = `series-${series.id}`;
    seriesDiv.style.cssText = `
        flex: 1;
        border: 2px solid ${series.color};
        border-radius: 8px;
        padding: 15px;
        margin: 5px;
        background: rgba(255, 255, 255, 0.05);
        position: relative;
    `;
    
    const isFirstSeries = series.index === 0;
    const seriesTitle = isFirstSeries ? 'Primary Series' : `Series ${series.index + 1}`;
    const unitPlaceholder = isFirstSeries ? 'Select Unit...' : 'Select Unit (Optional)...';
    const pointPlaceholder = isFirstSeries ? 'Select Point...' : 'Select Point (Optional)...';
    
    seriesDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0; color: ${series.color};">${seriesTitle}</h4>
            ${!isFirstSeries ? `<button onclick="removeSeries('${series.id}')" style="
                background: #e74c3c;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 4px 8px;
                cursor: pointer;
                font-size: 12px;
            ">Remove</button>` : ''}
        </div>
        <div class="control-row" style="display: flex; gap: 10px;">
            <div class="control-group" style="flex: 1;">
                <label class="control-label">Unit:</label>
                <select id="unitSelector-${series.id}" onchange="updatePointSelector('${series.id}'); updateSeriesData('${series.id}'); updateGraph()">
                    <option value="">${unitPlaceholder}</option>
                </select>
            </div>
            <div class="control-group" style="flex: 1;">
                <label class="control-label">Point:</label>
                <select id="pointSelector-${series.id}" onchange="updateSeriesData('${series.id}'); updateGraph()">
                    <option value="">${pointPlaceholder}</option>
                </select>
            </div>
        </div>
    `;
    
    return seriesDiv;
}

function removeSeries(seriesId) {
    // Find and remove the series
    const seriesIndex = activeSeries.findIndex(s => s.id == seriesId);
    if (seriesIndex === -1) return;
    
    // Don't allow removing the first series
    if (seriesIndex === 0) {
        updateImportStatus('Cannot remove the primary series', 'warning');
        return;
    }
    
    // Remove from active series
    activeSeries.splice(seriesIndex, 1);
    
    // Remove the DOM element
    const seriesElement = document.getElementById(`series-${seriesId}`);
    if (seriesElement) {
        seriesElement.remove();
    }
    
    // Update indices and colors for remaining series
    activeSeries.forEach((series, index) => {
        series.index = index;
        series.color = seriesColors[index];
        series.label = index === 0 ? 'Primary Series' : `Series ${index + 1}`;
        
        // Update the visual styling
        const seriesElement = document.getElementById(`series-${series.id}`);
        if (seriesElement) {
            seriesElement.style.borderColor = series.color;
            const title = seriesElement.querySelector('h4');
            if (title) {
                title.textContent = series.label;
                title.style.color = series.color;
            }
        }
    });
    
    updateAddSeriesButton();
    updateGraph();
}

function updateAddSeriesButton() {
    const seriesContainer = document.querySelector('.series-container');
    if (!seriesContainer) return;
    
    // Remove existing add button
    const existingButton = document.getElementById('addSeriesButton');
    if (existingButton) {
        existingButton.remove();
    }
    
    // Add new add button if we haven't reached the max
    if (activeSeries.length < maxSeries) {
        const addButton = document.createElement('div');
        addButton.id = 'addSeriesButton';
        addButton.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 120px;
            border: 2px dashed #7f8c8d;
            border-radius: 8px;
            margin: 5px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.02);
            transition: all 0.3s;
            flex: 0 0 200px;
        `;
        
        addButton.innerHTML = `
            <div style="text-align: center; color: #7f8c8d;">
                <div style="font-size: 24px; margin-bottom: 5px;">+</div>
                <div style="font-size: 12px;">Add Series</div>
                <div style="font-size: 11px; opacity: 0.7;">(${activeSeries.length}/${maxSeries})</div>
            </div>
        `;
        
        addButton.addEventListener('mouseenter', function() {
            this.style.borderColor = '#3498db';
            this.style.background = 'rgba(52, 152, 219, 0.1)';
        });
        
        addButton.addEventListener('mouseleave', function() {
            this.style.borderColor = '#7f8c8d';
            this.style.background = 'rgba(255, 255, 255, 0.02)';
        });
        
        addButton.addEventListener('click', addNewSeries);
        
        seriesContainer.appendChild(addButton);
    }
}

function updateAllSeriesSelectors() {
    activeSeries.forEach(series => {
        populateUnitSelectorForSeries(series.id);
        updatePointSelector(series.id);
    });
}

function populateUnitSelectorForSeries(seriesId) {
    const unitSelector = document.getElementById(`unitSelector-${seriesId}`);
    if (!unitSelector) return;

    const currentValue = unitSelector.value; // Preserve current selection
    unitSelector.innerHTML = `<option value="">${activeSeries.find(s => s.id == seriesId).index === 0 ? 'Select Unit...' : 'Select Unit (Optional)...'}</option>`;

    let dataSource = [];
    
    if (importedJsonData && importedJsonData.eventLogs) {
        dataSource = importedJsonData.eventLogs;
    } else if (window.eventLogs && window.eventLogs.length > 0) {
        dataSource = window.eventLogs;
    }
    
    if (dataSource.length === 0) {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No data available - import JSON file or collect data';
        option.disabled = true;
        unitSelector.appendChild(option);
        return;
    }
    
    const uniqueUnits = [...new Set(dataSource.map(log => log.unit))].filter(unit => unit).sort();
    
    uniqueUnits.forEach(unit => {
        const option = document.createElement('option');
        option.value = unit;
        option.textContent = unit;
        if (unit === currentValue) {
            option.selected = true;
        }
        unitSelector.appendChild(option);
    });
}

function updatePointSelector(seriesId) {
    const unitSelector = document.getElementById(`unitSelector-${seriesId}`);
    const pointSelector = document.getElementById(`pointSelector-${seriesId}`);
    
    if (!unitSelector || !pointSelector) return;

    const selectedUnit = unitSelector.value;
    const currentValue = pointSelector.value; // Preserve current selection
    const isFirstSeries = activeSeries.find(s => s.id == seriesId).index === 0;
    pointSelector.innerHTML = `<option value="">${isFirstSeries ? 'Select Point...' : 'Select Point (Optional)...'}</option>`;

    if (selectedUnit) {
        let dataSource = [];
        
        if (importedJsonData && importedJsonData.eventLogs) {
            dataSource = importedJsonData.eventLogs;
        } else if (window.eventLogs && window.eventLogs.length > 0) {
            dataSource = window.eventLogs;
        }
        
        const uniquePoints = [...new Set(
            dataSource
                .filter(log => log.unit === selectedUnit)
                .map(log => log.pointName)
        )].sort();
        
        uniquePoints.forEach(point => {
            if (point) {
                const option = document.createElement('option');
                option.value = point;
                option.textContent = point;
                if (point === currentValue) {
                    option.selected = true;
                }
                pointSelector.appendChild(option);
            }
        });
    }
}

function updateSeriesData(seriesId) {
    const series = activeSeries.find(s => s.id == seriesId);
    if (!series) return;
    
    const unitSelector = document.getElementById(`unitSelector-${seriesId}`);
    const pointSelector = document.getElementById(`pointSelector-${seriesId}`);
    
    if (unitSelector && pointSelector) {
        series.unit = unitSelector.value;
        series.point = pointSelector.value;
    }
}

function updateGraph() {
    const timeRangeSelector = document.getElementById('timeRangeSelector');
    const timeRange = timeRangeSelector ? timeRangeSelector.value : 'all';
    
    // Update all series data
    activeSeries.forEach(series => {
        updateSeriesData(series.id);
    });
    
    // Check if at least the first series has data
    const firstSeries = activeSeries[0];
    if (!firstSeries || !firstSeries.unit || !firstSeries.point) {
        clearGraph();
        return;
    }

    drawMultiSeriesGraph(timeRange);
}

function drawMultiSeriesGraph(timeRange) {
    const canvas = document.getElementById('graphCanvas');
    const noDataMessage = document.getElementById('noDataMessage');
    
    if (!canvas) return;

    const selectedDate = getSelectedDate();
    if (!selectedDate) {
        clearGraph();
        return;
    }

    const ctx = canvas.getContext('2d');
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    // Clear previous data points array
    window.graphDataPoints = [];

    // Get data for all active series
    const allSeriesData = [];
    let hasAnyData = false;

    activeSeries.forEach((series, index) => {
        if (series.unit && series.point) {
            let seriesData = getFilteredEventLogsByDate(series.unit, series.point);
            
            // Apply time range filter
            if (timeRange !== 'all' && !isNaN(parseInt(timeRange))) {
                const minutesBack = parseInt(timeRange);
                const cutoffTime = new Date(selectedDate.endOfDay.getTime() - (minutesBack * 60 * 1000));
                
                seriesData = seriesData.filter(log => {
                    const logTime = log.timestampObj || new Date(log.timestamp);
                    return logTime >= cutoffTime;
                });
            }

            // Process data
            seriesData = seriesData.map(log => ({
                timestamp: log.timestampObj || new Date(log.timestamp),
                timestampString: log.timestamp,
                value: parseFloat(log.value),
                pointName: log.pointName,
                dataUnit: log.dataUnit || '',
                seriesIndex: index
            })).sort((a, b) => a.timestamp - b.timestamp);

            allSeriesData.push({
                series: series,
                data: seriesData
            });
            
            if (seriesData.length > 0) {
                hasAnyData = true;
            }
        }
    });

    if (!hasAnyData) {
        let message = 'No numerical data found for the selected series on ' + selectedDate.dateString;
        noDataMessage.textContent = message;
        noDataMessage.style.display = 'block';
        canvas.style.display = 'none';
        document.getElementById('graphLegend').innerHTML = '';
        document.getElementById('graphStats').innerHTML = '';
        return;
    }

    noDataMessage.style.display = 'none';
    canvas.style.display = 'block';

    // Calculate combined value range for Y-axis
    const allValues = [];
    allSeriesData.forEach(seriesData => {
        allValues.push(...seriesData.data.map(d => d.value));
    });
    
    const minValue = Math.min(...allValues);
    const maxValue = Math.max(...allValues);
    const valueRange = maxValue - minValue;
    const valuePadding = valueRange * 0.1;
    const adjustedMin = minValue - valuePadding;
    const adjustedMax = maxValue + valuePadding;

    // Draw graph background and axes
    drawGraphAxes(ctx, canvas.width, canvas.height, adjustedMin, adjustedMax, selectedDate);

    // Draw all series
    const startTimeMs = selectedDate.startOfDay.getTime();
    const timeRangeMs = selectedDate.endOfDay.getTime() - startTimeMs;
    const padding = 60;
    const graphWidth = canvas.width - (padding * 2);
    const graphHeight = canvas.height - (padding * 2);

    allSeriesData.forEach(({ series, data }) => {
        if (data.length === 0) return;
        
        // Draw line
        ctx.strokeStyle = series.color;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        ctx.beginPath();
        
        for (let i = 0; i < data.length; i++) {
            const entry = data[i];
            const x = padding + (graphWidth * (entry.timestamp.getTime() - startTimeMs) / timeRangeMs);
            const normalizedValue = (entry.value - adjustedMin) / (adjustedMax - adjustedMin);
            const y = padding + graphHeight - (graphHeight * normalizedValue);

            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.stroke();

        // Draw data points and store for click detection
        data.forEach((entry, dataIndex) => {
            const x = padding + (graphWidth * (entry.timestamp.getTime() - startTimeMs) / timeRangeMs);
            const normalizedValue = (entry.value - adjustedMin) / (adjustedMax - adjustedMin);
            const y = padding + graphHeight - (graphHeight * normalizedValue);
            
            // Store point data for click detection
            window.graphDataPoints.push({
                x: x,
                y: y,
                radius: 6,
                data: entry,
                index: dataIndex,
                series: series.index + 1,
                seriesName: series.label,
                seriesColor: series.color,
                seriesId: series.id
            });
            
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, 2 * Math.PI);
            ctx.fillStyle = series.color;
            ctx.fill();
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        });
    });

    // Add click event listener (only once)
    if (canvas && !canvas.hasClickListener) {
        canvas.hasClickListener = true;
        canvas.addEventListener('click', handleMultiSeriesGraphClick);
        canvas.style.cursor = 'pointer';
    }

    // Update legend and stats
    updateMultiSeriesLegend(allSeriesData);
    updateMultiSeriesStats(allSeriesData);
}

function drawGraphAxes(ctx, width, height, adjustedMin, adjustedMax, selectedDate) {
    const padding = 60;
    const graphWidth = width - (padding * 2);
    const graphHeight = height - (padding * 2);

    ctx.clearRect(0, 0, width, height);

    // Background
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-bg') || '#ffffff';
    ctx.fillRect(0, 0, width, height);

    // Grid
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border-color') || '#ddd';
    ctx.lineWidth = 0.5;
    ctx.setLineDash([2, 2]);

    for (let i = 0; i <= 10; i++) {
        const x = padding + (graphWidth * i / 10);
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, padding + graphHeight);
        ctx.stroke();
    }

    for (let i = 0; i <= 8; i++) {
        const y = padding + (graphHeight * i / 8);
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(padding + graphWidth, y);
        ctx.stroke();
    }

    ctx.setLineDash([]);

    // Axes
    const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color') || '#000000';
    ctx.strokeStyle = textColor;
    ctx.lineWidth = 2;
    ctx.font = '12px Segoe UI, sans-serif';
    ctx.fillStyle = textColor;

    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, padding + graphHeight);
    ctx.lineTo(padding + graphWidth, padding + graphHeight);
    ctx.stroke();

    // Y-axis labels
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    
    for (let i = 0; i <= 8; i++) {
        const value = adjustedMin + (adjustedMax - adjustedMin) * (1 - i / 8);
        const y = padding + (graphHeight * i / 8);
        ctx.fillText(value.toFixed(1), padding - 10, y);
    }

    // X-axis labels
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    
    const startTime = selectedDate.startOfDay;
    const timeLabels = [
        new Date(startTime.getTime()),
        new Date(startTime.getTime() + 4 * 60 * 60 * 1000),
        new Date(startTime.getTime() + 8 * 60 * 60 * 1000),
        new Date(startTime.getTime() + 12 * 60 * 60 * 1000),
        new Date(startTime.getTime() + 16 * 60 * 60 * 1000),
        new Date(startTime.getTime() + 20 * 60 * 60 * 1000),
        new Date(selectedDate.endOfDay.getTime())
    ];
    
    timeLabels.forEach((timePoint, i) => {
        const x = padding + (graphWidth * i / 6);
        const timeStr = timePoint.toLocaleTimeString('en-US', { 
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
        });
        ctx.fillText(timeStr, x, padding + graphHeight + 10);
    });

    // Axis titles
    ctx.font = 'bold 14px Segoe UI, sans-serif';
    ctx.save();
    ctx.translate(20, padding + graphHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Value', 0, 0);
    ctx.restore();
    
    ctx.fillText('Time', padding + graphWidth / 2, padding + graphHeight + 35);
}

function handleMultiSeriesGraphClick(event) {
    if (!window.graphDataPoints) return;
    
    const canvas = event.target;
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    // Check if click is near any data point
    for (let i = 0; i < window.graphDataPoints.length; i++) {
        const point = window.graphDataPoints[i];
        const distance = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
        
        if (distance <= point.radius) {
            showMultiSeriesDataPointTooltip(point, event.clientX, event.clientY);
            return;
        }
    }
    
    hideDataPointTooltip();
}

function showMultiSeriesDataPointTooltip(pointData, screenX, screenY) {
    hideDataPointTooltip();
    
    const tooltip = document.createElement('div');
    tooltip.id = 'dataPointTooltip';
    tooltip.style.cssText = `
        position: fixed;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-family: 'Segoe UI', sans-serif;
        font-size: 13px;
        z-index: 10001;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        border: 2px solid ${pointData.seriesColor};
        max-width: 280px;
        pointer-events: none;
    `;
    
    const timeStr = pointData.data.timestamp.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        second: '2-digit',
        hour12: true
    });
    
    tooltip.innerHTML = `
        <div style="font-weight: bold; color: ${pointData.seriesColor}; margin-bottom: 6px;">
            ${pointData.seriesName}
        </div>
        <div style="margin-bottom: 4px;">
            <strong>Value:</strong> ${pointData.data.value} ${pointData.data.dataUnit || ''}
        </div>
        <div style="margin-bottom: 4px;">
            <strong>Time:</strong> ${timeStr}
        </div>
        <div style="margin-bottom: 4px;">
            <strong>Point:</strong> ${pointData.data.pointName}
        </div>
        <div style="font-size: 11px; color: #bbb; margin-top: 8px;">
            Click elsewhere to close
        </div>
    `;
    
    document.body.appendChild(tooltip);
    
    // Position tooltip
    const tooltipRect = tooltip.getBoundingClientRect();
    let left = screenX + 15;
    let top = screenY - 15;
    
    if (left + tooltipRect.width > window.innerWidth) {
        left = screenX - tooltipRect.width - 15;
    }
    
    if (top < 0) {
        top = screenY + 15;
    }
    
    if (top + tooltipRect.height > window.innerHeight) {
        top = window.innerHeight - tooltipRect.height - 10;
    }
    
    tooltip.style.left = left + 'px';
    tooltip.style.top = top + 'px';
    
    setTimeout(() => {
        hideDataPointTooltip();
    }, 8000);
}

function updateMultiSeriesLegend(allSeriesData) {
    const graphLegend = document.getElementById('graphLegend');
    if (!graphLegend) return;

    let legendHtml = '';
    
    allSeriesData.forEach(({ series, data }) => {
        if (data.length > 0) {
            legendHtml += `
                <div class="legend-item">
                    <span class="legend-color" style="background-color: ${series.color};"></span>
                    <span class="legend-text">${series.unit} - ${series.point}</span>
                </div>
            `;
        }
    });
    
    graphLegend.innerHTML = legendHtml;
}

function updateMultiSeriesStats(allSeriesData) {
    const graphStats = document.getElementById('graphStats');
    if (!graphStats) return;

    let statsHtml = '';
    
    allSeriesData.forEach(({ series, data }) => {
        if (data.length > 0) {
            const values = data.map(d => d.value);
            const avg = values.reduce((sum, val) => sum + val, 0) / values.length;
            const min = Math.min(...values);
            const max = Math.max(...values);
            const current = values[values.length - 1];
            const unit = data[0].dataUnit || '';
            
            statsHtml += `
                <div class="stat-group" style="border-left: 4px solid ${series.color}; padding-left: 10px; margin-bottom: 15px;">
                    <div style="font-weight: bold; color: ${series.color}; margin-bottom: 8px;">${series.label}</div>
                    <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                        <div class="stat-card" style="min-width: 80px;">
                            <div class="stat-value" style="color: ${series.color};">${data.length}</div>
                            <div class="stat-label">Points</div>
                        </div>
                        <div class="stat-card" style="min-width: 80px;">
                            <div class="stat-value" style="color: ${series.color};">${avg.toFixed(2)} ${unit}</div>
                            <div class="stat-label">Average</div>
                        </div>
                        <div class="stat-card" style="min-width: 80px;">
                            <div class="stat-value" style="color: ${series.color};">${current.toFixed(2)} ${unit}</div>
                            <div class="stat-label">Current</div>
                        </div>
                        <div class="stat-card" style="min-width: 80px;">
                            <div class="stat-value" style="color: ${series.color};">${min.toFixed(2)} - ${max.toFixed(2)} ${unit}</div>
                            <div class="stat-label">Range</div>
                        </div>
                    </div>
                </div>
            `;
        }
    });
    
    graphStats.innerHTML = statsHtml;
}

function hideDataPointTooltip() {
    const existingTooltip = document.getElementById('dataPointTooltip');
    if (existingTooltip) {
        existingTooltip.remove();
    }
}

// Graph viewer functions
function toggleGraphViewer() {
    const graphViewer = document.getElementById('graphViewer');
    const mainView = document.getElementById('mainView');
    
    window.graphViewerActive = !window.graphViewerActive;

    if (window.graphViewerActive) {
        graphViewer.classList.add('active');
        mainView.classList.add('hidden');
        initializeGraphViewer();
    } else {
        graphViewer.classList.remove('active');
        mainView.classList.remove('hidden');
    }
}

function initializeGraphViewer() {
    initializeDateInput();
    initializeSeriesContainer();
    clearGraph();
}

function initializeDateInput() {
    const dateInput = document.getElementById('dateInput');
    if (dateInput) {
        const today = new Date().toISOString().split('T')[0];
        dateInput.value = today;
        dateInput.addEventListener('change', forceRefreshGraph);
    }
}

function getSelectedDate() {
    const dateInput = document.getElementById('dateInput');
    if (!dateInput || !dateInput.value) return null;
    
    const selectedDate = new Date(dateInput.value + 'T00:00:00.000');
    const startOfDay = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate(), 0, 0, 0, 0);
    const endOfDay = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate(), 23, 59, 59, 999);
    
    return {
        dateObject: selectedDate,
        dateString: dateInput.value,
        startOfDay: startOfDay,
        endOfDay: endOfDay
    };
}

function getFilteredEventLogsByDate(unit = null, point = null) {
    const selectedDate = getSelectedDate();
    if (!selectedDate) return [];
    
    let dataSource = [];
    
    if (importedJsonData && importedJsonData.eventLogs) {
        dataSource = importedJsonData.eventLogs;
    } else if (window.eventLogs && window.eventLogs.length > 0) {
        dataSource = window.eventLogs;
    }
    
    return dataSource.filter(log => {
        let logTimestamp;
        if (log.timestampObj) {
            logTimestamp = log.timestampObj;
        } else if (typeof log.timestamp === 'string') {
            logTimestamp = new Date(log.timestamp);
        } else if (log.timestamp instanceof Date) {
            logTimestamp = log.timestamp;
        } else {
            return false;
        }
        
        if (isNaN(logTimestamp.getTime())) return false;
        if (isNaN(log.value)) return false;
        
        const logDateString = logTimestamp.getFullYear() + '-' + 
                             String(logTimestamp.getMonth() + 1).padStart(2, '0') + '-' + 
                             String(logTimestamp.getDate()).padStart(2, '0');
        
        const matchesDate = logDateString === selectedDate.dateString;
        const matchesUnit = !unit || log.unit === unit;
        const matchesPoint = !point || log.pointName === point;
        
        return matchesDate && matchesUnit && matchesPoint;
    });
}

function validateImportedLogs(logs) {
    const validatedLogs = [];
    
    logs.forEach((log, index) => {
        try {
            if (!log.unit || !log.pointName || !log.timestamp || (log.value === undefined && log.value === null)) {
                console.warn(`Skipping log entry ${index}: missing required fields`, log);
                return;
            }
            
            let timestampObj;
            if (log.timestampObj && log.timestampObj instanceof Date) {
                timestampObj = log.timestampObj;
            } else if (typeof log.timestamp === 'string') {
                timestampObj = new Date(log.timestamp);
            } else if (log.timestamp instanceof Date) {
                timestampObj = log.timestamp;
            } else {
                console.warn(`Skipping log entry ${index}: invalid timestamp`, log);
                return;
            }
            
            if (isNaN(timestampObj.getTime())) {
                console.warn(`Skipping log entry ${index}: invalid timestamp format`, log);
                return;
            }
            
            const numericValue = parseFloat(log.value);
            if (isNaN(numericValue)) {
                console.warn(`Skipping log entry ${index}: non-numeric value`, log);
                return;
            }
            
            validatedLogs.push({
                id: log.id || index,
                timestamp: timestampObj.toLocaleString(),
                timestampObj: timestampObj,
                unit: log.unit.toString(),
                pointName: log.pointName.toString(),
                pointId: log.pointId || log.id || '',
                value: numericValue,
                dataUnit: log.dataUnit || log.unit || '',
                fullPath: log.fullPath || '',
                displayName: `${log.unit} - ${log.pointName}`,
                details: `${log.pointName} = ${numericValue} ${log.dataUnit || ''}`
            });
            
        } catch (error) {
            console.warn(`Error processing log entry ${index}:`, error, log);
        }
    });
    
    return validatedLogs;
}

function updateImportStatus(message, type = 'info') {
    const statusElement = document.getElementById('importStatus');
    if (!statusElement) return;
    
    statusElement.textContent = message;
    statusElement.className = `import-status import-${type}`;
    
    if (type === 'success') {
        setTimeout(() => {
            if (statusElement.textContent === message) {
                statusElement.textContent = '';
                statusElement.className = 'import-status';
            }
        }, 10000);
    }
}

function clearGraph() {
    const canvas = document.getElementById('graphCanvas');
    const noDataMessage = document.getElementById('noDataMessage');
    const graphLegend = document.getElementById('graphLegend');
    const graphStats = document.getElementById('graphStats');
    
    if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.style.display = 'none';
    }
    
    if (noDataMessage) {
        noDataMessage.textContent = 'Select a unit and point to view numerical graph data.';
        noDataMessage.style.display = 'block';
    }
    
    if (graphLegend) graphLegend.innerHTML = '';
    if (graphStats) graphStats.innerHTML = '';
    
    window.graphDataPoints = [];
    hideDataPointTooltip();
}

function forceRefreshGraph() {
    updateGraph();
}

// Add click handler to document to hide tooltip when clicking elsewhere
document.addEventListener('click', function(event) {
    const canvas = document.getElementById('graphCanvas');
    if (event.target !== canvas) {
        hideDataPointTooltip();
    }
});

// Helper function to clear file history (for testing/debugging)
function clearFileHistory() {
    fileHistory = [];
    updateFileHistoryDisplay();
    console.log('File history cleared');
}

// Keyboard shortcut to clear history (Ctrl+Shift+C)
document.addEventListener('keydown', function(e) {
    if (e.ctrlKey && e.shiftKey && e.code === 'KeyC') {
        clearFileHistory();
    }
});

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    updateFileHistoryDisplay();
});

        function showNotification(title, message, type = 'info') {
            const notification = document.createElement('div');
            const colors = {
                success: '#27ae60',
                error: '#e74c3c',
                info: '#3498db',
                warning: '#f39c12'
            };
            
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${colors[type] || colors.info};
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 10000;
                max-width: 300px;
                font-family: 'Segoe UI', sans-serif;
                font-size: 14px;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
            `;
            
            notification.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 5px;">${title}</div>
                <div>${message}</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 5000);
        }

        // Dark mode toggle
        function initializeDarkMode() {
            const toggleSwitch = document.getElementById('toggleSwitch');
            const toggleLabel = document.querySelector('.toggle-label');
            
            // For browser compatibility, we'll use a simple flag instead of localStorage
            const currentTheme = 'light'; // Default to light mode
            document.documentElement.setAttribute('data-theme', currentTheme);
            
            toggleLabel.textContent = 'Light Mode';
            
            toggleSwitch.addEventListener('click', function() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                document.documentElement.setAttribute('data-theme', newTheme);
                
                if (newTheme === 'dark') {
                    toggleSwitch.classList.add('active');
                    toggleLabel.textContent = 'Dark Mode';
                } else {
                    toggleSwitch.classList.remove('active');
                    toggleLabel.textContent = 'Light Mode';
                }
                
                if (graphViewerActive) {
                    updateGraph();
                }
            });
        }

        // Initialize everything when DOM loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeSystem();
            initializeDarkMode();
            
            console.log('Niagara Numerical System Monitor ready!');
            console.log('Features: Global.json monitoring, real-time data collection, JSON export, graphing, dark mode');
        });

        // Resize handling
        window.addEventListener('resize', function() {
            if (graphViewerActive) {
                setTimeout(updateGraph, 100);
            }
        });
    </script>
</body>
</html>