<!DOCTYPE html>
<!-- @noSnoop -->
<html lang="en" xmlns:b="http://www.tridium.com/baja/baja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Murphy Control Panel - AHU Monitoring</title>

<!-- Add RequireJS and BajaScript Support -->
<script type='text/javascript' src='/requirejs/config.js'></script>
<script type='text/javascript' src='/module/js/com/tridium/js/ext/require/require.min.js?'></script>

<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --success-color: #27ae60;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --info-color: #17a2b8;
            --light-color: #ecf0f1;
            --dark-color: #34495e;
            --text-color: #2c3e50;
            --bg-color: #ffffff;
            --card-bg: #ffffff;
            --border-color: #bdc3c7;
        }

        [data-theme="dark"] {
            --text-color: #ecf0f1;
            --bg-color: #1a1a1a;
            --card-bg: #2c2c2c;
            --border-color: #444444;
            --primary-color: #3498db;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg-color) 0%, var(--light-color) 100%);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
            transition: all 0.3s ease;
        }

        [data-theme="dark"] body {
            background: linear-gradient(135deg, #1a1a1a 0%, #2c2c2c 100%);
        }

        .toggle-container {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            background: var(--card-bg);
            padding: 10px 15px;
            border-radius: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .toggle-label {
            font-size: 14px;
            font-weight: 500;
        }

        .toggle-switch {
            width: 50px;
            height: 25px;
            background: var(--border-color);
            border-radius: 25px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .toggle-switch.active {
            background: var(--primary-color);
        }

        .toggle-slider {
            width: 21px;
            height: 21px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(25px);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: var(--card-bg);
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .header h1 {
            color: var(--primary-color);
            margin-bottom: 10px;
            font-size: 2.5rem;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            min-width: 120px;
        }

        .btn-success { background: var(--success-color); color: white; }
        .btn-danger { background: var(--danger-color); color: white; }
        .btn-info { background: var(--info-color); color: white; }
        .btn-primary { background: var(--primary-color); color: white; }
        .btn-secondary { background: var(--dark-color); color: white; }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .monitoring-status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 18px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .monitoring-active {
            background: var(--success-color);
            color: white;
            animation: pulse 2s infinite;
        }

        .monitoring-inactive {
            background: var(--danger-color);
            color: white;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .bubbleSP {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border-left: 5px solid var(--primary-color);
            transition: all 0.3s ease;
        }

        .bubbleSP:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .point-status {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
        }

        .status-ok {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
        }

        .status-error {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .status-display {
            background: var(--card-bg);
            color: var(--text-color);
            border: 2px solid var(--border-color);
        }

        .status-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .status-details p {
            margin-bottom: 5px;
            font-size: 14px;
        }

        .overall-summary {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border-left: 5px solid var(--success-color);
        }

        /* Graph Viewer Styles */
        .graph-viewer {
            display: none;
            background: var(--card-bg);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .graph-viewer.active {
            display: block;
        }

        .graph-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .unit-selector, .point-selector {
            padding: 10px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: var(--card-bg);
            color: var(--text-color);
            font-size: 14px;
            min-width: 150px;
        }

        .time-range-selector {
            padding: 10px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: var(--card-bg);
            color: var(--text-color);
            font-size: 14px;
        }

        .graph-container {
            width: 100%;
            height: 400px;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            background: var(--card-bg);
            position: relative;
            overflow: hidden;
        }

        .graph-canvas {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .graph-title {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: var(--primary-color);
        }

        .graph-legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        .no-data-message {
            text-align: center;
            color: var(--text-color);
            font-size: 16px;
            margin-top: 50px;
        }

        .graph-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .stat-label {
            font-size: 14px;
            color: var(--text-color);
            margin-top: 5px;
        }

        .main-view {
            display: block;
        }

        .main-view.hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .controls {
                justify-content: center;
            }
            
            .btn {
                min-width: 100px;
                font-size: 14px;
                padding: 10px 20px;
            }
            
            .graph-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .unit-selector, .point-selector, .time-range-selector {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="main-content">
        <!-- Toggle Switch -->
        <div class="toggle-container">
            <span class="toggle-label">Light Mode</span>
            <div class="toggle-switch" id="toggleSwitch">
                <div class="toggle-slider"></div>
            </div>
        </div>

        <div class="container">
            <div class="header">
                <h1>üè¢ Niagara System Monitor</h1>
                <p id="currentDateTime"></p>
            </div>
            
            <div class="controls">
                <button class="btn btn-success" onclick="startMonitoring()">‚ñ∂Ô∏è Start Monitoring</button>
                <button class="btn btn-danger" onclick="stopMonitoring()">‚èπÔ∏è Stop Monitoring</button>
                <button class="btn btn-info" onclick="exportLogs()">üì§ Export Logs</button>
                <button class="btn btn-danger" onclick="clearLogs()">üóëÔ∏è Clear Logs</button>
                <button class="btn btn-primary" onclick="toggleGraphViewer()">üìä View Graphs</button>
            </div>
            
            <div id="monitoringStatus" class="monitoring-status monitoring-active">MONITORING ACTIVE</div>
            
            
            <!-- Graph Viewer Section -->
            <div id="graphViewer" class="graph-viewer">
                <div class="graph-title">üìä System Data Visualization</div>
                
                <div class="graph-controls">
                  
                  <!--POINTS-->
                    <select id="unitSelector" class="unit-selector" onchange="updatePointSelector()">
                        <option value="">Select Unit...</option>
                    </select>
                    
                    <select id="pointSelector" class="point-selector" onchange="updateGraph()">
                        <option value="">Select Point...</option>
                    </select>
                    
                    
                    <!--<select id="timeRangeSelector" class="time-range-selector" onchange="updateGraph()">-->
                    <!--    <option value="60">Last Hour</option>-->
                    <!--    <option value="360">Last 6 Hours</option>-->
                    <!--    <option value="1440">Last 24 Hours</option>-->
                    <!--    <option value="all">All Data</option>-->
                    <!--</select>-->
                    
                    <div class="control-group">
    <label for="timeRangeSelector" class="control-label">Time Range:    </label>

    <select id="timeRangeSelector" class="unit-selector" onchange="updateGraph()">
        <option value="all">All Data (Selected Date)</option>
        <option value="60">Last Hour (of Selected Date)</option>
        <option value="180">Last 3 Hours (of Selected Date)</option>
        <option value="360">Last 6 Hours (of Selected Date)</option>
        <option value="720">Last 12 Hours (of Selected Date)</option>
    </select>
</div>
                    
                <div class="control-group">
                    <label for="numeric-input" class="control-label">Select Date:</label>
                    <input type="date" id="numeric-input" class="unit-selector" title="Select date to filter data">
                </div>
                <button class="btn btn-secondary" onclick="toggleGraphViewer()">‚Üê Back to Logs</button>
                </div>
                
                <div class="graph-container">
                    <canvas id="graphCanvas" class="graph-canvas"></canvas>
                    <div id="noDataMessage" class="no-data-message" style="display: none;">
                        No data available for the selected point and time range.
                    </div>
                </div>
                
                <div class="graph-legend" id="graphLegend"></div>
                
                <div class="graph-stats" id="graphStats"></div>
            </div>
            
            <!-- Main View Section -->
            <div id="mainView" class="main-view">
                <div id="system-status"></div>
                
                <h3>üìã Event Logs (State Changes Only)</h3>
                <div id="eventLogs"></div>
            </div>
        </div>
        
        </div>
        
  
  
  
  
  
  
  
        
<!--LOGGING SCRIPT-->
    <script>
 // FIXED PERSISTENT DATA STORAGE USING INDEXEDDB
class PersistentStorage {
    constructor() {
        this.dbName = 'NiagaraLoggingDB';
        this.dbVersion = 1;
        this.db = null;
        this.initialized = false;
    }

    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);
            
            request.onerror = () => {
                console.error('Failed to open IndexedDB:', request.error);
                reject(request.error);
            };
            
            request.onsuccess = () => {
                this.db = request.result;
                this.initialized = true;
                console.log('‚úÖ IndexedDB initialized successfully');
                resolve();
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // Create stores if they don't exist
                if (!db.objectStoreNames.contains('eventLogs')) {
                    const eventStore = db.createObjectStore('eventLogs', { keyPath: 'id' });
                    eventStore.createIndex('timestamp', 'timestamp', { unique: false });
                    eventStore.createIndex('unit', 'unit', { unique: false });
                }
                
                if (!db.objectStoreNames.contains('unitStates')) {
                    db.createObjectStore('unitStates', { keyPath: 'id' });
                }
                
                if (!db.objectStoreNames.contains('unitHistory')) {
                    db.createObjectStore('unitHistory', { keyPath: 'id' });
                }
                
                if (!db.objectStoreNames.contains('systemConfig')) {
                    db.createObjectStore('systemConfig', { keyPath: 'key' });
                }
                
                console.log('üì¶ IndexedDB structure created');
            };
        });
    }

    async saveEventLogs(logs) {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['eventLogs'], 'readwrite');
            const store = transaction.objectStore('eventLogs');
            
            transaction.oncomplete = () => {
                console.log(`üíæ Saved ${logs.length} event logs to IndexedDB`);
                resolve();
            };
            
            transaction.onerror = (event) => {
                const error = transaction.error || event.target.error || new Error('Transaction failed');
                console.error('Failed to save event logs:', error);
                reject(error);
            };
            
            // Clear existing logs first and wait for completion
            const clearRequest = store.clear();
            clearRequest.onsuccess = () => {
                // Use put instead of add to handle potential duplicates
                try {
                    logs.forEach((log, index) => {
                        // Ensure each log has a unique ID
                        const logWithId = { ...log, id: log.id || (Date.now() + index) };
                        const putRequest = store.put(logWithId);
                        
                        putRequest.onerror = (event) => {
                            console.error(`Failed to save log ${index}:`, event.target.error);
                        };
                    });
                } catch (error) {
                    console.error('Error in saveEventLogs forEach:', error);
                    reject(error);
                }
            };
            
            clearRequest.onerror = (event) => {
                const error = clearRequest.error || event.target.error || new Error('Clear operation failed');
                console.error('Failed to clear event logs:', error);
                reject(error);
            };
        });
    }

    async loadEventLogs() {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['eventLogs'], 'readonly');
            const store = transaction.objectStore('eventLogs');
            const request = store.getAll();
            
            request.onsuccess = () => {
                const logs = request.result.sort((a, b) => b.id - a.id); // Sort by ID descending
                console.log(`üìñ Loaded ${logs.length} event logs from IndexedDB`);
                resolve(logs);
            };
            
            request.onerror = (event) => {
                const error = request.error || event.target.error || new Error('Load operation failed');
                console.error('Failed to load event logs:', error);
                reject(error);
            };
        });
    }

    async saveUnitStates(states) {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['unitStates'], 'readwrite');
            const store = transaction.objectStore('unitStates');
            
            transaction.oncomplete = () => {
                console.log(`üíæ Saved ${Object.keys(states).length} unit states to IndexedDB`);
                resolve();
            };
            
            transaction.onerror = (event) => {
                const error = transaction.error || event.target.error || new Error('Transaction failed');
                console.error('Failed to save unit states:', error);
                reject(error);
            };
            
            const clearRequest = store.clear();
            clearRequest.onsuccess = () => {
                try {
                    Object.entries(states).forEach(([unit, state]) => {
                        const putRequest = store.put({ id: unit, state: state });
                        putRequest.onerror = (event) => {
                            console.error(`Failed to save state for ${unit}:`, event.target.error);
                        };
                    });
                } catch (error) {
                    console.error('Error in saveUnitStates forEach:', error);
                    reject(error);
                }
            };
            
            clearRequest.onerror = (event) => {
                const error = clearRequest.error || event.target.error || new Error('Clear operation failed');
                console.error('Failed to clear unit states:', error);
                reject(error);
            };
        });
    }

    async loadUnitStates() {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['unitStates'], 'readonly');
            const store = transaction.objectStore('unitStates');
            const request = store.getAll();
            
            request.onsuccess = () => {
                const states = {};
                request.result.forEach(item => {
                    states[item.id] = item.state;
                });
                console.log(`üìñ Loaded ${Object.keys(states).length} unit states from IndexedDB`);
                resolve(states);
            };
            
            request.onerror = (event) => {
                const error = request.error || event.target.error || new Error('Load operation failed');
                console.error('Failed to load unit states:', error);
                reject(error);
            };
        });
    }

    async saveLastKnownStates(states) {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['systemConfig'], 'readwrite');
            const store = transaction.objectStore('systemConfig');
            
            transaction.oncomplete = () => {
                console.log(`üíæ Saved ${Object.keys(states).length} last known states to IndexedDB`);
                resolve();
            };
            
            transaction.onerror = (event) => {
                const error = transaction.error || event.target.error || new Error('Transaction failed');
                console.error('Failed to save last known states:', error);
                reject(error);
            };
            
            const putRequest = store.put({
                key: 'lastKnownStates',
                value: states,
                timestamp: new Date().toISOString()
            });
            
            putRequest.onerror = (event) => {
                const error = putRequest.error || event.target.error || new Error('Put operation failed');
                console.error('Failed to put last known states:', error);
                reject(error);
            };
        });
    }

    async loadLastKnownStates() {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['systemConfig'], 'readonly');
            const store = transaction.objectStore('systemConfig');
            const request = store.get('lastKnownStates');
            
            request.onsuccess = () => {
                const result = request.result;
                if (result && result.value) {
                    console.log(`üìñ Loaded ${Object.keys(result.value).length} last known states from IndexedDB`);
                    resolve(result.value);
                } else {
                    console.log('üìñ No saved last known states found');
                    resolve({});
                }
            };
            
            request.onerror = (event) => {
                const error = request.error || event.target.error || new Error('Load operation failed');
                console.error('Failed to load last known states:', error);
                reject(error);
            };
        });
    }

    async saveSystemConfig(config) {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['systemConfig'], 'readwrite');
            const store = transaction.objectStore('systemConfig');
            
            transaction.oncomplete = () => {
                console.log('üíæ Saved system configuration to IndexedDB');
                resolve();
            };
            
            transaction.onerror = (event) => {
                const error = transaction.error || event.target.error || new Error('Transaction failed');
                console.error('Failed to save system config:', error);
                reject(error);
            };
            
            try {
                Object.entries(config).forEach(([key, value]) => {
                    const putRequest = store.put({
                        key: key,
                        value: value,
                        timestamp: new Date().toISOString()
                    });
                    
                    putRequest.onerror = (event) => {
                        console.error(`Failed to save config ${key}:`, event.target.error);
                    };
                });
            } catch (error) {
                console.error('Error in saveSystemConfig forEach:', error);
                reject(error);
            }
        });
    }

    async loadSystemConfig() {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['systemConfig'], 'readonly');
            const store = transaction.objectStore('systemConfig');
            const request = store.getAll();
            
            request.onsuccess = () => {
                const config = {};
                request.result.forEach(item => {
                    if (item.key !== 'lastKnownStates') { // Skip this as it's handled separately
                        config[item.key] = item.value;
                    }
                });
                console.log('üìñ Loaded system configuration from IndexedDB');
                resolve(config);
            };
            
            request.onerror = (event) => {
                const error = request.error || event.target.error || new Error('Load operation failed');
                console.error('Failed to load system config:', error);
                reject(error);
            };
        });
    }

    async clearAllData() {
        if (!this.initialized) await this.init();
        
        return new Promise((resolve, reject) => {
            const stores = ['eventLogs', 'unitStates', 'unitHistory', 'systemConfig'];
            const transaction = this.db.transaction(stores, 'readwrite');
            
            transaction.oncomplete = () => {
                console.log('üóëÔ∏è Cleared all persistent data from IndexedDB');
                resolve();
            };
            
            transaction.onerror = (event) => {
                const error = transaction.error || event.target.error || new Error('Transaction failed');
                console.error('Failed to clear data:', error);
                reject(error);
            };
            
            try {
                stores.forEach(storeName => {
                    const clearRequest = transaction.objectStore(storeName).clear();
                    clearRequest.onerror = (event) => {
                        console.error(`Failed to clear store ${storeName}:`, event.target.error);
                    };
                });
            } catch (error) {
                console.error('Error in clearAllData forEach:', error);
                reject(error);
            }
        });
    }
}












        // Initialize persistent storage
        const persistentStorage = new PersistentStorage();

        // GLOBAL DATA ACCESS - Expose data to other documents
        if (!window.NiagaraGlobalData) {
            window.NiagaraGlobalData = {
                // Current states of all units
                unitStates: {},
                
                // Historical data for graphing (timestamped values)
                unitHistory: {},
                
                // Metadata about units
                unitMetadata: {},
                
                // Get current state of a specific unit
                getUnitState: function(unitName) {
                    return this.unitStates[unitName] || null;
                },
                
                // Get historical data for a unit (for graphing)
                getUnitHistory: function(unitName, maxEntries = 100) {
                    const history = this.unitHistory[unitName] || [];
                    return history.slice(-maxEntries); // Return last N entries
                },
                
                // Get all unit names
                getAllUnits: function() {
                    return Object.keys(this.unitStates);
                },
                
                // Get units by type (AHU, VAV, etc.)
                getUnitsByType: function(type) {
                    return Object.keys(this.unitStates).filter(unit => unit.startsWith(type));
                },
                
                // Subscribe to unit changes (callback when unit state changes)
                subscribers: [],
                subscribe: function(callback) {
                    this.subscribers.push(callback);
                },
                
                // Internal method to notify subscribers
                _notifySubscribers: function(unitName, oldState, newState, timestamp) {
                    this.subscribers.forEach(callback => {
                        try {
                            callback(unitName, oldState, newState, timestamp);
                        } catch (e) {
                            console.error('Error in subscriber callback:', e);
                        }
                    });
                }
            };
        }

        // Reference to global data for easier access
        const GlobalData = window.NiagaraGlobalData;

        // Global variables for logging functionality
        let eventLogs = [];
        let logCounter = 0;
        let monitoringActive = true;
        let startTime = new Date();
        let selectedDate = null;

        
        // Store last known states to detect changes
        let lastKnownStates = {};
        
        // Graph viewer state
        let graphViewerActive = false;
        
        // Monitor points array (will be populated when require callback runs)
        let monitorPoints = [];

        // AUTO-SAVE FUNCTIONALITY
        let autoSaveInterval;
        const AUTO_SAVE_INTERVAL = 30000; // Save every 30 seconds

        function startAutoSave() {
            autoSaveInterval = setInterval(async () => {
                try {
                    await saveAllDataToPersistentStorage();
                    console.log('üîÑ Auto-save completed');
                } catch (error) {
                    console.error('‚ùå Auto-save failed:', error);
                }
            }, AUTO_SAVE_INTERVAL);
            
            console.log(`‚è∞ Auto-save started (every ${AUTO_SAVE_INTERVAL/1000} seconds)`);
        }

        function stopAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
                console.log('‚è∞ Auto-save stopped');
            }
        }

        // SAVE DATA TO PERSISTENT STORAGE
        async function saveAllDataToPersistentStorage() {
            try {
                console.log('üíæ Starting save operation...');
                
                // Save event logs
                if (eventLogs && eventLogs.length > 0) {
                    await persistentStorage.saveEventLogs(eventLogs);
                }
                
                // Save unit states
                if (GlobalData.unitStates && Object.keys(GlobalData.unitStates).length > 0) {
                    await persistentStorage.saveUnitStates(GlobalData.unitStates);
                }
                
                // Save last known states
                if (lastKnownStates && Object.keys(lastKnownStates).length > 0) {
                    await persistentStorage.saveLastKnownStates(lastKnownStates);
                }
                
                // Save system configuration
                await persistentStorage.saveSystemConfig({
                    logCounter: logCounter,
                    monitoringActive: monitoringActive,
                    startTime: startTime.toISOString(),
                    totalPoints: monitorPoints ? monitorPoints.length : 0
                });
                
                // Update UI to show last save time
                updateLastSaveTime();
                
                console.log('‚úÖ All data saved successfully');
                
            } catch (error) {
                console.error('‚ùå Failed to save data to persistent storage:', error);
                throw error;
            }
        }

        // LOAD DATA FROM PERSISTENT STORAGE
        async function loadAllDataFromPersistentStorage() {
            try {
                console.log('üìñ Loading data from persistent storage...');
                
                // Load event logs
                const savedLogs = await persistentStorage.loadEventLogs();
                if (savedLogs && savedLogs.length > 0) {
                    eventLogs = savedLogs;
                    console.log(`‚úÖ Restored ${eventLogs.length} event logs`);
                }
                
                // Load unit states
                const savedUnitStates = await persistentStorage.loadUnitStates();
                if (savedUnitStates && Object.keys(savedUnitStates).length > 0) {
                    GlobalData.unitStates = savedUnitStates;
                    console.log(`‚úÖ Restored ${Object.keys(savedUnitStates).length} unit states`);
                }
                
                // Load last known states
                const savedLastKnown = await persistentStorage.loadLastKnownStates();
                if (savedLastKnown && Object.keys(savedLastKnown).length > 0) {
                    lastKnownStates = savedLastKnown;
                    console.log(`‚úÖ Restored ${Object.keys(savedLastKnown).length} last known states`);
                }
                
                // Load system configuration
                const savedConfig = await persistentStorage.loadSystemConfig();
                if (savedConfig) {
                    if (savedConfig.logCounter) logCounter = savedConfig.logCounter;
                    if (savedConfig.monitoringActive !== undefined) monitoringActive = savedConfig.monitoringActive;
                    if (savedConfig.startTime) startTime = new Date(savedConfig.startTime);
                    console.log('‚úÖ Restored system configuration');
                }
                
                // Update UI
                updateEventLogs();
                updateMonitoringStatus();
                updateLastSaveTime();
                
                console.log('üéâ All data successfully restored from persistent storage');
                
                // Show restoration notification
                showNotification('Data Restored', `Restored ${eventLogs.length} logs and ${Object.keys(lastKnownStates).length} states from previous session`, 'success');
                
            } catch (error) {
                console.error('‚ùå Failed to load data from persistent storage:', error);
                showNotification('Load Failed', 'Could not restore previous session data', 'error');
            }
        }

        
        
        
        function convertToCSV(data) {
    if (!data || data.length === 0) return '';

    // Define CSV headers
    const headers = [
        // 'Log ID',
        'Unit',
        'Timestamp',
        // 'Unit',
        'Point Name',
        // 'Display Name',
        'Value',
        // 'State Change',
        // 'Details'
    ];

    // Sort data by Unit, then Point Name, then Timestamp (optional)
    // data.sort((a, b) => {
    //     if (a.unit !== b.unit) return a.unit.localeCompare(b.unit);
    //     if (a.pointName !== b.pointName) return a.pointName.localeCompare(b.pointName);
    //     return new Date(a.timestamp) - new Date(b.timestamp); // optional
    // });
    
    data.sort((a, b) => {
    const unitA = String(a.unit);
    const unitB = String(b.unit);
    const pointA = String(a.pointName);
    const pointB = String(b.pointName);

    if (unitA !== unitB) return unitA.localeCompare(unitB);
    if (pointA !== pointB) return pointA.localeCompare(pointB);
    return new Date(a.timestamp) - new Date(b.timestamp); // optional
});


    const csvRows = [headers.join(',')];
    let previousUnit = null;

    data.forEach(log => {
        // Insert a blank row when unit changes
        if (previousUnit !== null && log.unit !== previousUnit) {
            csvRows.push('');
        }

        const row = [
            log.unit || '',
            // log.id || '',
            `"${log.timestamp || ''}"`,
            // log.unit || '',
            log.pointName || '',
            // `"${log.displayName || log.systemName || ''}"`,
            log.value ? 'TRUE' : 'FALSE',
            // log.isStateChange ? 'YES' : 'NO',
            // `"${log.details || ''}"`
        ].join(',');

        csvRows.push(row);
        previousUnit = log.unit;
    });

    return csvRows.join('\n');
}


        // UPDATE LAST SAVE TIME DISPLAY
        function updateLastSaveTime() {
            const saveTimeElement = document.getElementById('lastSaveTime');
            if (saveTimeElement) {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                saveTimeElement.textContent = `Last saved: ${timeString}`;
                saveTimeElement.style.color = '#4CAF50';
                
                // Fade the color back to normal after 2 seconds
                setTimeout(() => {
                    saveTimeElement.style.color = '#666';
                }, 2000);
            }
        }

        // SHOW NOTIFICATION
        function showNotification(title, message, type = 'info') {
            // Create notification element if it doesn't exist
            let notificationContainer = document.getElementById('notificationContainer');
            if (!notificationContainer) {
                notificationContainer = document.createElement('div');
                notificationContainer.id = 'notificationContainer';
                notificationContainer.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 10000;
                    max-width: 300px;
                `;
                document.body.appendChild(notificationContainer);
            }
            
            const notification = document.createElement('div');
            const typeColors = {
                success: '#4CAF50',
                error: '#f44336',
                info: '#2196F3',
                warning: '#ff9800'
            };
            
            notification.style.cssText = `
                background: ${typeColors[type] || typeColors.info};
                color: white;
                padding: 12px 16px;
                margin-bottom: 10px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                font-family: Arial, sans-serif;
                font-size: 14px;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
            `;
            
            notification.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 4px;">${title}</div>
                <div style="font-size: 12px; opacity: 0.9;">${message}</div>
            `;
            
            notificationContainer.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 5000);
        }

        // HANDLE PAGE VISIBILITY CHANGES (save when page becomes hidden)
        document.addEventListener('visibilitychange', async () => {
            if (document.hidden) {
                console.log('üìÑ Page became hidden - saving data...');
                try {
                    await saveAllDataToPersistentStorage();
                    console.log('‚úÖ Data saved before page hidden');
                } catch (error) {
                    console.error('‚ùå Failed to save data before page hidden:', error);
                }
            }
        });

        // HANDLE PAGE UNLOAD (save before leaving)
        window.addEventListener('beforeunload', async (event) => {
            console.log('üö™ Page unloading - attempting to save data...');
            try {
                // Synchronous save attempt for beforeunload
                await saveAllDataToPersistentStorage();
                console.log('‚úÖ Data saved on page unload');
            } catch (error) {
                console.error('‚ùå Failed to save data on page unload:', error);
            }
        });

        // ENHANCED CLEAR LOGS FUNCTION
        window.clearLogs = async function() {
            const confirmMessage = `‚ö†Ô∏è WARNING: Clear All Logs and Reset States?\n\nThis will permanently delete:\n- All ${eventLogs.length} log entries\n- All ${Object.keys(lastKnownStates).length} stored states\n- All persistent storage data\n\nNext monitoring cycle will treat all points as "initial state"\n\nThis action cannot be undone!\n\nAre you sure you want to continue?`;
            
            if (confirm(confirmMessage)) {
                const backupLogCount = eventLogs.length;
                const backupStateCount = Object.keys(lastKnownStates).length;
                
                // Clear in-memory data
                eventLogs = [];
                logCounter = 0;
                lastKnownStates = {};
                
                // Clear global data history but keep current states
                Object.keys(GlobalData.unitHistory).forEach(unitName => {
                    GlobalData.unitHistory[unitName] = [];
                });
                
                try {
                    // Clear persistent storage
                    await persistentStorage.clearAllData();
                    
                    updateEventLogs();
                    updateLastSaveTime();
                    
                    console.log(`üóëÔ∏è Cleared ${backupLogCount} log entries and ${backupStateCount} stored states`);
                    showNotification('Data Cleared', `Successfully cleared ${backupLogCount} log entries and ${backupStateCount} stored states`, 'success');
                    
                } catch (error) {
                    console.error('‚ùå Failed to clear persistent storage:', error);
                    showNotification('Clear Failed', 'Failed to clear some persistent data', 'error');
                }
            } else {
                console.log('‚ùå Clear logs cancelled by user');
            }
        };

        // MANUAL SAVE FUNCTION
        window.saveData = async function() {
            try {
                await saveAllDataToPersistentStorage();
                showNotification('Data Saved', `Saved ${eventLogs.length} logs and ${Object.keys(lastKnownStates).length} states`, 'success');
            } catch (error) {
                console.error('‚ùå Manual save failed:', error);
                showNotification('Save Failed', 'Failed to save data to persistent storage', 'error');
            }
        };

        // ENHANCED EXPORT LOGS FUNCTION (NOW EXPORTS CSV)
        window.exportLogs = function() {
            if (eventLogs.length === 0) {
                alert('No logs to export - please wait for some state changes to be detected');
                return;
            }

            // Sort by timestamp (newest first)
            const sortedLogs = eventLogs.slice().sort((a, b) => {
                return new Date(b.timestamp) - new Date(a.timestamp);
            });

            // Convert to CSV
            const csvContent = convertToCSV(sortedLogs);
            
            if (!csvContent) {
                alert('Failed to generate CSV content');
                return;
            }

            // Create and download CSV file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `niagara-logs-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log(`üìä Exported ${sortedLogs.length} logs to CSV`);
            showNotification('CSV Export Complete', `Exported ${sortedLogs.length} log entries to CSV file`, 'success');
        };
        
        // Simulate Niagara baja library for demo purposes
        if (typeof require === 'undefined') {
            window.require = function(deps, callback) {
                // Mock baja object
                const mockBaja = {
                    Ord: {
                        make: function(path) {
                            return {
                                get: function() {
                                    return Promise.resolve({
                                        getDisplayName: function() {
                                            const parts = path.split('/');
                                            return parts[parts.length - 1] || 'Unknown Point';
                                        },
                                        getName: function() {
                                            const parts = path.split('/');
                                            return parts[parts.length - 1] || 'Unknown Point';
                                        },
                                        get: function(slot) {
                                            if (slot === 'out') {
                                                const pointId = path.split('/').pop();
                                                const lastState = lastKnownStates[pointId];
                                                
                                                let newValue;
                                                if (lastState === undefined) {
                                                    newValue = Math.random() > 0.7;
                                                } else {
                                                    if (Math.random() > 0.1) {
                                                        newValue = lastState;
                                                    } else {
                                                        newValue = !lastState;
                                                    }
                                                }
                                                
                                                return {
                                                    getValue: function() {
                                                        return newValue;
                                                    }
                                                };
                                            }
                                            return null;
                                        }
                                    });
                                }
                            };
                        }
                    }
                };
                
                setTimeout(() => callback(mockBaja, {}), 100);
            };
        }

// FIXED INITIALIZATION ORDER - Define UI functions first, then load data

require(['baja!', 'baja!control:Override', 'baja!control:NumericOverride', 'baja!baja:Status', 'baja!alarm:AlarmSourceExt', 'baja!baja:StatusBoolean'], function (baja, types) {
    'use strict';
    
    // DEFINE ALL UI FUNCTIONS FIRST (before any data loading)
    
    // Time tracking function
    function updateDateTime() {
        const now = new Date();
        const options = {
            day: '2-digit',
            month: 'short',
            year: 'numeric',
            hour: 'numeric',
            minute: '2-digit',
            hour12: true,
            timeZoneName: 'short'
        };
        const formatted = now.toLocaleString('en-US', options).replace(',', '');
        document.getElementById('currentDateTime').textContent = formatted;
    }
    
    // Function to get formatted timestamp for data points
    function getFormattedTimestamp() {
        const now = new Date();
        const options = {
            day: '2-digit',
            month: 'short',
            year: 'numeric',
            hour: 'numeric',
            minute: '2-digit',
            hour12: true,
            timeZoneName: 'short'
        };
        return now.toLocaleString('en-US', options).replace(',', '');
    }
    
    
    
    
    function updateMonitoringStatus() {
        const statusElement = document.getElementById('monitoringStatus');
        if (statusElement) {
            if (monitoringActive) {
                statusElement.textContent = 'MONITORING ACTIVE';
                statusElement.className = 'monitoring-status monitoring-active';
            } else {
                statusElement.textContent = 'MONITORING STOPPED';
                statusElement.className = 'monitoring-status monitoring-inactive';
            }
        }
    }
    
    // Function to update event logs display
    function updateEventLogs() {
        const logsContainer = document.getElementById('eventLogs');
        
        // Check if element exists
        if (!logsContainer) {
            console.warn('Event logs container not found - UI may not be ready yet');
            return;
        }
        
        // Clear existing logs
        logsContainer.innerHTML = '';
        
        // Show recent logs (limit to 4 for performance)
        const recentLogs = eventLogs.slice(0, 4);
        
        // Add event logs
        recentLogs.forEach((log, index) => {
            const logElement = document.createElement('div');
            logElement.className = 'bubbleSP';
            
            const statusClass = log.value ? 'status-ok' : 'status-error';
            const statusText = log.value ? 'ON' : 'OFF';
            const statusIcon = log.value ? 'üîµ': '‚ö™';
            
            const changeIcon = log.isStateChange ? 'üîÑ ' : '';
            
            logElement.innerHTML = `
                <div id="status-point${log.id}" class="point-status status-display ${statusClass}">
                    <div class="status-title">${changeIcon}${statusIcon} ${log.displayName || log.systemName} - ${statusText}</div>
                    <div class="status-details">
                        <p><strong>Timestamp:</strong> ${log.timestamp}</p>
                        <p><strong>Status:</strong> ${log.details}</p>
                        <p><strong>Value:</strong> ${log.value ? 'TRUE' : 'FALSE'}</p>
                    </div>
                </div>
            `;
            
            logsContainer.appendChild(logElement);
        });
        
        // Show message if there are more logs
        if (eventLogs.length > 4) {
            const moreElement = document.createElement('div');
            moreElement.className = 'bubbleSP';
            moreElement.innerHTML = `
                <div class="point-status status-display">
                    <div class="status-title">... and ${eventLogs.length - 4} older entries</div>
                    <div class="status-details">
                        <p>Use Export Logs to view all ${eventLogs.length} entries</p>
                    </div>
                </div>
            `;
            logsContainer.appendChild(moreElement);
        }
        
        // Add message if no logs
        if (eventLogs.length === 0) {
            logsContainer.innerHTML = `
                <div class="bubbleSP">
                    <div class="point-status status-display">
                        <div class="status-title">No state changes recorded</div>
                        <div class="status-details">
                            <p>System is monitoring points for state changes...</p>
                            <p>Logs will only appear when values change from TRUE ‚Üî FALSE</p>
                        </div>
                    </div>
                </div>
            `;
        }
        
        updateOverallStatus();
    }
    
    // Function to update the overall system status summary
    function updateOverallStatus() {
        var statusElement = document.getElementById('system-status');
        if (!statusElement) {
            console.warn('System status element not found - UI may not be ready yet');
            return;
        }
        
        // Remove loading message
        statusElement.innerHTML = '';
        
        // Check if we need to add the overall summary
        var summaryElement = document.getElementById('overall-summary');
        if (!summaryElement) {
            summaryElement = document.createElement('div');
            summaryElement.id = 'overall-summary';
            summaryElement.className = 'overall-summary';
            statusElement.appendChild(summaryElement);
        }
        
        // Add save status indicator
        var saveStatusElement = document.getElementById('save-status');
        if (!saveStatusElement) {
            saveStatusElement = document.createElement('div');
            saveStatusElement.id = 'save-status';
            saveStatusElement.style.cssText = `
                margin-top: 10px;
                padding: 8px 12px;
                background: #f0f0f0;
                border-radius: 4px;
                font-size: 12px;
                color: #666;
            `;
            statusElement.appendChild(saveStatusElement);
        }
        
        // Count active points from last known states
        window.activeCount1 = 0;
        window.totalPoints1 = monitorPoints.length;
        
        // Count how many are active based on last known states
        Object.values(lastKnownStates).forEach(function(state) {
            if (state === true) {
                activeCount1++;
            }
        });
        
        var overallClass = activeCount1 > 0 ? 'status-ok' : 'status-error';
        var overallTitle = activeCount1 > 0 ? 
            `<span class="status-indicator"></span>üîµ ${activeCount1} SYSTEM${activeCount1 > 1 ? 'S' : ''} ACTIVE` : 
            '<span class="status-indicator"></span>‚ö™ ALL SYSTEMS INACTIVE';
        
        const monitoringStatusText = monitoringActive ? 'üü¢ ACTIVE' : 'üî¥ STOPPED';
        const monitoredCount = Object.keys(lastKnownStates).length;
        
        summaryElement.className = `overall-summary status-display ${overallClass}`;
        summaryElement.innerHTML = `
            <div class="status-title">${overallTitle}</div>
            <div class="status-details">
                <p><strong>Monitoring Status:</strong> ${monitoringStatusText}</p>
                <p><strong>True Points Count:</strong> ${activeCount1} of ${monitoredCount} monitored points</p>
                <p><strong>Total Logged Points:</strong> ${eventLogs.length}</p>
                <p><strong>Last Updated:</strong> ${new Date().toLocaleString()}</p>
                <p><strong>Global Units:</strong> ${GlobalData.getAllUnits().length} units accessible</p>
            </div>
        `;
        
        // Update save status
        saveStatusElement.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span id="lastSaveTime">Auto-save active</span>
                <button onclick="saveData()" style="padding: 4px 8px; font-size: 11px; border: 1px solid #ccc; background: white; border-radius: 3px; cursor: pointer;">Manual Save</button>
            </div>
        `;
    }

    // MODIFIED LOAD DATA FUNCTION with better error handling
    async function loadAllDataFromPersistentStorage() {
        try {
            console.log('üìñ Loading data from persistent storage...');
            
            // Load event logs
            try {
                const savedLogs = await persistentStorage.loadEventLogs();
                if (savedLogs && savedLogs.length > 0) {
                    eventLogs = savedLogs;
                    console.log(`‚úÖ Restored ${eventLogs.length} event logs`);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load event logs, starting fresh:', error.message);
            }
            
            // Load unit states
            try {
                const savedUnitStates = await persistentStorage.loadUnitStates();
                if (savedUnitStates && Object.keys(savedUnitStates).length > 0) {
                    GlobalData.unitStates = savedUnitStates;
                    console.log(`‚úÖ Restored ${Object.keys(savedUnitStates).length} unit states`);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load unit states, starting fresh:', error.message);
            }
            
            // Load last known states
            try {
                const savedLastKnown = await persistentStorage.loadLastKnownStates();
                if (savedLastKnown && Object.keys(savedLastKnown).length > 0) {
                    lastKnownStates = savedLastKnown;
                    console.log(`‚úÖ Restored ${Object.keys(savedLastKnown).length} last known states`);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load last known states, starting fresh:', error.message);
            }
            
            // Load system configuration
            try {
                const savedConfig = await persistentStorage.loadSystemConfig();
                if (savedConfig) {
                    if (savedConfig.logCounter) logCounter = savedConfig.logCounter;
                    if (savedConfig.monitoringActive !== undefined) monitoringActive = savedConfig.monitoringActive;
                    if (savedConfig.startTime) startTime = new Date(savedConfig.startTime);
                    console.log('‚úÖ Restored system configuration');
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load system config, using defaults:', error.message);
            }
            
            // Update UI - these functions are now defined above
            updateEventLogs();
            updateMonitoringStatus();
            updateLastSaveTime();
            
            console.log('üéâ Data loading completed (with any recoverable errors handled)');
            
            // Show restoration notification only if we actually restored data
            const totalRestored = eventLogs.length + Object.keys(lastKnownStates).length;
            if (totalRestored > 0) {
                showNotification('Data Restored', `Restored ${eventLogs.length} logs and ${Object.keys(lastKnownStates).length} states from previous session`, 'success');
            }
            
        } catch (error) {
            console.error('‚ùå Critical error during data loading:', error);
            showNotification('Load Failed', 'Could not restore previous session data', 'error');
            
            // Initialize with empty state to prevent further errors
            eventLogs = [];
            lastKnownStates = {};
            updateEventLogs();
            updateMonitoringStatus();
        }
    }

    // INITIALIZATION SEQUENCE - Now properly ordered
    async function initializeSystem() {
        console.log('üöÄ Initializing Niagara logging system...');
        
        try {
            // Wait for DOM to be ready
            if (document.readyState === 'loading') {
                await new Promise(resolve => {
                    document.addEventListener('DOMContentLoaded', resolve);
                });
            }
            
            // Initialize the display first
            updateDateTime();
            updateMonitoringStatus();
            
            // Now load saved data (UI functions are available)
            await loadAllDataFromPersistentStorage();
            
            // Start auto-save
            startAutoSave();
            
            // Set up periodic monitoring (every 10 seconds)
            setInterval(() => {
                if (monitoringActive) {
                    monitorAllPoints();
                }
            }, 10000);

            // Update date/time every second
            setInterval(updateDateTime, 1000);
            
            console.log('üéØ Niagara logging system with persistent storage initialized');
            console.log('üíæ Auto-save runs every 30 seconds');
            console.log('üîÑ Monitoring cycle runs every 10 seconds');
            console.log('üì± Data persists across page refresh/browser restart');
            console.log('üìä CSV export available via exportLogs() function');
            
        } catch (error) {
            console.error('‚ùå Failed to initialize system:', error);
            showNotification('Initialization Error', 'System started with limited functionality', 'error');
            
            // Basic fallback initialization
            updateDateTime();
            updateMonitoringStatus();
            updateEventLogs();
            startAutoSave();
        }
    }

    // CREATE POINT DEFINITION AND SETUP (this stays the same)
    function createPoint(idSuffix, unit, pointName, label = null) {
        return {
            id: `point${idSuffix}`,
            path: `station:|slot:/Drivers/BcpBacnetNetwork/${unit}/points/${pointName}`,
            systemName: label || `${unit}_${pointName}`,
            unit: unit,
            pointName: pointName
        };
    }

    // List of points per unit (this stays the same)
    const pointDefs1 = [
        // AIR HANDLING UNITS
        { unit: 'AHU_1', points: ['AHUAlarm', 'OccupiedCmd', 'AutoStop', 'MorningWarmupOutput', 'SF_S', 'OCC_S'] },
        { unit: 'AHU_2', points: ['AHUAlarm', 'OccupiedCmd', 'AutoStop', 'MorningWarmupOutput', 'SF_S', 'OCC_S'] },
        
        // VAV UNITS
        { unit: 'VAV_0_1', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_0_2', points: ['UnitStatus', 'RoomOccupancy'] },
        { unit: 'VAV_0_3', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_0_4', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_0_5', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        
        { unit: 'VAV_1_1', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_1_2', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_1_3', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_1_4', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_1_5', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_1_6', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_1_7', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        
        { unit: 'VAV_2_1', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_2_2', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_2_3', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_2_4', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_2_5', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_2_6', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_2_7', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_2_8', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        
        { unit: 'VAV_3_1', points: ['UnitStatus', 'RoomOccupancy'] },
        { unit: 'VAV_3_2', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_3_3', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
        { unit: 'VAV_3_4', points: ['UnitStatus', 'RoomOccupancy', 'Reheat1'] },
    ];

      // Build monitorPoints dynamically
            monitorPoints = []; // Reset the global array
            let idCounter = 1;

            pointDefs1.forEach(def => {
                def.points.forEach(p => {
                    monitorPoints.push(createPoint(idCounter++, def.unit, p));
                });
            });

            // Initialize global data structures for all units
            pointDefs1.forEach(def => {
                const unitName = def.unit;
                
                // Initialize unit state object
                if (!GlobalData.unitStates[unitName]) {
                    GlobalData.unitStates[unitName] = {};
                }
                
                // Initialize unit history array
                if (!GlobalData.unitHistory[unitName]) {
                    GlobalData.unitHistory[unitName] = [];
                }
                
                // Initialize unit metadata
                if (!GlobalData.unitMetadata[unitName]) {
                    GlobalData.unitMetadata[unitName] = {
                        type: unitName.startsWith('AHU') ? 'Air Handling Unit' : 'Variable Air Volume',
                        points: def.points,
                        lastUpdated: null
                    };
                }
                
                // Initialize individual point states
                def.points.forEach(pointName => {
                    if (!GlobalData.unitStates[unitName][pointName]) {
                        GlobalData.unitStates[unitName][pointName] = {
                            value: null,
                            timestamp: null,
                            displayName: null
                        };
                    }
                });
            });

            console.log(`üìä Initialized ${monitorPoints.length} monitor points`);
            console.log('üåê Global data structures initialized:', GlobalData);

            // Time tracking function
            function updateDateTime() {
                const now = new Date();
                const options = {
                    day: '2-digit',
                    month: 'short',
                    year: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true,
                    timeZoneName: 'short'
                };
                const formatted = now.toLocaleString('en-US', options).replace(',', '');
                document.getElementById('currentDateTime').textContent = formatted;
            }
            
            // Function to get formatted timestamp for data points
            function getFormattedTimestamp() {
                const now = new Date();
                const options = {
                    day: '2-digit',
                    month: 'short',
                    year: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true,
                    timeZoneName: 'short'
                };
                return now.toLocaleString('en-US', options).replace(',', '');
            }
            
            // Function to update global data when state changes
            function updateGlobalData(pointConfig, value, displayName, timestamp) {
                const unitName = pointConfig.unit;
                const pointName = pointConfig.pointName;
                
                // Store previous value for change detection
                const previousValue = GlobalData.unitStates[unitName][pointName].value;
                
                // Update current state
                GlobalData.unitStates[unitName][pointName] = {
                    value: value,
                    timestamp: timestamp,
                    displayName: displayName
                };
                
                // Update unit metadata
                GlobalData.unitMetadata[unitName].lastUpdated = timestamp;
                
                // Add to history for graphing (with timestamp as Date object for easier plotting)
                const historyEntry = {
                    timestamp: new Date(),
                    timestampString: timestamp,
                    value: value,
                    pointName: pointName,
                    changed: previousValue !== value
                };
                
                GlobalData.unitHistory[unitName].push(historyEntry);
                
                // Limit history to prevent memory issues (keep last 1000 entries per unit)
                if (GlobalData.unitHistory[unitName].length > 1000) {
                    GlobalData.unitHistory[unitName] = GlobalData.unitHistory[unitName].slice(-500);
                }
                
                // Notify subscribers of the change
                if (previousValue !== value) {
                    GlobalData._notifySubscribers(unitName, previousValue, value, timestamp);
                }
            }
            
            // Function to add data point to event logs (only on state change)
            function addDataPoint(value, pointConfig, displayName, errorMsg, isStateChange = false) {
                const timestamp = getFormattedTimestamp();
                logCounter++;
                
                // Update global data regardless of whether it's logged
                updateGlobalData(pointConfig, value, displayName, timestamp);
                
                // Determine the log message based on whether it's a state change
                let details;
                if (errorMsg) {
                    details = errorMsg;
                } else if (isStateChange) {
                    const previousState = lastKnownStates[pointConfig.id];
                    if (previousState === undefined) {
                        details = `${displayName} = ${value ? 'TRUE' : 'FALSE'} (Initial State)`;
                    } else {
                        details = `${displayName} changed from ${previousState ? 'TRUE' : 'FALSE'} to ${value ? 'TRUE' : 'FALSE'}`;
                    }
                } else {
                    details = `${displayName} = ${value ? 'TRUE' : 'FALSE'}`;
                }
                
                // Add to event log
                const logEntry = {
                    id: logCounter,
                    value: value,
                    timestamp: timestamp,
                    systemName: pointConfig.systemName || displayName,
                    details: details,
                    pointId: pointConfig.id,
                    displayName: displayName,
                    isStateChange: isStateChange,
                    unit: pointConfig.unit,
                    pointName: pointConfig.pointName
                };
                
                eventLogs.unshift(logEntry);
                
                updateEventLogs();
                
                // Trigger auto-save after new log entry (debounced)
                if (!addDataPoint.saveTimeout) {
                    addDataPoint.saveTimeout = setTimeout(async () => {
                        try {
                            await saveAllDataToPersistentStorage();
                            console.log('üìä Auto-saved after log entry');
                        } catch (error) {
                            console.error('‚ùå Failed to auto-save after log entry:', error);
                        }
                        addDataPoint.saveTimeout = null;
                    }, 5000); // Save 5 seconds after last change
                }
            }
            
            // Function to monitor a single point (only log on state change)
            function monitorSinglePoint(pointConfig) {
                if (!monitoringActive) return;
                
                try {
                    baja.Ord.make(pointConfig.path).get()
                        .then(function(pointObject) {
                            
                            // Extract the display name from the Niagara point
                            var pathParts = pointConfig.path.split('/');
                            var parentFolder = pathParts[pathParts.indexOf('BcpBacnetNetwork') + 1] || 
                                              pathParts[pathParts.indexOf('Magic_House') + 1] || 
                                              'Unknown';
                            pointConfig.parentFolder = parentFolder;

                            // Use in display name
                            var displayName = `${parentFolder} - ` +
                            (pointObject.getDisplayName ? pointObject.getDisplayName() : 
                             pointObject.getName ? pointObject.getName() : 
                             pointConfig.path.split('/').pop());

                            pointConfig.displayName = displayName;
                            
                            console.log(`[${displayName}] Point resolved:`, pointObject);
                            
                            // Get the current value of the 'out' slot
                            var currentStatus = pointObject.get('out');
                            var boolValue = currentStatus.getValue();
                            
                            console.log(`[${displayName}] Current out value:`, currentStatus);
                            console.log(`[${displayName}] Actual boolean value:`, boolValue);
                            
                            // Check if this is a state change
                            const lastKnownValue = lastKnownStates[pointConfig.id];
                            const isFirstTime = lastKnownValue === undefined;
                            const isStateChange = isFirstTime || (lastKnownValue !== boolValue);
                            
                            // Only log if state changed or it's the first time
                            if (isStateChange) {
                                console.log(`üîÑ [${displayName}] STATE CHANGE DETECTED! ${lastKnownValue === undefined ? '(Initial)' : `${lastKnownValue} ‚Üí ${boolValue}`}`);
                                
                                // Update the last known state
                                lastKnownStates[pointConfig.id] = boolValue;
                                
                                // Add data point to logs
                                addDataPoint(boolValue, pointConfig, displayName, null, true);
                                
                                if (boolValue === true) {
                                    console.log(`üö® [${displayName}] ACTIVATED!`);
                                } else {
                                    console.log(`üîµ [${displayName}] DEACTIVATED!`);
                                }
                            } else {
                                // No state change - just update global data but don't log
                                updateGlobalData(pointConfig, boolValue, displayName, getFormattedTimestamp());
                                console.log(`‚ö™ [${displayName}] No change - staying ${boolValue ? 'TRUE' : 'FALSE'}`);
                            }

                        })
                        .catch(function(error) {
                            console.error(`[${pointConfig.id}] Error resolving point:`, error);
                            // Always log errors
                            addDataPoint(false, pointConfig, pointConfig.id, 'Error connecting to system', false);
                        });
                        
                } catch (error) {
                    console.error(`[${pointConfig.id}] Error in monitorSinglePoint:`, error);
                    // Always log errors
                    addDataPoint(false, pointConfig, pointConfig.id, 'Error initializing monitor', false);
                }
            }
            
            // Function to monitor all points
            function monitorAllPoints() {
                if (!monitoringActive) {
                    console.log('‚è∏Ô∏è Monitoring is stopped');
                    return;
                }
                
                console.log('üîÑ Checking all points for state changes...');
                monitorPoints.forEach(function(pointConfig) {
                    monitorSinglePoint(pointConfig);
                });
            }
            
            // Enhanced Start/Stop monitoring functions
            window.startMonitoring = function() {
                monitoringActive = true;
                updateMonitoringStatus();
                console.log('‚ñ∂Ô∏è Monitoring started');
                
                // Save the monitoring state
                saveAllDataToPersistentStorage().catch(error => 
                    console.error('Failed to save monitoring state:', error)
                );
                
                monitorAllPoints();
                
                showNotification('Monitoring Started', 'Point monitoring is now active', 'success');
            };
            
            window.stopMonitoring = function() {
                monitoringActive = false;
                updateMonitoringStatus();
                console.log('‚èπÔ∏è Monitoring stopped');
                
                // Save the monitoring state
                saveAllDataToPersistentStorage().catch(error => 
                    console.error('Failed to save monitoring state:', error)
                );
                
                showNotification('Monitoring Stopped', 'Point monitoring has been paused', 'warning');
            };
            
            function updateMonitoringStatus() {
                const statusElement = document.getElementById('monitoringStatus');
                if (statusElement) {
                    if (monitoringActive) {
                        statusElement.textContent = 'MONITORING ACTIVE';
                        statusElement.className = 'monitoring-status monitoring-active';
                    } else {
                        statusElement.textContent = 'MONITORING STOPPED';
                        statusElement.className = 'monitoring-status monitoring-inactive';
                    }
                }
            }
            
            // Function to update event logs display
            function updateEventLogs() {
                const logsContainer = document.getElementById('eventLogs');
                
                // Clear existing logs
                logsContainer.innerHTML = '';
                
                // Show recent logs (limit to 6 for performance)
                const recentLogs = eventLogs.slice(0, 4);
                
                // Add event logs
                recentLogs.forEach((log, index) => {
                    const logElement = document.createElement('div');
                    logElement.className = 'bubbleSP';
                    
                    const statusClass = log.value ? 'status-ok' : 'status-error';
                    const statusText = log.value ? 'ON' : 'OFF';
                    const statusIcon = log.value ? 'üîµ': '‚ö™';
                    
                    const changeIcon = log.isStateChange ? 'üîÑ ' : '';
                    
                    logElement.innerHTML = `
                        <div id="status-point${log.id}" class="point-status status-display ${statusClass}">
                            <div class="status-title">${changeIcon}${statusIcon} ${log.displayName || log.systemName} - ${statusText}</div>
                            <div class="status-details">
                                <p><strong>Timestamp:</strong> ${log.timestamp}</p>
                                <p><strong>Status:</strong> ${log.details}</p>
                                <p><strong>Value:</strong> ${log.value ? 'TRUE' : 'FALSE'}</p>
                            </div>
                        </div>
                    `;
                    
                    logsContainer.appendChild(logElement);
                });
                
                // Show message if there are more logs
                if (eventLogs.length > 4) {
                    const moreElement = document.createElement('div');
                    moreElement.className = 'bubbleSP';
                    moreElement.innerHTML = `
                        <div class="point-status status-display">
                            <div class="status-title">... and ${eventLogs.length - 4} older entries</div>
                            <div class="status-details">
                                <p>Use Export Logs to view all ${eventLogs.length} entries</p>
                            </div>
                        </div>
                    `;
                    logsContainer.appendChild(moreElement);
                }
                
                // Add message if no logs
                if (eventLogs.length === 0) {
                    logsContainer.innerHTML = `
                        <div class="bubbleSP">
                            <div class="point-status status-display">
                                <div class="status-title">No state changes recorded</div>
                                <div class="status-details">
                                    <p>System is monitoring points for state changes...</p>
                                    <p>Logs will only appear when values change from TRUE ‚Üî FALSE</p>
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                updateOverallStatus();
            }

    // NOW START THE INITIALIZATION (all functions are defined)
    initializeSystem();
    
    // ALL OTHER FUNCTIONS (monitoring, data processing, etc.) go here...
    // [Include all your other existing functions like updateGlobalData, addDataPoint, etc.]
    
});












// Enhanced Graph Viewer Functions with Date Filtering
function initializeGraphViewer() {
    populateUnitSelector();
    initializeDateFilter();
}

// Initialize date filter functionality
// Add event listener to date input for immediate refresh
function initializeDateFilter() {
    const dateInput = document.getElementById('numeric-input');
    if (dateInput) {
        // Set default date to today
        const today = new Date();
        const todayString = today.getFullYear() + '-' + 
                           String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                           String(today.getDate()).padStart(2, '0');
        dateInput.value = todayString;
        dateInput.type = 'date';
        
        console.log(`üìÖ Date input initialized with: ${todayString}`);
        
        // Add event listener for date changes
        dateInput.addEventListener('change', function() {
            console.log(`üìÖ Date changed to: ${dateInput.value}`);
            forceRefreshGraph(); // Use force refresh instead of just update
        });
    }
}



// Get selected date with more robust parsing
function getSelectedDate() {
    const dateInput = document.getElementById('numeric-input');
    if (!dateInput || !dateInput.value) {
        console.log('‚ùå No date input found or no value selected');
        return null;
    }
    
    // Parse the date input value (should be in YYYY-MM-DD format)
    const inputValue = dateInput.value;
    console.log(`üìÖ Raw date input value: "${inputValue}"`);
    
    // Create date object from input
    const selectedDate = new Date(inputValue + 'T00:00:00.000'); // Add time to avoid timezone issues
    
    // Create start and end of day in local time
    const startOfDay = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate(), 0, 0, 0, 0);
    const endOfDay = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate(), 23, 59, 59, 999);
    
    console.log(`üìÖ Parsed date: ${selectedDate}`);
    console.log(`üåÖ Start of day: ${startOfDay}`);
    console.log(`üåô End of day: ${endOfDay}`);
    
    return {
        dateObject: selectedDate,
        dateString: inputValue, // YYYY-MM-DD
        startOfDay: startOfDay,
        endOfDay: endOfDay
    };
}

// COMPLETELY REWRITTEN - More aggressive date filtering
function getFilteredEventLogsByDate(unit = null, point = null) {
    const selectedDate = getSelectedDate();
    if (!selectedDate) {
        console.log('‚ö†Ô∏è No date selected, returning empty array');
        return []; // Return empty array instead of all data
    }
    
    console.log(`üîç Filtering eventLogs for date: ${selectedDate.dateString}`);
    console.log(`üìä Total eventLogs to filter: ${eventLogs.length}`);
    
    // Filter with detailed logging
    const filtered = eventLogs.filter((log, index) => {
        // Parse the log timestamp
        const logTimestamp = new Date(log.timestamp);
        
        // Check if timestamp is valid
        if (isNaN(logTimestamp.getTime())) {
            console.log(`‚ö†Ô∏è Invalid timestamp at index ${index}: "${log.timestamp}"`);
            return false;
        }
        
        // Get just the date part for comparison (ignore time)
        const logDateString = logTimestamp.getFullYear() + '-' + 
                             String(logTimestamp.getMonth() + 1).padStart(2, '0') + '-' + 
                             String(logTimestamp.getDate()).padStart(2, '0');
        
        const selectedDateString = selectedDate.dateString;
        
        // Date match check
        const matchesDate = logDateString === selectedDateString;
        
        // Unit match check
        const matchesUnit = !unit || log.unit === unit;
        
        // Point match check  
        const matchesPoint = !point || log.pointName === point;
        
        const shouldInclude = matchesDate && matchesUnit && matchesPoint;
        
        // Debug logging for first few entries or matches
        if (index < 5 || shouldInclude) {
            console.log(`üìã Index ${index}: ${log.timestamp} (${logDateString}) - Date Match: ${matchesDate}, Unit: ${matchesUnit}, Point: ${matchesPoint}, Include: ${shouldInclude}`);
        }
        
        return shouldInclude;
    });
    
    console.log(`‚úÖ Found ${filtered.length} matching logs for ${selectedDate.dateString}`);
    
    // Log the actual timestamps we found
    if (filtered.length > 0) {
        console.log('üïê Matching timestamps:');
        filtered.forEach((log, i) => {
            console.log(`  ${i + 1}. ${log.timestamp} - ${log.unit} - ${log.pointName} - ${log.value}`);
        });
    } else {
        console.log('‚ùå No matching data found for the selected criteria');
    }
    
    return filtered;
}


// Enhanced populateUnitSelector with better logging
function populateUnitSelector() {
    const unitSelector = document.getElementById('unitSelector');
    if (!unitSelector) return;

    console.log('üè¢ Populating unit selector...');

    // Clear existing options
    unitSelector.innerHTML = '<option value="">Select Unit...</option>';

    // Get unique units from filtered eventLogs by selected date
    const filteredLogs = getFilteredEventLogsByDate();
    console.log(`üìä Units available for selected date: filtering from ${filteredLogs.length} logs`);
    
    const uniqueUnits = [...new Set(filteredLogs.map(log => log.unit))].filter(unit => unit).sort();
    console.log(`üè¢ Unique units found: ${uniqueUnits.length}`, uniqueUnits);
    
    uniqueUnits.forEach(unit => {
        const option = document.createElement('option');
        option.value = unit;
        option.textContent = unit;
        unitSelector.appendChild(option);
    });

    // Update data availability indicator
    updateDataAvailabilityIndicator(filteredLogs.length);
}



function updatePointSelector() {
    const unitSelector = document.getElementById('unitSelector');
    const pointSelector = document.getElementById('pointSelector');
    
    if (!unitSelector || !pointSelector) return;

    const selectedUnit = unitSelector.value;
    
    // Clear existing options
    pointSelector.innerHTML = '<option value="">Select Point...</option>';

    if (selectedUnit) {
        // Get unique points for the selected unit from filtered eventLogs by date
        const filteredLogs = getFilteredEventLogsByDate(selectedUnit);
        const uniquePoints = [...new Set(filteredLogs.map(log => log.pointName))].sort();
        
        uniquePoints.forEach(point => {
            if (point) {
                const option = document.createElement('option');
                option.value = point;
                option.textContent = point;
                pointSelector.appendChild(option);
            }
        });
    }

    // Clear the graph when unit changes
    clearGraph();
}

function updateGraph() {
    const unitSelector = document.getElementById('unitSelector');
    const pointSelector = document.getElementById('pointSelector');
    const timeRangeSelector = document.getElementById('timeRangeSelector');
    
    if (!unitSelector || !pointSelector) return;

    const selectedUnit = unitSelector.value;
    const selectedPoint = pointSelector.value;
    const timeRange = timeRangeSelector ? timeRangeSelector.value : 'all';

    if (!selectedUnit || !selectedPoint) {
        clearGraph();
        return;
    }

    drawGraph(selectedUnit, selectedPoint, timeRange);
}


// function drawGraph(unitName, pointName, timeRange) {
//     console.log(`üé® Starting drawGraph for ${unitName} - ${pointName} with timeRange: ${timeRange}`);
    
//     const canvas = document.getElementById('graphCanvas');
//     const noDataMessage = document.getElementById('noDataMessage');
//     const graphLegend = document.getElementById('graphLegend');
//     const graphStats = document.getElementById('graphStats');
    
//     if (!canvas) {
//         console.log('‚ùå Canvas not found');
//         return;
//     }

//     const selectedDate = getSelectedDate();
//     if (!selectedDate) {
//         console.log('‚ùå No date selected');
//         clearGraph();
//         return;
//     }

//     const ctx = canvas.getContext('2d');
    
//     // Set canvas size
//     canvas.width = canvas.offsetWidth;
//     canvas.height = canvas.offsetHeight;

//     // STEP 1: Get data for selected date only
//     let filteredData = getFilteredEventLogsByDate(unitName, pointName);
//     console.log(`üìä After date filtering: ${filteredData.length} points for ${selectedDate.dateString}`);
    
//     // STEP 2: Apply time range filter within the selected date (if not 'all')
//     if (timeRange !== 'all' && !timeRange.includes('All Data') && timeRange !== undefined) {
//         const minutesBack = parseInt(timeRange);
//         if (!isNaN(minutesBack)) {
//             // Calculate cutoff time from the END of the selected day
//             const cutoffTime = new Date(selectedDate.endOfDay.getTime() - (minutesBack * 60 * 1000));
//             console.log(`‚è∞ Applying time filter: last ${minutesBack} minutes from ${cutoffTime}`);
            
//             const beforeTimeFilter = filteredData.length;
//             filteredData = filteredData.filter(log => {
//                 const logTime = new Date(log.timestamp);
//                 return logTime >= cutoffTime;
//             });
//             console.log(`‚è∞ After time filtering: ${filteredData.length} points (was ${beforeTimeFilter})`);
//         }
//     }

//     // Convert to graph format
//     filteredData = filteredData.map(log => ({
//         timestamp: new Date(log.timestamp),
//         timestampString: log.timestamp,
//         value: log.value,
//         changed: log.isStateChange || false,
//         pointName: log.pointName
//     }));

//     // Sort by timestamp
//     filteredData.sort((a, b) => a.timestamp - b.timestamp);

//     console.log(`üìà Final data points for graph: ${filteredData.length}`);

//     // Show no data message if empty
//     if (filteredData.length === 0) {
//         const dateStr = selectedDate.dateString;
//         noDataMessage.textContent = `No data found for ${unitName} - ${pointName} on ${dateStr}`;
//         noDataMessage.style.display = 'block';
//         canvas.style.display = 'none';
//         graphLegend.innerHTML = '';
//         graphStats.innerHTML = '';
//         console.log('‚ùå No data to display');
//         return;
//     }

//     // Show the graph
//     noDataMessage.style.display = 'none';
//     canvas.style.display = 'block';

//     // Clear canvas
//     ctx.clearRect(0, 0, canvas.width, canvas.height);

//     // Graph dimensions
//     const padding = 60;
//     const graphWidth = canvas.width - (padding * 2);
//     const graphHeight = canvas.height - (padding * 2);

//     // Draw background
//     ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim() || '#ffffff';
//     ctx.fillRect(0, 0, canvas.width, canvas.height);

//     // Draw grid
//     drawGrid(ctx, padding, graphWidth, graphHeight);

//     // Draw axes (this will now show the full selected day)
//     drawAxesWithDate(ctx, padding, graphWidth, graphHeight, filteredData);

//     // Draw data line (this will now position data within the full day)
//     drawDataLine(ctx, padding, graphWidth, graphHeight, filteredData);

//     // Update legend and stats
//     updateGraphLegend(unitName, pointName, filteredData);
//     updateGraphStats(filteredData);
    
//     console.log(`‚úÖ Graph completed for ${selectedDate.dateString}`);
// }



// Updated drawGraph function to use the fixed drawAxesWithDate
function drawGraph(unitName, pointName, timeRange) {
    console.log(`üé® Starting drawGraph for ${unitName} - ${pointName} with timeRange: ${timeRange}`);
    
    const canvas = document.getElementById('graphCanvas');
    const noDataMessage = document.getElementById('noDataMessage');
    const graphLegend = document.getElementById('graphLegend');
    const graphStats = document.getElementById('graphStats');
    
    if (!canvas) {
        console.log('‚ùå Canvas not found');
        return;
    }

    const selectedDate = getSelectedDate();
    if (!selectedDate) {
        console.log('‚ùå No date selected');
        clearGraph();
        return;
    }

    const ctx = canvas.getContext('2d');
    
    // Set canvas size
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    // STEP 1: Get data for selected date only
    let filteredData = getFilteredEventLogsByDate(unitName, pointName);
    console.log(`üìä After date filtering: ${filteredData.length} points for ${selectedDate.dateString}`);
    
    // STEP 2: Apply time range filter within the selected date (if not 'all')
    if (timeRange !== 'all' && !timeRange.includes('All Data') && timeRange !== undefined) {
        const minutesBack = parseInt(timeRange);
        if (!isNaN(minutesBack)) {
            // Calculate cutoff time from the END of the selected day
            const cutoffTime = new Date(selectedDate.endOfDay.getTime() - (minutesBack * 60 * 1000));
            console.log(`‚è∞ Applying time filter: last ${minutesBack} minutes from ${cutoffTime}`);
            
            const beforeTimeFilter = filteredData.length;
            filteredData = filteredData.filter(log => {
                const logTime = new Date(log.timestamp);
                return logTime >= cutoffTime;
            });
            console.log(`‚è∞ After time filtering: ${filteredData.length} points (was ${beforeTimeFilter})`);
        }
    }

    // Convert to graph format
    filteredData = filteredData.map(log => ({
        timestamp: new Date(log.timestamp),
        timestampString: log.timestamp,
        value: log.value,
        changed: log.isStateChange || false,
        pointName: log.pointName
    }));

    // Sort by timestamp
    filteredData.sort((a, b) => a.timestamp - b.timestamp);

    console.log(`üìà Final data points for graph: ${filteredData.length}`);

    // Show no data message if empty
    if (filteredData.length === 0) {
        const dateStr = selectedDate.dateString;
        noDataMessage.textContent = `No data found for ${unitName} - ${pointName} on ${dateStr}`;
        noDataMessage.style.display = 'block';
        canvas.style.display = 'none';
        graphLegend.innerHTML = '';
        graphStats.innerHTML = '';
        console.log('‚ùå No data to display');
        return;
    }

    // Show the graph
    noDataMessage.style.display = 'none';
    canvas.style.display = 'block';

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Graph dimensions
    const padding = 60;
    const graphWidth = canvas.width - (padding * 2);
    const graphHeight = canvas.height - (padding * 2);

    // Draw background
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim() || '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw grid
    drawGrid(ctx, padding, graphWidth, graphHeight);

    // Draw axes using the FIXED function
    drawAxesWithDate(ctx, padding, graphWidth, graphHeight, filteredData);

    // Draw data line using the FIXED function
    drawDataLine(ctx, padding, graphWidth, graphHeight, filteredData);

    // Update legend and stats
    updateGraphLegend(unitName, pointName, filteredData);
    updateGraphStats(filteredData);
    
    console.log(`‚úÖ Graph completed for ${selectedDate.dateString}`);
}





// function drawAxesWithDate(ctx, padding, width, height, data) {
//     const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim() || '#000000';
//     ctx.strokeStyle = textColor;
//     ctx.lineWidth = 2;
//     ctx.font = '12px Segoe UI, sans-serif';
//     ctx.fillStyle = textColor;

//     // Draw axes
//     ctx.beginPath();
//     ctx.moveTo(padding, padding);
//     ctx.lineTo(padding, padding + height);
//     ctx.lineTo(padding + width, padding + height);
//     ctx.stroke();

//     // Y-axis labels (TRUE/FALSE)
//     ctx.textAlign = 'right';
//     ctx.textBaseline = 'middle';
//     ctx.fillText('TRUE', padding - 10, padding + height * 0.25);
//     ctx.fillText('FALSE', padding - 10, padding + height * 0.75);

//     // FIXED: X-axis labels with logical time intervals
//     const selectedDate = getSelectedDate();
//     if (selectedDate) {
//         ctx.textAlign = 'center';
//         ctx.textBaseline = 'top';
        
//         // Use the full selected day range for X-axis
//         const startTime = selectedDate.startOfDay;
//         const endTime = selectedDate.endOfDay;
        
//         // SOLUTION 1: Use logical 4-hour intervals instead of equal divisions
//         const timeLabels = [
//             // new Date(startTime.getTime()), // 12:00 AM
//             // new Date(startTime.getTime() + 4 * 60 * 60 * 1000), // 4:00 AM
//             // new Date(startTime.getTime() + 8 * 60 * 60 * 1000), // 8:00 AM
//             // new Date(startTime.getTime() + 12 * 60 * 60 * 1000), // 12:00 PM
//             // new Date(startTime.getTime() + 16 * 60 * 60 * 1000), // 4:00 PM
//             // new Date(startTime.getTime() + 20 * 60 * 60 * 1000), // 8:00 PM
//         ];
        
//         timeLabels.forEach((timePoint, i) => {
//             const x = padding + (width * i / 5); // Still divide visual space equally
//             const timeStr = timePoint.toLocaleTimeString('en-US', { 
//                 hour: 'numeric', // Use 'numeric' instead of '2-digit' for cleaner look
//                 minute: '2-digit',
//                 hour12: true
//             });
//             ctx.fillText(timeStr, x, padding + height + 10);
//         });
        
//         // Add date label at bottom center
//         ctx.font = 'bold 14px Segoe UI, sans-serif';
//         const dateStr = selectedDate.dateObject.toLocaleDateString('en-US', {
//             weekday: 'long',
//             year: 'numeric',
//             month: 'long',
//             day: 'numeric'
//         });
//         ctx.fillText(dateStr, padding + width / 2, padding + height + 35);
//     }

//     // Axis titles
//     ctx.textAlign = 'center';
//     ctx.textBaseline = 'middle';
//     ctx.font = 'bold 14px Segoe UI, sans-serif';
    
//     // Y-axis title
//     ctx.save();
//     ctx.translate(20, padding + height / 2);
//     ctx.rotate(-Math.PI / 2);
//     ctx.fillText('Point Value', 0, 0);
//     ctx.restore();
    
//     // X-axis title
//     ctx.fillText('Time', padding + width / 2, padding + height + 55);
// }


// Fixed drawAxesWithDate function
function drawAxesWithDate(ctx, padding, width, height, data) {
    const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim() || '#000000';
    ctx.strokeStyle = textColor;
    ctx.lineWidth = 2;
    ctx.font = '12px Segoe UI, sans-serif';
    ctx.fillStyle = textColor;

    // Draw axes
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, padding + height);
    ctx.lineTo(padding + width, padding + height);
    ctx.stroke();

    // Y-axis labels (TRUE/FALSE)
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    ctx.fillText('TRUE', padding - 10, padding + height * 0.25);
    ctx.fillText('FALSE', padding - 10, padding + height * 0.75);

    // X-axis labels - FIXED VERSION
    const selectedDate = getSelectedDate();
    if (selectedDate && data && data.length > 0) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        
        // Use FULL DAY for the timespan
        const dayStartTime = selectedDate.startOfDay.getTime();
        const dayEndTime = selectedDate.endOfDay.getTime();
        const dayTimeSpan = dayEndTime - dayStartTime;
        
        console.log(`üìä Day range: ${selectedDate.startOfDay.toLocaleString()} to ${selectedDate.endOfDay.toLocaleString()}`);
        
        // Create proper chronological time labels throughout the day
        const timeLabels = [];
        
        // Start at midnight and create logical time intervals
        const startOfSelectedDay = selectedDate.startOfDay;
        
        // Option 1: Every 4 hours - 12AM, 4AM, 8AM, 12PM, 4PM, 8PM
        // const hourIntervals = [0, 4, 8, 12, 16, 20];
        
        // Option 2: Key times throughout the day - 12AM, 6AM, 12PM, 6PM, 11:59PM
        const hourIntervals = [0, 6, 12, 17, 22]; // 23.98 ‚âà 11:59 PM
        
        // Option 3: Business day focused - 12AM, 8AM, 12PM, 4PM, 8PM
        // const hourIntervals = [0, 8, 12, 16, 20];
        
        hourIntervals.forEach(hour => {
            const timePoint = new Date(startOfSelectedDay.getFullYear(), 
                                    startOfSelectedDay.getMonth(), 
                                    startOfSelectedDay.getDate(), 
                                    Math.floor(hour), 
                                    (hour % 1) * 60, 0, 0); // Handle decimal hours for minutes
            timeLabels.push(timePoint);
        });
        
        console.log(`üìä Time labels:`, timeLabels.map(t => t.toLocaleTimeString()));
        
        // Draw the time labels
        timeLabels.forEach((timePoint, i) => {
            const x = padding + (width * i / 4); // Evenly space across width
            
            const timeStr = timePoint.toLocaleTimeString('en-US', { 
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });
            
            ctx.fillText(timeStr, x, padding + height + 10);
            console.log(`üìç Label ${i}: ${timeStr} at x=${Math.round(x)}`);
        });
        
        // Add date label at bottom center
        ctx.font = 'bold 14px Segoe UI, sans-serif';
        const dateStr = selectedDate.dateObject.toLocaleDateString('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
        ctx.fillText(dateStr, padding + width / 2, padding + height + 35);
    }

    // Axis titles
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = 'bold 14px Segoe UI, sans-serif';
    
    // Y-axis title
    ctx.save();
    ctx.translate(20, padding + height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Point Value', 0, 0);
    ctx.restore();
    
    // X-axis title
    ctx.fillText('Time', padding + width / 2, padding + height + 55);
}


// Add data availability indicator
function updateDataAvailabilityIndicator(dataCount) {
    const selectedDate = getSelectedDate();
    if (!selectedDate) return;
    
    // Create or update indicator element
    let indicator = document.getElementById('dataAvailabilityIndicator');
    if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'dataAvailabilityIndicator';
        indicator.style.cssText = `
            margin: 10px 0;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
        `;
        
        const unitSelector = document.getElementById('unitSelector');
        if (unitSelector && unitSelector.parentNode) {
            unitSelector.parentNode.insertBefore(indicator, unitSelector.nextSibling);
        }
    }
    
    const dateStr = selectedDate.dateObject.toLocaleDateString('en-US');
    if (dataCount === 0) {
        indicator.textContent = `No data available for ${dateStr}`;
        indicator.style.backgroundColor = '#ffebee';
        indicator.style.color = '#c62828';
        indicator.style.border = '1px solid #ef5350';
    } else {
        indicator.textContent = `${dataCount} data points found for ${dateStr}`;
        indicator.style.backgroundColor = '#e8f5e8';
        indicator.style.color = '#2e7d32';
        indicator.style.border = '1px solid #4caf50';
    }
}

// Enhanced CSV export with date filtering
function exportGraphData() {
    const unitSelector = document.getElementById('unitSelector');
    const pointSelector = document.getElementById('pointSelector');
    const selectedDate = getSelectedDate();
    
    if (!unitSelector || !pointSelector) {
        alert('Please select a unit and point first');
        return;
    }

    const selectedUnit = unitSelector.value;
    const selectedPoint = pointSelector.value;

    if (!selectedUnit || !selectedPoint) {
        alert('Please select both a unit and point to export');
        return;
    }

    const filteredData = getFilteredEventLogsByDate(selectedUnit, selectedPoint);

    if (filteredData.length === 0) {
        const dateStr = selectedDate ? selectedDate.dateString : 'selected date';
        alert(`No data available for the selected point on ${dateStr}`);
        return;
    }

    // Create CSV content with date info
    const dateStr = selectedDate ? selectedDate.dateString : 'All_Dates';
    let csvContent = 'Timestamp,Value,Changed,Unit,Point\n';
    filteredData.forEach(log => {
        csvContent += `"${log.timestamp}",${log.value ? 'TRUE' : 'FALSE'},${log.isStateChange ? 'YES' : 'NO'},"${selectedUnit}","${selectedPoint}"\n`;
    });

    // Download CSV with date in filename
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `Graph_Data_${selectedUnit}_${selectedPoint}_${dateStr}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
    
    console.log(`üìä Exported ${filteredData.length} data points for ${dateStr}`);
}

// Update the toggle graph viewer function to initialize date filtering
function toggleGraphViewer() {
    const graphViewer = document.getElementById('graphViewer');
    const mainView = document.getElementById('mainView');
    
    if (!graphViewer || !mainView) return;

    graphViewerActive = !graphViewerActive;

    if (graphViewerActive) {
        graphViewer.classList.add('active');
        mainView.classList.add('hidden');
        
        // Initialize graph viewer data with date filtering
        initializeGraphViewer(); // This now includes date filter initialization
        clearGraph();
        addExportButton();
        
        // Update button text
        const button = document.querySelector('.controls button[onclick="toggleGraphViewer()"]');
        if (button) button.innerHTML = '‚Üê Back to Logs';
    } else {
        graphViewer.classList.remove('active');
        mainView.classList.remove('hidden');
        
        // Update button text
        const button = document.querySelector('.controls button[onclick="toggleGraphViewer()"]');
        if (button) button.innerHTML = 'üìä View Graphs';
    }
}

// Console logging for debugging
console.log('üìÖ Date-filtered graphing functionality loaded!');
console.log('üîç Select a date to filter graph data');
console.log('üìä Unit and point selectors will update based on selected date');


        
function populateUnitSelector() {
    const unitSelector = document.getElementById('unitSelector');
    if (!unitSelector) return;

    // Clear existing options
    unitSelector.innerHTML = '<option value="">Select Unit...</option>';

    // MODIFIED: Get unique units from eventLogs instead of GlobalData
    const uniqueUnits = [...new Set(eventLogs.map(log => log.unit))].sort();
    
    uniqueUnits.forEach(unit => {
        if (unit) { // Make sure unit is not empty or undefined
            const option = document.createElement('option');
            option.value = unit;
            option.textContent = unit;
            unitSelector.appendChild(option);
        }
    });
}
        
      
        
        function updatePointSelector() {
    const unitSelector = document.getElementById('unitSelector');
    const pointSelector = document.getElementById('pointSelector');
    
    if (!unitSelector || !pointSelector) return;

    const selectedUnit = unitSelector.value;
    
    // Clear existing options
    pointSelector.innerHTML = '<option value="">Select Point...</option>';

    if (selectedUnit) {
        // MODIFIED: Get unique points for the selected unit from eventLogs
        const uniquePoints = [...new Set(
            eventLogs
                .filter(log => log.unit === selectedUnit)
                .map(log => log.pointName)
        )].sort();
        
        uniquePoints.forEach(point => {
            if (point) { // Make sure point is not empty or undefined
                const option = document.createElement('option');
                option.value = point;
                option.textContent = point;
                pointSelector.appendChild(option);
            }
        });
    }

    // Clear the graph when unit changes
    clearGraph();
}
        

        function updateGraph() {
            const unitSelector = document.getElementById('unitSelector');
            const pointSelector = document.getElementById('pointSelector');
            const timeRangeSelector = document.getElementById('timeRangeSelector');
            
            if (!unitSelector || !pointSelector || !timeRangeSelector) return;

            const selectedUnit = unitSelector.value;
            const selectedPoint = pointSelector.value;
            const timeRange = timeRangeSelector.value;

            if (!selectedUnit || !selectedPoint) {
                clearGraph();
                return;
            }

            drawGraph(selectedUnit, selectedPoint, timeRange);
        }

        
        function drawGraph(unitName, pointName, timeRange) {
    const canvas = document.getElementById('graphCanvas');
    const noDataMessage = document.getElementById('noDataMessage');
    const graphLegend = document.getElementById('graphLegend');
    const graphStats = document.getElementById('graphStats');
    
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    
    // Set canvas size
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    // MODIFIED: Use eventLogs instead of unitHistory to get all persistent data
    let filteredData = eventLogs.filter(log => 
        log.unit === unitName && log.pointName === pointName
    );
    
    // Apply time filter
    if (timeRange !== 'all') {
        const minutesBack = parseInt(timeRange);
        const cutoffTime = new Date(Date.now() - (minutesBack * 60 * 1000));
        filteredData = filteredData.filter(log => 
            new Date(log.timestamp) >= cutoffTime
        );
    }

    // Convert eventLogs format to the expected graph data format
    filteredData = filteredData.map(log => ({
        timestamp: new Date(log.timestamp),
        timestampString: log.timestamp,
        value: log.value,
        changed: log.isStateChange || false,
        pointName: log.pointName
    }));

    // Sort by timestamp to ensure proper order
    filteredData.sort((a, b) => a.timestamp - b.timestamp);

    if (filteredData.length === 0) {
        noDataMessage.style.display = 'block';
        canvas.style.display = 'none';
        graphLegend.innerHTML = '';
        graphStats.innerHTML = '';
        return;
    }

    noDataMessage.style.display = 'none';
    canvas.style.display = 'block';

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Graph dimensions
    const padding = 60;
    const graphWidth = canvas.width - (padding * 2);
    const graphHeight = canvas.height - (padding * 2);

    // Draw background
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim();
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw grid
    drawGrid(ctx, padding, graphWidth, graphHeight);

    // Draw axes
    drawAxes(ctx, padding, graphWidth, graphHeight, filteredData);

    // Draw data line
    drawDataLine(ctx, padding, graphWidth, graphHeight, filteredData);

    // Update legend and stats
    updateGraphLegend(unitName, pointName, filteredData);
    updateGraphStats(filteredData);
}
        
        
        // Add this function to manually trigger a complete refresh
function forceRefreshGraph() {
    console.log('üîÑ Force refreshing graph...');
    
    // Clear current selections to force a complete rebuild
    const unitSelector = document.getElementById('unitSelector');
    const pointSelector = document.getElementById('pointSelector');
    
    if (unitSelector && pointSelector) {
        const selectedUnit = unitSelector.value;
        const selectedPoint = pointSelector.value;
        
        // Rebuild unit selector with current date filter
        populateUnitSelector();
        
        // Restore selections if they still exist for this date
        if (selectedUnit) {
            unitSelector.value = selectedUnit;
            updatePointSelector();
            
            if (selectedPoint) {
                pointSelector.value = selectedPoint;
                updateGraph();
            }
        }
    }
}

        

        function drawGrid(ctx, padding, width, height) {
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
            ctx.lineWidth = 0.5;
            ctx.setLineDash([2, 2]);

            // Vertical grid lines
            for (let i = 0; i <= 10; i++) {
                const x = padding + (width * i / 10);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, padding + height);
                ctx.stroke();
            }

            // Horizontal grid lines
            for (let i = 0; i <= 4; i++) {
                const y = padding + (height * i / 4);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + width, y);
                ctx.stroke();
            }

            ctx.setLineDash([]);
        }

        // function drawAxes(ctx, padding, width, height, data) {
        //     ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
        //     ctx.lineWidth = 2;
        //     ctx.font = '12px Segoe UI';
        //     ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();

        //     // Draw axes
        //     ctx.beginPath();
        //     ctx.moveTo(padding, padding);
        //     ctx.lineTo(padding, padding + height);
        //     ctx.lineTo(padding + width, padding + height);
        //     ctx.stroke();

        //     // Y-axis labels (TRUE/FALSE)
        //     ctx.textAlign = 'right';
        //     ctx.textBaseline = 'middle';
        //     ctx.fillText('TRUE', padding - 10, padding + height * 0.25);
        //     ctx.fillText('FALSE', padding - 10, padding + height * 0.75);

        //     // X-axis labels (time)
        //     if (data.length > 0) {
        //         ctx.textAlign = 'center';
        //         ctx.textBaseline = 'top';
                
        //         const startTime = data[0].timestamp;
        //         const endTime = data[data.length - 1].timestamp;
                
        //         // Show 5 time labels
        //         for (let i = 0; i <= 4; i++) {
        //             const timePoint = new Date(startTime.getTime() + (endTime.getTime() - startTime.getTime()) * i / 4);
        //             const x = padding + (width * i / 4);
        //             const timeStr = timePoint.toLocaleTimeString('en-US', { 
        //                 hour: '2-digit', 
        //                 minute: '2-digit' 
        //             });
        //             ctx.fillText(timeStr, x, padding + height + 10);
        //         }
        //     }

        //     // Axis titles
        //     ctx.textAlign = 'center';
        //     ctx.textBaseline = 'middle';
        //     ctx.font = 'bold 14px Segoe UI';
            
        //     // Y-axis title
        //     ctx.save();
        //     ctx.translate(20, padding + height / 2);
        //     ctx.rotate(-Math.PI / 2);
        //     ctx.fillText('Point Value', 0, 0);
        //     ctx.restore();
            
        //     // X-axis title
        //     ctx.fillText('Time', padding + width / 2, padding + height + 40);
        // }
        

function drawGraph(unitName, pointName, timeRange) {
    console.log(`üé® Starting drawGraph for ${unitName} - ${pointName} with timeRange: ${timeRange}`);
    
    const canvas = document.getElementById('graphCanvas');
    const noDataMessage = document.getElementById('noDataMessage');
    const graphLegend = document.getElementById('graphLegend');
    const graphStats = document.getElementById('graphStats');
    
    if (!canvas) {
        console.log('‚ùå Canvas not found');
        return;
    }

    const selectedDate = getSelectedDate();
    if (!selectedDate) {
        console.log('‚ùå No date selected');
        clearGraph();
        return;
    }

    const ctx = canvas.getContext('2d');
    
    // Set canvas size
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    // STEP 1: Get data for selected date only
    let filteredData = getFilteredEventLogsByDate(unitName, pointName);
    console.log(`üìä After date filtering: ${filteredData.length} points for ${selectedDate.dateString}`);
    
    // STEP 2: Apply time range filter within the selected date (if not 'all')
    if (timeRange !== 'all' && !timeRange.includes('All Data') && timeRange !== undefined) {
        const minutesBack = parseInt(timeRange);
        if (!isNaN(minutesBack)) {
            // Calculate cutoff time from the END of the selected day
            const cutoffTime = new Date(selectedDate.endOfDay.getTime() - (minutesBack * 60 * 1000));
            console.log(`‚è∞ Applying time filter: last ${minutesBack} minutes from ${cutoffTime}`);
            
            const beforeTimeFilter = filteredData.length;
            filteredData = filteredData.filter(log => {
                const logTime = new Date(log.timestamp);
                return logTime >= cutoffTime;
            });
            console.log(`‚è∞ After time filtering: ${filteredData.length} points (was ${beforeTimeFilter})`);
        }
    }

    // Convert to graph format
    filteredData = filteredData.map(log => ({
        timestamp: new Date(log.timestamp),
        timestampString: log.timestamp,
        value: log.value,
        changed: log.isStateChange || false,
        pointName: log.pointName
    }));

    // Sort by timestamp
    filteredData.sort((a, b) => a.timestamp - b.timestamp);

    console.log(`üìà Final data points for graph: ${filteredData.length}`);

    // Show no data message if empty
    if (filteredData.length === 0) {
        const dateStr = selectedDate.dateString;
        noDataMessage.textContent = `No data found for ${unitName} - ${pointName} on ${dateStr}`;
        noDataMessage.style.display = 'block';
        canvas.style.display = 'none';
        graphLegend.innerHTML = '';
        graphStats.innerHTML = '';
        console.log('‚ùå No data to display');
        return;
    }

    // Show the graph
    noDataMessage.style.display = 'none';
    canvas.style.display = 'block';

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Graph dimensions
    const padding = 60;
    const graphWidth = canvas.width - (padding * 2);
    const graphHeight = canvas.height - (padding * 2);

    // Draw background
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim() || '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw grid
    drawGrid(ctx, padding, graphWidth, graphHeight);

    // CRITICAL FIX: Use drawAxesWithDate instead of drawAxes
    drawAxesWithDate(ctx, padding, graphWidth, graphHeight, filteredData);

    // Draw data line using the FIXED function
    drawDataLine(ctx, padding, graphWidth, graphHeight, filteredData);

    // Update legend and stats
    updateGraphLegend(unitName, pointName, filteredData);
    updateGraphStats(filteredData);
    
    console.log(`‚úÖ Graph completed for ${selectedDate.dateString}`);
}
        
        
//         function drawDataLine(ctx, padding, width, height, data) {
//     if (data.length === 0) return;

//     const selectedDate = getSelectedDate();
//     if (!selectedDate) return;

//     // CRITICAL FIX: Use the full selected day range for X-axis positioning, not data range
//     const startTime = selectedDate.startOfDay.getTime();
//     const endTime = selectedDate.endOfDay.getTime();
//     const timeRange = endTime - startTime;

//     console.log(`üìä Drawing data line with day range: ${new Date(startTime)} to ${new Date(endTime)}`);
//     console.log(`üìä Data points to plot: ${data.length}`);

//     // Draw step line
//     ctx.strokeStyle = '#3498db';
//     ctx.lineWidth = 3;
//     ctx.lineCap = 'round';
//     ctx.lineJoin = 'round';

//     ctx.beginPath();
    
//     for (let i = 0; i < data.length; i++) {
//         const entry = data[i];
        
//         // Position X based on the FULL DAY range, not the data range
//         const x = padding + (width * (entry.timestamp.getTime() - startTime) / timeRange);
//         const y = padding + (entry.value ? height * 0.25 : height * 0.75);

//         if (i === 0) {
//             ctx.moveTo(x, y);
//         } else {
//             // Create step line (horizontal then vertical)
//             const prevY = padding + (data[i-1].value ? height * 0.25 : height * 0.75);
//             ctx.lineTo(x, prevY); // Horizontal line
//             ctx.lineTo(x, y); // Vertical line
//         }
        
//         console.log(`üìç Point ${i}: ${entry.timestamp.toLocaleTimeString()} at x=${Math.round(x)}, y=${Math.round(y)}`);
//     }
    
//     ctx.stroke();

//     // Draw data points using the same X positioning
//     data.forEach((entry, index) => {
//         const x = padding + (width * (entry.timestamp.getTime() - startTime) / timeRange);
//         const y = padding + (entry.value ? height * 0.25 : height * 0.75);
        
//         ctx.beginPath();
//         ctx.arc(x, y, entry.changed ? 6 : 4, 0, 2 * Math.PI);
//         ctx.fillStyle = entry.changed ? '#e74c3c' : '#3498db';
//         ctx.fill();
        
//         // Highlight state changes
//         if (entry.changed) {
//             ctx.strokeStyle = '#fff';
//             ctx.lineWidth = 2;
//             ctx.stroke();
//         }
//     });
// }

// Fixed drawDataLine function with proper bounds checking
function drawDataLine(ctx, padding, width, height, data) {
    if (data.length === 0) return;

    const selectedDate = getSelectedDate();
    if (!selectedDate) return;

    // Use the full selected day range for X-axis positioning
    const startTime = selectedDate.startOfDay.getTime();
    const endTime = selectedDate.endOfDay.getTime();
    const timeRange = endTime - startTime;

    console.log(`üìä Drawing data line with day range: ${new Date(startTime)} to ${new Date(endTime)}`);
    console.log(`üìä Data points to plot: ${data.length}`);

    // Draw step line
    ctx.strokeStyle = '#3498db';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    ctx.beginPath();
    
    let hasValidPoints = false;
    
    for (let i = 0; i < data.length; i++) {
        const entry = data[i];
        
        // Position X based on the FULL DAY range
        const x = padding + (width * (entry.timestamp.getTime() - startTime) / timeRange);
        const y = padding + (entry.value ? height * 0.25 : height * 0.75);

        // Only plot points that are within the visible area
        if (x >= padding && x <= padding + width) {
            if (!hasValidPoints) {
                ctx.moveTo(x, y);
                hasValidPoints = true;
            } else {
                // Create step line (horizontal then vertical)
                const prevY = padding + (data[i-1].value ? height * 0.25 : height * 0.75);
                ctx.lineTo(x, prevY); // Horizontal line
                ctx.lineTo(x, y); // Vertical line
            }
            
            console.log(`üìç Point ${i}: ${entry.timestamp.toLocaleTimeString()} at x=${Math.round(x)}, y=${Math.round(y)}`);
        }
    }
    
    if (hasValidPoints) {
        ctx.stroke();
    }

    // Draw data points using the same X positioning
    data.forEach((entry, index) => {
        const x = padding + (width * (entry.timestamp.getTime() - startTime) / timeRange);
        const y = padding + (entry.value ? height * 0.25 : height * 0.75);
        
        // Only draw points within visible area
        if (x >= padding && x <= padding + width) {
            ctx.beginPath();
            ctx.arc(x, y, entry.changed ? 6 : 4, 0, 2 * Math.PI);
            ctx.fillStyle = entry.changed ? '#e74c3c' : '#3498db';
            ctx.fill();
            
            // Highlight state changes
            if (entry.changed) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
    });
}

        function updateGraphLegend(unitName, pointName, data) {
            const graphLegend = document.getElementById('graphLegend');
            if (!graphLegend) return;

            graphLegend.innerHTML = `
                <div class="legend-item">
                    <div class="legend-color" style="background: #3498db;"></div>
                    <span>Data Line</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e74c3c; height: 6px; border-radius: 50%;"></div>
                    <span>State Changes</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2c3e50; height: 4px; border-radius: 50%;"></div>
                    <span>Data Points</span>
                </div>
            `;
        }

        function updateGraphStats(data) {
            const graphStats = document.getElementById('graphStats');
            if (!graphStats) return;

            // Calculate statistics
            const totalPoints = data.length;
            const stateChanges = data.filter(entry => entry.changed).length;
            const trueCount = data.filter(entry => entry.value === true).length;
            const falseCount = data.filter(entry => entry.value === false).length;
            const uptime = totalPoints > 0 ? ((trueCount / totalPoints) * 100).toFixed(1) : 0;

            graphStats.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${totalPoints}</div>
                    <div class="stat-label">Total Data Points</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stateChanges}</div>
                    <div class="stat-label">State Changes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${uptime}%</div>
                    <div class="stat-label">TRUE Ratio</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${data.length > 0 ? new Date(data[data.length - 1].timestamp).toLocaleTimeString() : 'N/A'}</div>
                    <div class="stat-label">Last Update</div>
                </div>
            `;
        }

        function clearGraph() {
            const canvas = document.getElementById('graphCanvas');
            const noDataMessage = document.getElementById('noDataMessage');
            const graphLegend = document.getElementById('graphLegend');
            const graphStats = document.getElementById('graphStats');
            
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                canvas.style.display = 'none';
            }
            
            if (noDataMessage) {
                noDataMessage.textContent = 'Select a unit and point to view graph data.';
                noDataMessage.style.display = 'block';
            }
            
            if (graphLegend) graphLegend.innerHTML = '';
            if (graphStats) graphStats.innerHTML = '';
        }

        function toggleGraphViewer() {
            const graphViewer = document.getElementById('graphViewer');
            const mainView = document.getElementById('mainView');
            
            if (!graphViewer || !mainView) return;

            graphViewerActive = !graphViewerActive;

            if (graphViewerActive) {
                graphViewer.classList.add('active');
                mainView.classList.add('hidden');
                
                // Initialize graph viewer data
                populateUnitSelector();
                clearGraph();
                
                // Update button text
                const button = document.querySelector('button[onclick="toggleGraphViewer()"]');
                if (button) button.innerHTML = 'üìä View Graphs';
            } else {
                graphViewer.classList.remove('active');
                mainView.classList.remove('hidden');
                
                // Update button text
                const button = document.querySelector('button[onclick="toggleGraphViewer()"]');
                if (button) button.innerHTML = 'üìä View Graphs';
            }
        }

        // Dark mode toggle
        document.addEventListener('DOMContentLoaded', function() {
            const toggleSwitch = document.getElementById('toggleSwitch');
            const toggleLabel = document.querySelector('.toggle-label');
            
            // Check for saved theme preference or default to light mode
            const currentTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', currentTheme);
            
            if (currentTheme === 'dark') {
                toggleSwitch.classList.add('active');
                toggleLabel.textContent = 'Dark Mode';
            } else {
                toggleLabel.textContent = 'Light Mode';
            }
            
            toggleSwitch.addEventListener('click', function() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
                
                if (newTheme === 'dark') {
                    toggleSwitch.classList.add('active');
                    toggleLabel.textContent = 'Dark Mode';
                } else {
                    toggleSwitch.classList.remove('active');
                    toggleLabel.textContent = 'Light Mode';
                }
                
                // Redraw graph if active to update colors
                if (graphViewerActive) {
                    updateGraph();
                }
            });
        });

        // Resize canvas when window resizes
        window.addEventListener('resize', function() {
            if (graphViewerActive) {
                setTimeout(updateGraph, 100);
            }
        });

        // Subscribe to global data changes to auto-update graphs
        GlobalData.subscribe(function(unitName, oldState, newState, timestamp) {
            // If graph viewer is active and showing data for this unit, refresh the graph
            if (graphViewerActive) {
                const unitSelector = document.getElementById('unitSelector');
                if (unitSelector && unitSelector.value === unitName) {
                    setTimeout(updateGraph, 100);
                }
            }
        });

   
        // Add export button to graph controls when graph viewer is initialized
        function addExportButton() {
            const graphControls = document.querySelector('.graph-controls');
            if (graphControls && !document.getElementById('exportGraphBtn')) {
                const exportBtn = document.createElement('button');
                exportBtn.id = 'exportGraphBtn';
                exportBtn.className = 'btn btn-info';
                exportBtn.onclick = exportGraphData;
                exportBtn.innerHTML = 'üìà Export Graph Data';
                graphControls.appendChild(exportBtn);
            }
        }

        // Enhanced toggle function with export button
        function toggleGraphViewer() {
            const graphViewer = document.getElementById('graphViewer');
            const mainView = document.getElementById('mainView');
            
            if (!graphViewer || !mainView) return;

            graphViewerActive = !graphViewerActive;

            if (graphViewerActive) {
                graphViewer.classList.add('active');
                mainView.classList.add('hidden');
                
                // Initialize graph viewer data
                populateUnitSelector();
                clearGraph();
                addExportButton();
                
                // Update button text
                const button = document.querySelector('.controls button[onclick="toggleGraphViewer()"]');
                if (button) button.innerHTML = '‚Üê Back to Logs';
            } else {
                graphViewer.classList.remove('active');
                mainView.classList.remove('hidden');
                
                // Update button text
                const button = document.querySelector('.controls button[onclick="toggleGraphViewer()"]');
                if (button) button.innerHTML = 'üìä View Graphs';
            }
        }

        // Initialize everything when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize graph viewer
            setTimeout(initializeGraphViewer, 1000);
            
            // Dark mode toggle functionality
            const toggleSwitch = document.getElementById('toggleSwitch');
            const toggleLabel = document.querySelector('.toggle-label');
            
            // Check for saved theme preference or default to light mode
            const currentTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', currentTheme);
            
            if (currentTheme === 'dark') {
                toggleSwitch.classList.add('active');
                toggleLabel.textContent = 'Dark Mode';
            } else {
                toggleLabel.textContent = 'Light Mode';
            }
            
            toggleSwitch.addEventListener('click', function() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
                
                if (newTheme === 'dark') {
                    toggleSwitch.classList.add('active');
                    toggleLabel.textContent = 'Dark Mode';
                } else {
                    toggleSwitch.classList.remove('active');
                    toggleLabel.textContent = 'Light Mode';
                }
                
                // Redraw graph if active to update colors
                if (graphViewerActive) {
                    setTimeout(updateGraph, 100);
                }
            });
        });

        // Keyboard shortcuts for graph viewer
        document.addEventListener('keydown', function(e) {
            // Ctrl/Cmd + G to toggle graph viewer
            if ((e.ctrlKey || e.metaKey) && e.key === 'g') {
                e.preventDefault();
                toggleGraphViewer();
            }
            
            // Escape key to go back to logs from graph viewer
            if (e.key === 'Escape' && graphViewerActive) {
                toggleGraphViewer();
            }
        });

        // Performance optimization: Only update graph if it's visible
        function optimizedUpdateGraph() {
            if (graphViewerActive && document.getElementById('graphViewer').classList.contains('active')) {
                updateGraph();
            }
        }

        // Auto-refresh graph data every 10 seconds when in graph view
        setInterval(function() {
            if (graphViewerActive) {
                const unitSelector = document.getElementById('unitSelector');
                const pointSelector = document.getElementById('pointSelector');
                
                if (unitSelector && pointSelector && unitSelector.value && pointSelector.value) {
                    optimizedUpdateGraph();
                }
            }
        }, 10000);

        // Add tooltip functionality for data points
        function addGraphTooltips() {
            const canvas = document.getElementById('graphCanvas');
            if (!canvas) return;

            canvas.addEventListener('mousemove', function(e) {
                // This would show tooltips on hover - simplified for demo
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Tooltip logic would go here for production use
                canvas.title = `Click and drag to zoom, double-click to reset view`;
            });
        }

        // Initialize tooltips when graph viewer is ready
        setTimeout(addGraphTooltips, 2000);

        console.log('üéØ Enhanced Niagara System Monitor with Graphing Ready!');
        console.log('üìä Use Ctrl+G to toggle graph viewer');
        console.log('üîÑ Graphs auto-refresh every 10 seconds');
        console.log('üìà Export functionality available for graph data');
   
   
    </script>


</body>
</html>
